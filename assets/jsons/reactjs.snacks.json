[{"id":3,"codersnack":{"id":4,"header":"What is React?","created_at":"2019-12-31T20:04:40.879Z","updated_at":"2020-01-20T15:00:42.381Z","explanation":"React is a free, unlicensed JS library focused in **UI management**.\n\nCreated by **Facebook**,React was initially released in 2013.\n\nReact has some unique core concepts. It has a virtual DOM, JSX components, input properties, and props. Also, each React component has a state and a lifecycle.\n\n#### Virtual DOM\nInstead of constantly having to work with the real DOM, which is very expensive, everything is handled virtually until we absolutely need to update the DOM.\n\n#### JSX \nIt is officially an XML-like syntax that is close to HTML, but not quite HTML. It is actually JavaScript with HTML sprinkled in.\n\nExample\n\n```\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n","references":"- [Fun with React - A quick overview](https://www.telerik.com/blogs/fun-with-react-a-quick-overview)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"react-what-is","weblink":"https://codersnack.com/react-what-is/","featured_image_preview":{"id":8,"name":"logo-reactjs.png","hash":"51404cadac89402c960c70f6a9cc9b4a","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/51404cadac89402c960c70f6a9cc9b4a.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T20:04:40.889Z","updated_at":"2019-12-31T20:04:40.889Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"ReactJS - What is ReactJS","created_at":"2019-12-31T20:14:05.872Z","updated_at":"2019-12-31T20:17:02.216Z"},{"id":9,"codersnack":{"id":9,"header":"ReactJS - Introducing JSX","created_at":"2020-01-09T19:50:14.060Z","updated_at":"2020-01-20T15:04:09.637Z","explanation":"Consider this variable declaration:\n\n```\nconst element = <h1>Hello, world!</h1>;\n```\n\nThis funny tag syntax is neither a string nor HTML.\n\nIt is called JSX, and it is a **syntax extension to JavaScript**. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.\n\n**JSX produces React \"elements\"**.\n\n\n### Why JSX?\n\n**React embraces the fact that rendering logic is inherently coupled** with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.\n\nInstead of artificially separating technologies by putting markup and logic in separate files, **React separates concerns with loosely coupled units called \"components\" that contain both**. We will come back to components in a further section, but if you’re not yet comfortable putting markup in JS, this talk - https://www.youtube.com/watch?v=x7cQ3mrcKaY -  might convince you otherwise.\n\nReact doesn't require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.\n\n### JSX Represents Objects\nBabel compiles JSX down to React.createElement() calls.\n\nThese two examples are identical:\n```\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n\n```\n**React.createElement()** *performs a few checks to help you write bug-free code* but essentially it creates an object like this:\n\n```\n// Note: this structure is simplified\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world!'\n  }\n};\n```\n\n**These objects are called React elements.**. You can think of them as *descriptions of what you want to see on the screen*. React reads these objects and uses them to construct the DOM and keep it up to date.\n","references":"- [Reactjs.org - Introducing JSX](https://reactjs.org/docs/introducing-jsx.html)\n- [Why Jsx talk](https://www.youtube.com/watch?v=x7cQ3mrcKaY)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-introducing-jsx","weblink":"https://codersnack.com/reactjs-introducing-jsx","featured_image_preview":{"id":12,"name":"logo-reactjs.png","hash":"39731a1caf194ab78276d07a65d53f50","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/39731a1caf194ab78276d07a65d53f50.png","provider":"local","provider_metadata":null,"created_at":"2020-01-09T19:50:14.078Z","updated_at":"2020-01-09T19:50:14.078Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"Reactjs Introducing JSX","created_at":"2020-01-09T19:50:45.655Z","updated_at":"2020-01-09T19:50:45.660Z"},{"id":10,"codersnack":{"id":10,"header":"ReactJS - Components and Props","created_at":"2020-01-09T20:24:47.496Z","updated_at":"2020-01-20T14:58:00.472Z","explanation":"> Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. \n\n**Conceptually, components are like JavaScript functions**. They accept arbitrary inputs (called *props*) and return React elements describing what should appear on the screen.\n\n### Function and Class Components\nThe simplest way to define a component is to write a JavaScript function:\n```\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\nThis function is a valid React component because it accepts a single *props* (which stands for properties) object argument with data and *returns a React element*. We call such components *function components* because they are literally JavaScript functions.\n\nYou can also *use an ES6 class to define a component*:\n```\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\nThe above two components are equivalent from Reacts point of view.\n\n*Classes have some additional features* that we will discuss in the next sections. Until then, we will use function components for their conciseness.\n\n### Props are Read-Only\nWhether you declare a component as a function or a class, it must *never modify its own props*. Consider this sum function:\n```\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\nSuch functions are called *pure* because they do not attempt to change their inputs, and always return the same result for the same inputs.\n\nIn contrast, *this function is impure* because it changes its own input:\n```\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n\nReact is pretty flexible but it has a single strict rule:\n\n> All React components must act like pure functions with respect to their props.\n\nOf course, *application UIs are dynamic and change over time*. In the next section,*we will introduce a new concept of state*. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.","references":"- [ReactJS - Components and props](https://reactjs.org/docs/components-and-props.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-components-and-props","weblink":"https://codersnack.com/reactjs-components-and-props","featured_image_preview":{"id":14,"name":"logo-reactjs.png","hash":"f3090bf35fe04b8e8b7caa565a5a52bb","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/f3090bf35fe04b8e8b7caa565a5a52bb.png","provider":"local","provider_metadata":null,"created_at":"2020-01-09T20:24:47.507Z","updated_at":"2020-01-09T20:24:47.507Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"reactjs - components and props","created_at":"2020-01-09T20:25:24.831Z","updated_at":"2020-01-09T20:25:24.835Z"},{"id":11,"codersnack":{"id":11,"header":"ReactJS - States","created_at":"2020-01-09T21:11:21.628Z","updated_at":"2020-01-20T15:06:43.073Z","explanation":"> State is similar to props, but it is private and fully controlled by the component.\n\nConsider this ticking clock example. By now, we only call *ReactDOM.render()* to change the rendered output:\n```\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n\n```\n\nIn this snack, we will learn how to make the *Clock* component truly reusable and encapsulated. It will set up its own timer and update itself every second.\n\nWe can start by encapsulating how the clock looks:\n\n```\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\nHowever, it misses a crucial requirement: the fact that the *Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock*.\n\nIdeally we want to write this once and have the Clock update itself:\n\n```\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\nTo implement this, *we need to add \"state\" to the Clock component*.\n\n**State is similar to props, but it is private and fully controlled by the component.**\n\n### Converting a Function to a Class\nYou can convert a function component like Clock to a class in five steps:\n- Create an **ES6 class**, with the same name, that extends React.Component.- \n- Add a single empty method to it called **render()**. \n- Move the body of the function into the render() method. \n- *Replace props with this.props* in the render() body. \n- Delete the remaining empty function declaration.\n\n```\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\nClock is now defined as a class rather than a function.\n\n**The render method will be called each time an update happens**, but as long as we render <Clock /> into the same DOM node, only a single instance of the Clock class will be used. This lets us use additional features such as local state and lifecycle methods.\n\n### Adding Local State to a Class\nWe will move the date from props to state in three steps:\n\n1.- Replace this.props.date with **this.state.date** in the render() method:\n```\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n2.-**Add a class constructor that assigns the initial this.state**:\n```\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\nNote how we pass props to the base constructor:\n\n```\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n```\n\n> Class components should always call the base constructor with props.\n\n3.- Remove the date prop from the <Clock /> element:\n```\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\nWe will later add the timer code back to the component itself.\n\nThe result looks like this:\n\n```\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n","references":"- [ReactJS - State and Lifecycle](https://reactjs.org/docs/state-and-lifecycle.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-states","weblink":"https://codersnack.com/reactjs-states","featured_image_preview":{"id":15,"name":"logo-reactjs.png","hash":"dafd60fe7d604cde80f742be9647a01a","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/dafd60fe7d604cde80f742be9647a01a.png","provider":"local","provider_metadata":null,"created_at":"2020-01-09T21:11:21.659Z","updated_at":"2020-01-09T21:11:21.659Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"reactjs - states","created_at":"2020-01-09T21:11:53.776Z","updated_at":"2020-01-09T21:11:53.780Z"},{"id":29,"codersnack":{"id":30,"header":"ReactJS - Typechecking with PropTypes","created_at":"2020-01-28T15:04:52.787Z","updated_at":"2020-01-30T22:55:07.171Z","explanation":"As your app grows, you can catch a lot of bugs with typechecking. For some applications, you can use JavaScript extensions like Flow or TypeScript to typecheck your whole application. But even if you don’t use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special propTypes property:\n\n\n```\nimport PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n```\n\n>Note: React.PropTypes has moved into a different package since React v15.5. Please use the prop-types library instead.\n\n**PropTypes exports a range of validators that can be used to make sure the data you receive is valid**. In this example, we're using *PropTypes.string*. When an invalid value is provided for a prop, a **warning will be shown in the JavaScript console**. For performance reasons, *propTypes is only checked in development mode*.\n\n#### PropTypes\nHere is an example documenting the different validators provided:\n\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS type. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // A React element type (ie. MyComponent).\n  optionalElementType: PropTypes.elementType,\n  \n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n  \n  // An object with warnings on extra properties\n  optionalObjectWithStrictShape: PropTypes.exact({\n    name: PropTypes.string,\n    quantity: PropTypes.number\n  }),   \n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n\n#### Requiring Single Child\nWith *PropTypes.element* you can specify that **only a single child can be passed to a component as children**.\n```\nimport PropTypes from 'prop-types';\n\nclass MyComponent extends React.Component {\n  render() {\n    // This must be exactly one element or it will warn.\n    const children = this.props.children;\n    return (\n      <div>\n        {children}\n      </div>\n    );\n  }\n}\n\nMyComponent.propTypes = {\n  children: PropTypes.element.isRequired\n};\n```\n\n#### Default Prop Values\nYou can define **default values for your props** by assigning to the special *defaultProps* property:\n```\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\n// Specifies the default values for props:\nGreeting.defaultProps = {\n  name: 'Stranger'\n};\n\n// Renders \"Hello, Stranger\":\nReactDOM.render(\n  <Greeting />,\n  document.getElementById('example')\n);\n```\nIf you are **using a Babel transform like transform-class-properties** , you can also declare *defaultProps* as static property within a React component class. This syntax has not yet been finalized though and will require a compilation step to work within a browser. For more information, see the class fields proposal.\n\n```\nclass Greeting extends React.Component {\n  static defaultProps = {\n    name: 'stranger'\n  }\n\n  render() {\n    return (\n      <div>Hello, {this.props.name}</div>\n    )\n  }\n}\n```\n\nThe *defaultProps* will be used to ensure that *this.props.name* will have a value if it was not specified by the parent component. The *propTypes* typechecking happens after *defaultProps* are resolved, so typechecking will also apply to the *defaultProps*.","references":"- [Reactjs.org - Typechecking with proptypes](https://reactjs.org/docs/typechecking-with-proptypes.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-typechecking-proptypes","weblink":"https://codersnack.com/reactjs-typechecking-proptypes/","featured_image_preview":{"id":39,"name":"logo-reactjs.png","hash":"469760b168f34a5db684d2eeb92d200f","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/469760b168f34a5db684d2eeb92d200f.png","provider":"local","provider_metadata":null,"created_at":"2020-01-28T15:04:52.807Z","updated_at":"2020-01-28T15:04:52.807Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"Reactjs Typechecking with PropTypes","created_at":"2020-01-28T15:05:38.417Z","updated_at":"2020-01-28T15:05:38.420Z"},{"id":30,"codersnack":{"id":31,"header":"ReactJS - Lifecycle methods","created_at":"2020-01-28T15:59:20.239Z","updated_at":"2020-01-30T22:56:43.257Z","explanation":"Lifecycle methods are **custom functionality that gets executed during the different phases of a component**. There are methods available when the component gets created and inserted into the DOM (mounting), when the component updates, and when the component gets unmounted or removed from the DOM.\n\n#### Adding Lifecycle Methods to a Class\nIn applications with many components, **it's very important to free up resources taken by the components when they are destroyed**. We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called \"mounting\" in React.We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called \"unmounting\" in React.We can declare special methods on the component class to run some code when a component mounts and unmounts:\n\n```\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\nThese methods are called **\"lifecycle methods\"**.\n\nThe **componentDidMount()** method **runs after the component output has been rendered to the DOM**. This is a good place to set up a timer:\n```\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n```\n>Note how we save the timer ID right on this (this.timerID).\n\n>While *this.props* is set up by React itself and *this.state* has a special meaning, you are *free to add additional fields to the class* manually if you need to store something that doesn’t participate in the data flow (like a timer ID).\n\nWe will tear down the timer in the *componentWillUnmount()* lifecycle method:\n```\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n```\nFinally, we will implement a method called *tick()* that the *Clock* component will run every second.\n\nIt will use *this.setState()* to schedule updates to the component local state:\n\n```\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\nNow the clock ticks every second.\n\nLet’s quickly recap what’s going on and the order in which the methods are called:\n\n- When `<Clock />` is passed to *ReactDOM.render()*, React calls the constructor of the *Clock* component. Since *Clock* needs to display the current time, it initializes *this.state* with an object including the current time. We will later update this state.\n\n- React then **calls the *Clock* component's *render()* method**. This is how React learns what should be displayed on the screen. React then *updates the DOM* to match the Clock’s render output.\n\n- When the *Clock* output is inserted in the DOM, React **calls the *componentDidMount()* lifecycle method**. Inside it, the *Clock* component asks the browser to set up a timer to call the component’s *tick()* method once a second.\n\n- Every second the browser calls the *tick()* method. Inside it, the *Clock* component schedules a UI update by calling *setState()* with an object containing the current time. Thanks to the *setState()* call, React knows **the state has changed, and calls the *render()* method again to learn what should be on the screen**. This time, *this.state.date* in the *render()* method will be different, and so the render output will include the updated time. React updates the DOM accordingly.\n\n- If the *Clock* component is ever removed from the DOM, React calls the *componentWillUnmount()*  lifecycle method so the timer is stopped.","references":"- [Reactjs.org - Adding lifecycle methods to a class](https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-lifecycle-methods","weblink":"https://codersnack.com/reactjs-lifecycle-methods/","featured_image_preview":{"id":40,"name":"logo-reactjs.png","hash":"6532f660b2cb44c9a055b7d4603a4863","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/6532f660b2cb44c9a055b7d4603a4863.png","provider":"local","provider_metadata":null,"created_at":"2020-01-28T15:59:20.252Z","updated_at":"2020-01-28T15:59:20.252Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"ReactJS Lifecycle methods","created_at":"2020-01-28T16:00:10.748Z","updated_at":"2020-01-28T16:00:10.750Z"},{"id":31,"codersnack":{"id":32,"header":"ReactJS Forms","created_at":"2020-01-28T17:06:57.842Z","updated_at":"2020-01-28T17:06:57.842Z","explanation":"*HTML form elements work a little bit differently from other DOM elements in React,* because **form elements naturally keep some internal state**. For example, this form in plain HTML accepts a single name:\n```\n<form>\n  <label>\n    Name:\n    <input type=\"text\" name=\"name\" />\n  </label>\n  <input type=\"submit\" value=\"Submit\" />\n</form>\n```\nThis form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases,*it’s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form*. The standard way to achieve this is with a technique called **\"controlled components\"**.\n\n#### Controlled Components\nIn HTML, form elements such as `<input>` , `<textarea>` , and `<select>`  typically maintain their own state and update it based on user input. *In React, mutable state is typically kept in the state property of components, and only updated with setState()*.\n\nWe can combine the two by making the React state be the \"single source of truth\". Then the **React component that renders a form also controls what happens in that form on subsequent user input.An input form element whose value is controlled by React in this way is called a \"controlled component\"**.\n\nFor example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:\n\n```\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\nSince the *value* attribute is set on our form element, the displayed value will always be *this.state.value*, making the **React state the source of truth**. Since *handleChange* runs on every keystroke to update the React state, the displayed *value* will update as the user types.\n\nWith a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write handleChange as:\n```\nhandleChange(event) {\n  this.setState({value: event.target.value.toUpperCase()});\n}\n```\n\n#### Uncontrolled Components\nIn most cases, we recommend using controlled components to implement forms. In a controlled component, form data is handled by a React component. The alternative is **uncontrolled components, where form data is handled by the DOM itself**.\n\nTo write an uncontrolled component, **instead of writing an event handler for every state update, you can use a *ref* to get form values from the DOM**.\n\nFor example, this code accepts a single name in an uncontrolled component:\n\n```\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.input = React.createRef();\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.current.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={this.input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\nSince an **uncontrolled component keeps the source of truth in the DOM**, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.","references":"- [Reactjs.org - Uncontrolled components](https://reactjs.org/docs/uncontrolled-components.html)\n- [Reactjs.org - Controlled components](https://reactjs.org/docs/forms.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-forms","weblink":"https://codersnack.com/reactjs-forms/","featured_image_preview":{"id":41,"name":"logo-reactjs.png","hash":"6d696c79d00f44ff847d7697246bf2f3","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/6d696c79d00f44ff847d7697246bf2f3.png","provider":"local","provider_metadata":null,"created_at":"2020-01-28T17:06:57.856Z","updated_at":"2020-01-28T17:06:57.856Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"ReactJs forms","created_at":"2020-01-28T17:07:18.923Z","updated_at":"2020-01-28T17:07:18.925Z"},{"id":33,"codersnack":{"id":34,"header":"ReactJS - Higher Order Components","created_at":"2020-01-31T13:58:35.656Z","updated_at":"2020-01-31T14:22:05.280Z","explanation":"**A higher-order component (HOC) is an advanced technique in React for reusing component logic.** HOCs are not part of the React API, per se. They are a pattern that emerges from React's compositional nature.\n\nConcretely, **a higher-order component is a function that takes a component and returns a new component.**\n\n``` \nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n``` \n\nWhereas a component transforms props into UI, a higher-order component transforms a component into another component.\n\n**HOCs are common in third-party React libraries**, such as *Redux’s connect* and *Relay's createFragmentContainer*.\n\nIn this document, we’ll discuss why higher-order components are useful, and how to write your own.\n\n#### Use HOCs For Cross-Cutting Concerns\n\n>Note: We previously recommended mixins as a way to handle cross-cutting concerns. We’ve since realized that mixins create more trouble than they are worth. Read more about why we’ve moved away from mixins and how you can transition your existing components.\n\n**Components are the primary unit of code reuse in React**. However, you’ll find that **some patterns aren’t a straightforward fit for traditional components**.\n\nFor example, say you have a *CommentList* component that subscribes to an external data source to render a list of comments:\n\n``` \nclass CommentList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      // \"DataSource\" is some global data source\n      comments: DataSource.getComments()\n    };\n  }\n\n  componentDidMount() {\n    // Subscribe to changes\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    // Clean up listener\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    // Update component state whenever the data source changes\n    this.setState({\n      comments: DataSource.getComments()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        {this.state.comments.map((comment) => (\n          <Comment comment={comment} key={comment.id} />\n        ))}\n      </div>\n    );\n  }\n}\n``` \n\nLater, you write a component for subscribing to a single blog post, which follows a similar pattern:\n\n``` \nclass BlogPost extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    this.setState({\n      blogPost: DataSource.getBlogPost(this.props.id)\n    });\n  }\n\n  render() {\n    return <TextBlock text={this.state.blogPost} />;\n  }\n}\n``` \n\n*CommentList* and *BlogPost* aren't identical — they call different methods on *DataSource*, and they render different output. But much of their implementation is the same:\n\n- On mount, add a change listener to *DataSource*.\n- Inside the listener, call *setState* whenever the data source changes.\n- On unmount, remove the change listener.\n\nYou can imagine that in a large app, this same pattern of subscribing to *DataSource* and calling *setState* will occur over and over again. **We want an abstraction that allows us to define this logic in a single place and share it across many components**. This is where higher-order components excel.\n\nWe can write a function that creates components, like *CommentList* and *BlogPost*, that subscribe to *DataSource*. The function will *accept as one of its arguments a child component that receives the subscribed data as a prop*. Let’s call the function *withSubscription*:\n\n``` \nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id)\n);\n``` \n\nThe first parameter is the wrapped component. The second parameter retrieves the data we’re interested in, given a DataSource and the current props.\n\nWhen *CommentListWithSubscription* and *BlogPostWithSubscription* are rendered, *CommentList* and *BlogPost* will be passed a data prop with the most current data retrieved from DataSource:\n\n``` \n// This function takes a component...\nfunction withSubscription(WrappedComponent, selectData) {\n  // ...and returns another component...\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ... that takes care of the subscription...\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ... and renders the wrapped component with the fresh data!\n      // Notice that we pass through any additional props\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n``` \n\nNote that a HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC composes the original component by wrapping it in a container component. **A HOC is a pure function with zero side-effects**.\n\nAnd that's it! The wrapped component receives all the props of the container, along with a new prop, data, which it uses to render its output. The HOC isn't concerned with how or why the data is used, and the wrapped component isn’t concerned with where the data came from.\n\nBecause *withSubscription* is a normal function, you can add as many or as few arguments as you like. For example, you may want to make the name of the data prop configurable, to further isolate the HOC from the wrapped component. Or you could accept an argument that configures *shouldComponentUpdate*, or one that configures the data source. These are all possible because the HOC has full control over how the component is defined.\n\nLike components, the contract between *withSubscription* and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.","references":"- [ReactJS.org - Higher Order Components](https://reactjs.org/docs/higher-order-components.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-hocs","weblink":"https://codersnack.com/reactjs-hocs/","featured_image_preview":{"id":44,"name":"logo-reactjs.png","hash":"a05e6202199547babd57d695256f209b","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/a05e6202199547babd57d695256f209b.png","provider":"local","provider_metadata":null,"created_at":"2020-01-31T13:58:35.678Z","updated_at":"2020-01-31T13:58:35.678Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"Reactjs HOC","created_at":"2020-01-31T14:22:30.334Z","updated_at":"2020-01-31T14:22:30.337Z"},{"id":38,"codersnack":{"id":39,"header":"Reactjs Context","created_at":"2020-02-02T21:39:23.524Z","updated_at":"2020-02-02T21:39:23.524Z","explanation":"**Context provides a way to pass data through the component tree without having to pass props down manually at every level**.\n\n*In a typical React application, data is passed top-down* (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. *Context* provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.\n\n#### When to Use Context\n***Context* is designed to share data that can be considered \"global\" for a tree of React components**, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a *\"theme\"* prop in order to style the *Button* component:\n```\nclass App extends React.Component {\n  render() {\n    return <Toolbar theme=\"dark\" />;\n  }\n}\n\nfunction Toolbar(props) {\n  // The Toolbar component must take an extra \"theme\" prop\n  // and pass it to the ThemedButton. This can become painful\n  // if every single button in the app needs to know the theme\n  // because it would have to be passed through all components.\n  return (\n    <div>\n      <ThemedButton theme={props.theme} />\n    </div>\n  );\n}\n\nclass ThemedButton extends React.Component {\n  render() {\n    return <Button theme={this.props.theme} />;\n  }\n}\n```\n\nUsing context, we can avoid passing props through intermediate elements:\n\n```\n// Context lets us pass a value deep into the component tree\n// without explicitly threading it through every component.\n// Create a context for the current theme (with \"light\" as the default).\nconst ThemeContext = React.createContext('light');\n\nclass App extends React.Component {\n  render() {\n    // Use a Provider to pass the current theme to the tree below.\n    // Any component can read it, no matter how deep it is.\n    // In this example, we're passing \"dark\" as the current value.\n    return (\n      <ThemeContext.Provider value=\"dark\">\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\n\n// A component in the middle doesn't have to\n// pass the theme down explicitly anymore.\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nclass ThemedButton extends React.Component {\n  // Assign a contextType to read the current theme context.\n  // React will find the closest theme Provider above and use its value.\n  // In this example, the current theme is \"dark\".\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context} />;\n  }\n}\n```\n\n#### Before You Use Context\nContext is primarily used when some data needs to be accessible by many components at different nesting levels. **Apply it sparingly because it makes component reuse more difficult.**If you only want to avoid passing some props through many levels, **component composition** is often a simpler solution than context.\n\nFor **example**, consider a *Page* component that passes a *user* and *avatarSize* prop several levels down so that deeply nested *Link* and *Avatar* components can read it:\n```\n<Page user={user} avatarSize={avatarSize} />\n// ... which renders ...\n<PageLayout user={user} avatarSize={avatarSize} />\n// ... which renders ...\n<NavigationBar user={user} avatarSize={avatarSize} />\n// ... which renders ...\n<Link href={user.permalink}>\n  <Avatar user={user} size={avatarSize} />\n</Link>\n```\n\n**It might feel redundant to pass down the *user* and *avatarSize* props through many levels if in the end only the Avatar component really needs it**. It’s also annoying that whenever the *Avatar* component needs more props from the top, you have to add them at all the intermediate levels too.\n\n**One way to solve this issue without context is to pass down the Avatar component itself** so that the intermediate components don’t need to know about the user or avatarSize props:\n\n```\nfunction Page(props) {\n  const user = props.user;\n  const userLink = (\n    <Link href={user.permalink}>\n      <Avatar user={user} size={props.avatarSize} />\n    </Link>\n  );\n  return <PageLayout userLink={userLink} />;\n}\n\n// Now, we have:\n<Page user={user} avatarSize={avatarSize} />\n// ... which renders ...\n<PageLayout userLink={...} />\n// ... which renders ...\n<NavigationBar userLink={...} />\n// ... which renders ...\n{props.userLink}\n```\n\nWith this change, only the top-most Page component needs to know about the Link and Avatar components' use of user and avatarSize.\n\nThis inversion of control can make your code cleaner in many cases by reducing the amount of props you need to pass through your application and giving more control to the root components. However, this isn't the right choice in every case: **moving more complexity higher in the tree makes those higher-level components more complicated** and forces the lower-level components to be more flexible than you may want.\n\n**You’re not limited to a single child for a component. You may pass multiple children**, or even have multiple separate \"slots\" for children:\n\n```\nfunction Page(props) {\n  const user = props.user;\n  const content = <Feed user={user} />;\n  const topBar = (\n    <NavigationBar>\n      <Link href={user.permalink}>\n        <Avatar user={user} size={props.avatarSize} />\n      </Link>\n    </NavigationBar>\n  );\n  return (\n    <PageLayout\n      topBar={topBar}\n      content={content}\n    />\n  );\n}\n```\nThis pattern is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with render props if the child needs to communicate with the parent before rendering.\n\nHowever, **sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels**. **Context lets you \"broadcast\" such data, and changes to it**, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.\n","references":"- [Reacts.org - Context](https://reactjs.org/docs/context.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-context","weblink":"https://codersnack.com/reactjs-context/","featured_image_preview":{"id":50,"name":"logo-reactjs.png","hash":"a4dd400fbf344bd4960c9b3db9e17b7c","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/a4dd400fbf344bd4960c9b3db9e17b7c.png","provider":"local","provider_metadata":null,"created_at":"2020-02-02T21:39:23.538Z","updated_at":"2020-02-02T21:39:23.538Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"Reactjs Context","created_at":"2020-02-02T21:39:52.330Z","updated_at":"2020-02-02T21:39:52.334Z"},{"id":54,"codersnack":{"id":55,"header":"Reactjs Hooks Motivation","created_at":"2020-03-10T21:09:33.161Z","updated_at":"2020-03-10T21:09:33.161Z","explanation":"### Motivation\n\nHooks are a new addition in React 16.8. They **let you use state and other React features without writing a class**.\n\n\nHooks solve a wide variety of seemingly unconnected problems in React that we’ve encountered over five years of writing and maintaining tens of thousands of components. Whether you’re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.\n\n#### It's hard to reuse stateful logic between components\n**React doesn't offer a way to \"attach\" reusable behavior to a component (for example, connecting it to a store)**. If you've worked with React for a while, you may be familiar with patterns like render props and higher-order components that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a **\"wrapper hell\"** of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could filter them out in DevTools, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.\n\nWith Hooks, you can extract stateful logic from a component so it can be tested independently and reused. **Hooks allow you to reuse stateful logic without changing your component hierarchy**. This makes it easy to share Hooks among many components or with the community. More info google for \"Custom hooks\"\n\n#### Complex components become hard to understand\n**We’ve often had to maintain components that started out simple but grew into an unmanageable mess of stateful logic and side effects**. Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in componentDidMount and componentDidUpdate. However, the same componentDidMount method might also contain some unrelated logic that sets up event listeners, with cleanup performed in componentWillUnmount. Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.\n\nIn many cases **it's not possible to break these components into smaller ones** because the stateful logic is all over the place. It’s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.\n\nTo solve this, Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data), rather than forcing a split based on lifecycle methods. You may also opt into managing the component's local state with a reducer to make it more predictable.\n\nMore in Using the Effect Hook.\n\n#### Classes confuse both people and machines\nIn addition to making code reuse and code organization more difficult, we’ve found that **classes can be a large barrier to learning React**. You have to understand how this works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable syntax proposals, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.\n\nAdditionally, React has been out for about five years, and we want to make sure it stays relevant in the next five years. As Svelte, Angular, Glimmer, and others show, ahead-of-time compilation of components has a lot of future potential. Especially if it’s not limited to templates. Recently, we’ve been experimenting with component folding using Prepack, and we've seen promising early results. However, **we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path**. Classes present issues for today's tools, too. **For example, classes don’t minify very well, and they make hot reloading flaky and unreliable**. We want to present an API that makes it more likely for code to stay on the optimizable path.\n\nTo solve these problems, Hooks let you use more of React's features without classes. Conceptually, React components have always been closer to functions. Hooks embrace functions, but without sacrificing the practical spirit of React. Hooks provide access to imperative escape hatches and don’t require you to learn complex functional or reactive programming techniques.\n\n#### Gradual Adoption Strategy\n> TLDR: There are no plans to remove classes from React.\n\nWe know that React developers are focused on shipping products and don't have time to look into every new API that's being released. Hooks are very new, and it might be better to wait for more examples and tutorials before considering learning or adopting them.\n\nCrucially, **Hooks work side-by-side with existing code** so you can adopt them gradually.\n\n\n\n\n\n\n\n\n","references":"- [Reactjs.org Hooks Overview](https://reactjs.org/docs/hooks-overview.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-hooks-overview","weblink":"https://codersnack.com/reactjs-hooks-overview","featured_image_preview":{"id":72,"name":"reactjs-icon.png","hash":"a8f0b95cc5b2482bbe2e7f567fa2ce46","sha256":"PmVXpJ5g4o1kx3tUYPpFu1CS1wfvEx7u1CLaL54m9CQ","ext":".png","mime":"image/png","size":4.81,"url":"/uploads/a8f0b95cc5b2482bbe2e7f567fa2ce46.png","provider":"local","provider_metadata":null,"created_at":"2020-03-10T21:09:33.193Z","updated_at":"2020-03-10T21:09:33.193Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"Reactjs Hooks Motivation","created_at":"2020-03-10T21:09:59.429Z","updated_at":"2020-03-10T21:09:59.438Z"},{"id":55,"codersnack":{"id":56,"header":"ReactJS - Use State Correctly","created_at":"2020-03-16T15:36:26.199Z","updated_at":"2020-03-16T15:36:26.199Z","explanation":"There are three things you should know about setState().\n\n### Do Not Modify State Directly\nFor example, this will not re-render a component:\n```\n// Wrong\nthis.state.comment = 'Hello';\n```\nInstead, use setState():\n```\n// Correct\nthis.setState({comment: 'Hello'});\n```\n\n**The only place where you can assign this.state is the constructor**.\n\n### State Updates May Be Asynchronous\n**React may batch multiple ```setState()``` calls into a single update for performance**.\nBecause ```this.props``` and ```this.state``` may be updated asynchronously, you should not rely on their values for calculating the next state.\n\nFor example, this code may fail to update the counter:\n```\n// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});\n```\nTo fix it, use a second form of ```setState()``` that accepts a function rather than an object. **That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument**:\n```\n// Correct\nthis.setState((state, props) => ({\n  counter: state.counter + props.increment\n}));\n```\nWe used an arrow function above, but it also works with regular functions:\n```\n// Correct\nthis.setState(function(state, props) {\n  return {\n    counter: state.counter + props.increment\n  };\n});\n```\n### State Updates are Merged\nWhen you call ```setState()```, React merges the object you provide into the current state.\nFor example, your state may contain several independent variables:\n```\n  constructor(props) {\n    super(props);\n    this.state = {\n      posts: [],\n      comments: []\n    };\n  }\n```\nThen you can update them independently with separate ```setState()``` calls:\n```\n  componentDidMount() {\n    fetchPosts().then(response => {\n      this.setState({\n        posts: response.posts\n      });\n    });\n\n    fetchComments().then(response => {\n      this.setState({\n        comments: response.comments\n      });\n    });\n  }\n```\nThe merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments.\n\n","references":"- [ReactJS - Adding lifecycle methods to a class](https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-use-state-correctly","weblink":"https://codersnack.com/reactjs-use-state-correctly","featured_image_preview":{"id":73,"name":"reactjs-icon.png","hash":"aa7ba4aa2cd7424ba9ffff5fd14bdb0a","sha256":"PmVXpJ5g4o1kx3tUYPpFu1CS1wfvEx7u1CLaL54m9CQ","ext":".png","mime":"image/png","size":4.81,"url":"/uploads/aa7ba4aa2cd7424ba9ffff5fd14bdb0a.png","provider":"local","provider_metadata":null,"created_at":"2020-03-16T15:36:26.227Z","updated_at":"2020-03-16T15:36:26.227Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"ReactJs Use State Correctly","created_at":"2020-03-16T15:36:59.101Z","updated_at":"2020-03-16T15:36:59.105Z"},{"id":56,"codersnack":{"id":57,"header":"ReactJS - Hooks at a glance","created_at":"2020-03-16T19:39:30.647Z","updated_at":"2020-04-14T17:20:03.506Z","explanation":"\nHooks are **a new addition in React 16.8**. They **let you use state and other React features without writing a class**.\n\nHooks are **backwards-compatible**.\n\n### State Hook\nThis example renders a counter. When you click the button, it increments the value:\n```\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\nHere, ```useState``` is a *Hook*. We call it inside a function component to add some local state to it. React will preserve this state between re-renders. ```useState``` **returns a pair: the current state value and a function that lets you update it**. You can call this function from an event handler or somewhere else. It’s similar to ```this.setState``` in a class, except **it doesn’t merge the old and new state together**. (We’ll show an example comparing useState to this.state in Using the State Hook.)\n\n**The only argument to ```useState``` is the initial state**. In the example above, it is 0 because our counter starts from zero. Note that **unlike this.state, the state here doesn’t have to be an object** — although it can be if you want. **The initial state argument is only used during the first render**.\n\n### Declaring multiple state variables\nYou can use the State Hook more than once in a single component:\n\n```\nfunction ExampleWithManyStates() {\n  // Declare multiple state variables!\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n  // ...\n}\n```\n\nThe array destructuring syntax lets us give different names to the state variables we declared by calling useState. These names aren’t a part of the useState API. Instead, React assumes that if you call useState many times, you do it in the same order during every render. We’ll come back to why this works and when this is useful later.\n\n### But what is a Hook?\n**Hooks are functions that let you \"hook into\" React state and lifecycle features from function components**. Hooks don’t work inside classes — they let you use React without classes. (We don’t recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you’d like.)\n\n> **React provides a few built-in Hooks like useState. You can also create your own Hooks to reuse stateful behavior between different components**. We’ll look at the built-in Hooks first.\n\n### Effect Hook\nYou’ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations **\"side effects\" (or \"effects\" for short) because they can affect other components and can’t be done during rendering**.\n\n**The Effect Hook, useEffect, adds the ability to perform side effects from a function component**. It serves the same purpose as *componentDidMount*, *componentDidUpdate*, and *componentWillUnmount* in React classes, but *unified into a single API*. (We’ll show examples comparing useEffect to these methods in Using the Effect Hook.)\n\nFor example, this component sets the document title after React updates the DOM:\n```\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() => {\n    // Update the document title using the browser API\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nWhen you call ```useEffect```, **you’re telling React to run your \"effect\" function after flushing changes to the DOM**. Effects are declared inside the component so they *have access to its props and state*. By default, **React runs the effects after every render** — including the first render. (We’ll talk more about how this compares to class lifecycles in Using the Effect Hook.)\n\n**Effects may also optionally specify how to \"clean up\" after them by returning a function**. For example, this component uses an effect to subscribe to a friend’s online status, and cleans up by unsubscribing from it:\n```\nimport React, { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n```\nIn this example, React would unsubscribe from our ChatAPI when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there’s a way to tell React to skip re-subscribing if the props.friend.id we passed to ChatAPI didn’t change.)\n\nJust like with ```useState``` **you can use more than a single effect in a component**:\n\n```\nfunction FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n  // ...\n```\n> Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.\n\n\n### Rules of Hooks\n*Hooks are JavaScript functions*, but they impose two additional rules:\n\n- **Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions.**\n- **Only call Hooks from React function components**. Don’t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks — *your own custom Hooks*. We’ll learn about them in a moment.)\nWe provide a linter plugin to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.\n\n### Building Your Own Hooks\n**Sometimes, we want to reuse some stateful logic between components**. Traditionally, there were two popular solutions to this problem: higher-order components and render props. **Custom Hooks let you do this**, but without adding more components to your tree.\n\nEarlier on this page, we introduced a *FriendStatus* component that calls the ```useState``` and ```useEffect``` Hooks to subscribe to a friend’s online status. Let’s say we also want to reuse this subscription logic in another component.\n\nFirst, we’ll extract this logic into a custom Hook called useFriendStatus:\n\n```\nimport React, { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n```\nIt takes friendID as an argument, and returns whether our friend is online.\n\nNow we can use it from both components:\n\n```\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return (\n\n    <li>\n      {props.friend.name}\n    </li>\n  );\n}\n```\n> Fix: ```<li style=\\{\\{ color\\: isOnline \\? \\\"green\\\" \\: \\\"black\\\" \\}\\}```\n\n**The state of these components is completely independent**. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component.\n\nCustom Hooks are more of a convention than a feature. **If a function's name starts with \"use\" and it calls other Hooks, we say it is a custom Hook**. The ```useSomething``` naming convention is how our linter plugin is able to find bugs in the code using Hooks.\n\nYou can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven't considered. \n\n\n### Other Hooks\nThere are a few less commonly used built-in Hooks that you might find useful. For example, ```useContext``` **lets you subscribe to React context without introducing nesting**:\n\n```\nfunction Example() {\n  const locale = useContext(LocaleContext);\n  // ...\n}\n```\nAnd ```useReducer``` lets you **manage local state of complex components with a reducer**:\n\n```\nfunction Todos() {\n  const [todos, dispatch] = useReducer(todosReducer);\n  // ...\n```\n\n\n","references":"- [ReactJS - Hooks overview](https://reactjs.org/docs/hooks-overview.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-hooks-introduction","weblink":"https://codersnack.com/reactjs-hooks-introduction","featured_image_preview":{"id":74,"name":"reactjs-icon.png","hash":"f71e38a0a4d346208cebb0992c7e08eb","sha256":"PmVXpJ5g4o1kx3tUYPpFu1CS1wfvEx7u1CLaL54m9CQ","ext":".png","mime":"image/png","size":4.81,"url":"/uploads/f71e38a0a4d346208cebb0992c7e08eb.png","provider":"local","provider_metadata":null,"created_at":"2020-03-16T19:39:30.691Z","updated_at":"2020-03-16T19:39:30.691Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"ReactJS - Hooks at a glance","created_at":"2020-03-16T19:40:02.525Z","updated_at":"2020-03-16T19:40:02.533Z"},{"id":77,"codersnack":{"id":78,"header":"React - Handling Events & Synthetic Events","created_at":"2020-05-28T09:44:34.266Z","updated_at":"2020-05-28T12:29:49.832Z","explanation":"Handling events with React elements is **very similar to handling events on DOM elements**. There are some syntax **differences**:\n\n- React events are **named using camelCase**, rather than lowercase.\n- **With JSX you pass a function as the event handler**, rather than a string.\n\nFor example, the HTML:\n```\n<button onclick=\"activateLasers()\">\n  Activate Lasers\n</button>\n```\nis slightly different in React:\n```\n<button onClick={activateLasers}>\n  Activate Lasers\n</button>\n```\nAnother difference is that you cannot return false to prevent default behavior in React. **You must call preventDefault explicitly**. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:\n```\n<a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\">\n  Click me\n</a>\n```\nIn React, this could instead be:\n```\nfunction ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n  }\n  return (\n    <a href=\"#\" onClick={handleClick}>\n      Click me\n    </a>\n  );\n}\n```\nHere, e is a **synthetic event**. React defines these synthetic events according to the W3C spec, so you **don’t need to worry about cross-browser compatibility**. See the SyntheticEvent reference guide to learn more.\n\nWhen using React, you generally don’t need to call *addEventListener* to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.\n\nWhen you define a component using an ES6 class, a common pattern is for an **event handler to be a method on the class**. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:\n```\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // This binding is necessary to make `this` work in the callback\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(state => ({\n      isToggleOn: !state.isToggleOn\n    }));\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);\n```\n\n> You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.\n\n**If calling bind annoys you, there are two ways you can get around this**. If you are using the **experimental public class fields syntax**, you can use class fields to correctly bind callbacks:\n```\nclass LoggingButton extends React.Component {\n  // This syntax ensures `this` is bound within handleClick.\n  // Warning: this is *experimental* syntax.\n  handleClick = () => {\n    console.log('this is:', this);\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n\nThis syntax is enabled by default in Create React App.\nIf you aren’t using class fields syntax, you can use an **arrow function in the callback**:\n```\nclass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // This syntax ensures `this` is bound within handleClick\n    return (\n      <button onClick={() => this.handleClick()}>\n        Click me\n      </button>\n    );\n  }\n}\n```\nThe problem with this syntax is that *a different callback is created each time the LoggingButton renders*. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally **recommend binding in the constructor or using the class fields syntax**, to avoid this sort of performance problem.\n\n#### Passing Arguments to Event Handlers\nInside a loop, it is common to want to pass an extra parameter to an event handler. For example, if id is the row ID, either of the following would work:\n```\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n```\nThe above two lines are equivalent, and use arrow functions and Function.prototype.bind respectively. In both cases, the e argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.\n\n### SyntheticEvent\nThis reference guide documents the **SyntheticEvent** wrapper that forms part of *React’s Event System*. \n\n#### Overview\n**Your event handlers will be passed instances of SyntheticEvent, a cross-browser wrapper around the browser’s native event.** It has the **same interface** as the browser’s native event, including stopPropagation() and preventDefault(), except the events **work identically across all browsers**.\n\n> If you find that you need the underlying browser event for some reason, simply use the nativeEvent attribute to get it. Every *SyntheticEvent* object has the following attributes:\n\n- boolean bubbles\n- boolean cancelable\n- DOMEventTarget currentTarget\n- boolean defaultPrevented\n- number eventPhase\n- boolean isTrusted\n- DOMEvent nativeEvent\n- void preventDefault()\n- boolean isDefaultPrevented()\n- void stopPropagation()\n- boolean isPropagationStopped()\n- void persist()\n- DOMEventTarget target\n- number timeStamp\n- string type\nNote:\n\n> As of v0.14, returning false from an event handler will no longer stop event propagation. Instead, e.stopPropagation() or e.preventDefault() should be triggered manually, as appropriate.\n\n#### Event Pooling\nThe **SyntheticEvent is pooled**. This means that the **SyntheticEvent object will be reused and all properties will be nullified after the event callback has been invoked**. This is for *performance* reasons. As such, *you cannot access the event in an asynchronous way.*\n\n```\nfunction onClick(event) {\n  console.log(event); // => nullified object.\n  console.log(event.type); // => \"click\"\n  const eventType = event.type; // => \"click\"\n\n  setTimeout(function() {\n    console.log(event.type); // => null\n    console.log(eventType); // => \"click\"\n  }, 0);\n\n  // Won't work. this.state.clickEvent will only contain null values.\n  this.setState({clickEvent: event});\n\n  // You can still export event properties.\n  this.setState({eventType: event.type});\n}\n```\n\n> Note: If you want to *access the event properties in an asynchronous way*, you should call *event.persist()* on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.\n\n#### Supported Events\n**React normalizes events so that they have consistent properties across different browsers.**\n\nThe event handlers below are triggered by an event in the bubbling phase. To **register an event handler for the capture phase**, append **Capture** to the event name; for example, instead of using *onClick*, you would use *onClickCapture* to handle the click event in the capture phase.\n\n- Clipboard Events\n- Composition Events\n- Keyboard Events\n- Focus Events\n- Form Events\n- Generic Events\n- Mouse Events\n- Pointer Events\n- Selection Events\n- Touch Events\n- UI Events\n- Wheel Events\n- Media Events\n- Image Events\n- Animation Events\n- Transition Events\n- Other Events\n\n### Event bubbling \nEvent bubbling is a type of event propagation where the event first triggers on the innermost target element, and then successively triggers on the ancestors (parents) of the target element in the same nesting hierarchy till it reaches the outermost DOM element or document object (Provided the handler is initialized). \n\n![Event bubling](https://codersnack.com/assets/images/event_bubling.jpg)\n\nIt is one **way that events are handled in the browser**.\n\n\n","references":"- [reactjs.org - Handlng events](https://reactjs.org/docs/handling-events.html)\n- [reactjs.org - Synthetic Events](https://reactjs.org/docs/events.html)","featured_image_url":"https://codersnack.com/assets/images/logo-reactjs.png","slug":"reactjs-handling-events","weblink":"https://codersnack.com/reactjs-handling-events","featured_image_preview":{"id":105,"name":"logo-reactjs.png","hash":"f0538cec16224466ad02fa8267a6449f","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/f0538cec16224466ad02fa8267a6449f.png","provider":"local","provider_metadata":null,"created_at":"2020-05-28T09:44:34.284Z","updated_at":"2020-05-28T09:44:34.284Z"}},"codersnacks_category":{"id":2,"header":"ReactJS","description":"Javascript library for building user interfaces","snacks_by_cat_json_filename":"reactjs.snacks.json","key":"reactjs","image_url":"https://codersnack.com/assets/images/logo-reactjs.png","created_at":"2019-12-31T19:51:23.456Z","updated_at":"2020-01-27T20:11:40.554Z","image_preview":{"id":4,"name":"logo-reactjs.png","hash":"184e26e835dc4e16ad7789a8ca97d25d","sha256":"ek-ixAp6Ir6UtlIEoswH3vum83sE3lYiacTqgsQHpCI","ext":".png","mime":"image/png","size":10.75,"url":"/uploads/184e26e835dc4e16ad7789a8ca97d25d.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T19:51:23.474Z","updated_at":"2019-12-31T19:51:23.474Z"}},"title":"ReactJs - Handling Events","created_at":"2020-05-28T09:45:00.799Z","updated_at":"2020-05-28T09:45:00.802Z"}]