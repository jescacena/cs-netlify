[{"id":48,"codersnack":{"id":51,"header":"How the browser renders a web page? (I)","created_at":"2020-02-23T16:58:43.010Z","updated_at":"2020-02-23T16:58:43.010Z","explanation":"### Document Object Model (DOM)\n\nWhen the browser reads HTML code, whenever it encounters an HTML element like html, body, div etc., **it creates a JavaScript object called as *Node*. **Eventually, **all HTML elements will be converted to JavaScript objects**. Since every different HTML element has different properties, the Node object will be created from different classes (constructor functions).\n\nFor example, the Node object for the div element is created from **HTMLDivElement** which inherits Node class. The browser comes with built-in classes like HTMLDivElement, HTMLScriptElement, Node etc.\n\nAfter the browser has created Nodes from the HTML document, it has to **create a tree-like structure of these node objects**. Since our HTML element will be nested inside each other, **browser needs to replicate that but using Node objects it has previously created**. This will help the browser efficiently render and manage the webpage through its lifecycle.\n\n![text](https://codersnack.com/assets/images/web-performance-dom-tree.png)\n\n> A DOM node doesn’t always have to be an HTML element. When the browser creates a DOM tree, it also saved things like comments, attributes, text as separate nodes in the tree. But for the simplicity, we will just consider DOM nodes for HTML elements AKA DOM element. Here is the list of all [DOM node types](https://www.w3schools.com/jsref/prop_node_nodetype.asp)\n\n**JavaScript doesn’t understand what DOM is**, it is not part of the JavaScript specifications. **DOM is a high-level Web API provided by the browser** to efficiently render a webpage and expose it publically for the developer to dynamically manipulate DOM elements for various purposes.\n\n> Using DOM API, developers can add or remove HTML elements, change its appearance or bind event listeners. Using DOM API, HTML elements can be created or cloned in memory and maniuplated without affecting the rendered DOM tree. This gives developers the ability to construct highly dynamic web page with rich user experience.\n\n### CSS Object Model (CSSOM)\n\nAfter constructing the DOM, **the browser reads CSS** from all the sources (external, embedded, inline, user-agent, etc.) and **construct a *CSSOM***. CSSOM stands for CSS Object Model which is a Tree Like structure just like DOM.\n\n**Each node in this tree contains CSS style information for that particular DOM element.** CSSOM, however, does not contain DOM elements which can't be printed on the screen like `<meta>`, `<script>`, `<title>` etc.\n\nAs we know, **most of the browser comes with its own stylesheet which is called as *user agent stylesheet***, the browser first computes final CSS properties for DOM element by overriding user agent styles with CSS provided by the developer properties (using specificity rules) and then construct a node.\n\nEven if a CSS property for a particular HTML element isn’t defined by either the developer or the browser, its value is set to the default **value of that property as specified by W3C CSS standard**. While selecting the default value of a CSS property, some rules of inheritance are used if a property qualifies for the inheritance as mentioned in the W3C documentation.\n\nFor example, *color* and *font-size* among others **inherits the value of the parent if these properties are missing an HTML element**. So you can imagine having these properties on an HTML element and all its children inheriting it. This is called as cascading of styles and **that’s why CSS is called as Cascading Style Sheet.** This is the very reason why the browser constructs a CSSOM, a tree-like structure to compute styles based on CSS cascading rules.\n\n![text](https://codersnack.com/assets/images/web-performance-cssom-tree.png)\n\n","references":"- [Uday Hiwarale - How the Browser renders a web page?](https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969)","featured_image_url":"https://codersnack.com/assets/images/web-performance.png","slug":"web-performance-how-browser-renders","weblink":"https://codersnack.com/web-performance-how-browser-renders/","featured_image_preview":{"id":66,"name":"web-performance.png","hash":"fdf43fa458bf45b2bace1222ffb74f41","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/fdf43fa458bf45b2bace1222ffb74f41.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:58:43.019Z","updated_at":"2020-02-23T16:58:43.019Z"}},"codersnacks_quiz":{"id":48,"question":"Web performance - What is the CSSOM?","response_valid":"CSSOM stands for CSS Object Model which is a Tree Like structure just like DOM","response_invalid1":"Its a way of coding CSS object oriented","response_invalid2":"Its an advanced version of CSS for styling HTML elements","created_at":"2020-02-23T17:03:35.222Z","updated_at":"2020-02-23T17:03:35.222Z"},"codersnacks_category":{"id":11,"header":"Web Performance","description":"Performance is about retaining users","snacks_by_cat_json_filename":"web-performance.snacks.json","key":"web-performance","image_url":"https://codersnack.com/assets/images/web-performance.png","created_at":"2020-02-23T16:32:16.566Z","updated_at":"2020-02-23T16:32:16.566Z","image_preview":{"id":63,"name":"web-performance.png","hash":"f82923fcbd6240f195cee5cae6d16a3c","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/f82923fcbd6240f195cee5cae6d16a3c.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:32:16.584Z","updated_at":"2020-02-23T16:32:16.584Z"}},"title":"Web performance Browser renders CSSOM what","created_at":"2020-02-23T17:04:08.952Z","updated_at":"2020-02-23T17:04:08.955Z"},{"id":49,"codersnack":{"id":52,"header":"How the browser renders a web page? (II)","created_at":"2020-02-23T21:37:29.712Z","updated_at":"2020-02-23T21:37:29.712Z","explanation":"### Render Tree\n\n**Render-Tree is a tree-like structure constructed by combining DOM and CSSOM trees**. The browser has to calculate the layout of each visible element and paint them on the screen, for that browser uses Render-Tree. Hence, unless Render-Tree isn’t constructed, nothing will get printed on the screen.\n\nAs Render-Tree is a low-level representation of what will eventually get painted on the screen, **it won’t contain nodes that do not hold any area in the pixel matrix**. For example, display:none elements have dimensions of 0px X 0px hence they won't be present in Render-Tree.\n\n![Web performance DOM + CSSOM tree](https://codersnack.com/assets/images/web-performance-dom-cssom.png)\n\nAs you can see from the above diagram, **Render-Tree combines DOM and CSSOM to generate a tree-like structure containing only the elements which will be printed on the screen**.\n\nSince in CSSOM, p element inside div has *display:none* property set on it, it and its children won't be present in Render-Tree, since it occupies no space on the screen. However, if you have elements with *visibility:hidden* or opacity:0, they will occupy space on the screen hence they will be present in the Render-Tree.\n\nUnlike DOM API which gives access to the DOM elements in the DOM tree constructed by the browser, **CSSOM is kept hidden from the user. But since browser combines DOM and CSSOM to form the Render Tree, browser exposes CSSOM node of a DOM element by providing high-level API on the DOM element itself**. This enables the developer to access or change the CSS properties of a CSSOM node.\n\n### Rendering Sequence\n\nWhen a web page is loaded, the browser first reads the TEXT HTML and constructs DOM Tree from it. Then it processes the CSS whether that is inline, embedded or external CSS and constructs the CSSOM Tree from it. After these trees are constructed, then it constructs the Render-Tree from it. Once the Render-Tree is constructed, then the browser starts the printing individual elements on the screen.\n\n#### Layout operation\n\n**The first browser creates the layout of each individual Render-Tree node**. The layout consists of the size of each node in pixels and where (position) it will be printed on the screen.\n\n> This process is also called as **reflow** or **browser reflow** and it can also occur when you scroll, resize the window or manipulate DOM elements. Here is a list of events which can trigger reflow of the elements.\n\n#### Paint operation\n\nUntil now we have a list of geometries that needs be printed on the screen. Since elements (or a sub-tree) in the Render-Tree can overlap each other and they can have properties that make them frequently change the look, position or geometry, the browser creates a layer for it.\n\n**Creating layers helps browser efficiently perform painting operations** throughout the lifecycle of a web page for example while scrolling or resizing. Having layers also help browser correctly draw elements in the order (along the z-axis) they were intended by the developer.\n\nNow that we have layers, we can combine them and draw it on the screen. But the browser does not draw all the layers in a single image. Each layer is drawn separately first.\n\nInside each layer, the browser fills the individual pixels with whatever visible property of the element is like border, background colour, shadow, text, etc. This process is also called as **rasterization**. To increase performance, the browser may use different threads to perform rasterization.\n\n**The analogy of layers in Photoshop can be applied to how the browser renders a web page as well**. You can visualize different layers on a web page from Chrome DevTools. Open DevTools and from more tools options, select **Layers**. You can also visualize layer borders from **Rendering panel**.\n\n**Rasterization is normally done in CPU which makes it slow and expensive but we now have new techniques to do it in GPU for performance enhancement**. \n\n#### Compositing operation\n\nUntil now, we haven’t drawn a single pixel on the screen. What we have are different layers (bitmap images) which should be drawn on the screen in a specific order. In compositing operations, these layers are sent to GPU to finally draw it on the screen.\nSending entire layers to draw is clearly inefficient because this has to happen every time there is a reflow or repaint. Hence, **a layer is broken down into different tiles which then will be drawn on the screen**. You can also visualize these tiles in **Chrome DevTool Rendering panel**.\n\nFrom the above information, we can construct a sequence of events, the browser goes through when a web page is loaded for the first time.\n\n![Web performance Critical Rendering path](https://codersnack.com/assets/images/critical-rendering-path.png)\n\n\nThese sequence of event is also called a **critical rendering path**.\n\n\n","references":"- [Uday Hiwarale - How the Browser renders a web page?](https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969)","featured_image_url":"https://codersnack.com/assets/images/web-performance.png","slug":"web-performance-how-browser-renders-2","weblink":"https://codersnack.com/web-performance-how-browser-renders-2/","featured_image_preview":{"id":67,"name":"web-performance.png","hash":"65a7a1e6633a4467bb4ccfdee763ce22","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/65a7a1e6633a4467bb4ccfdee763ce22.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T21:37:29.724Z","updated_at":"2020-02-23T21:37:29.724Z"}},"codersnacks_quiz":{"id":49,"question":"The browser starts the printing of elements on the screen ..","response_valid":"once the Render-Tree is constructed","response_invalid1":"before the Render-Tree is constructed","response_invalid2":"once the browser first reads the TEXT HTML","created_at":"2020-02-23T21:41:57.922Z","updated_at":"2020-02-23T21:41:57.922Z"},"codersnacks_category":{"id":11,"header":"Web Performance","description":"Performance is about retaining users","snacks_by_cat_json_filename":"web-performance.snacks.json","key":"web-performance","image_url":"https://codersnack.com/assets/images/web-performance.png","created_at":"2020-02-23T16:32:16.566Z","updated_at":"2020-02-23T16:32:16.566Z","image_preview":{"id":63,"name":"web-performance.png","hash":"f82923fcbd6240f195cee5cae6d16a3c","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/f82923fcbd6240f195cee5cae6d16a3c.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:32:16.584Z","updated_at":"2020-02-23T16:32:16.584Z"}},"title":"Web performance - Browser render - Render tree when","created_at":"2020-02-23T21:43:16.335Z","updated_at":"2020-02-23T21:43:16.340Z"},{"id":50,"codersnack":{"id":53,"header":"How the browser renders a web page? (III)","created_at":"2020-02-24T21:52:10.827Z","updated_at":"2020-02-24T22:10:39.462Z","explanation":"### Render blocking CSS & DOMContentLoaded\n\nNow that we understood how the browser renders a web page from some HTML Text to individual pixels on the screen, **we need to understand how we can make this process efficient for better user experience**.\n\nA typical web page contains HTML, JavaScript and CSS. **The browser constructs the DOM by parsing HTML from top to bottom. If there is an embedded JavaScript and CSS, it will be parsed synchronously**.\n\nBut if the browser encounters ``` <link rel=\"stylesheet\">```  element which is used to load external CSS, it will send a request to fetch .css file asynchronously and again move on to parse other HTML elements below it.\n\nHowever, that’s not the case with ``` <script src=\"\"> ```  elements which load external JavaScript files. Whenever the browser encounters external JavaScript, DOM construction is stopped until the JavaScript file is downloaded and parsed.\n\nThe DOMContentLoaded is fired by the browser on document object when DOM is fully constructed. But that’s not a whole picture. Since you can modify the CSS styles of a DOM element, your CSSOM also needs to be ready. Hence, ***DOMContentLoaded* can be safely fired when both DOM and CSSOM is constructed and Render-Tree is about to be constructed**.\nDOMContentLoaded event **differs from *window.onload*** event in one aspect. As we know JavaScript can block DOM creation, that’s not the case with external stylesheets and files (like images, videos, etc.). ***DOMContentLoaded* event marks a point where all external JavaScript is parsed and DOM is fully ready, *window.onload* events marks a point where external stylesheets and files are downloaded and our webpage is completely ready.**\n\n**But there is a caveat**. CSS is a render-blocking resource which means until external CSS is downloaded and parsed, the browser will not render anything on the screen. Technically, that means it will block CSSOM from being fully constructed, so critical rendering path is stuck. This also means as CSSOM construction blocked, our DOMContentLoaded event won’t be fired by the browser. So **we can say that external stylesheets might load asynchronously, but they will be parsed synchronously**.\n\nWe can **visualize this in *Chrome DevTools console***. Going forward, let’s take the below example to test the critical rendering path. Inside the project repository, I have set up an express server to provide custom delays in external files, like for example, request for style.css will be resolved after 5000ms.\n```\n<html lang='en'>\n    <head>\n        <title>Rendering Test</title>\n        <link rel='stylesheet' href='/5000/css/style.css'>\n    </head>\n    <body>\n        <img src=\"/10000/res/nature.jpg\" />\n        \n        <h1>I am first!</h1>\n        \n        <script src=\"/1000/js/main.js\"></script>\n        \n        <h2>I am second!</h2>\n        \n        <script src=\"/2000/js/common.js\"></script>\n        \n        <h3>I am third!</h3>\n        <script src=\"/3000/js/vendor.js\"></script>\n    </body>\n</html>\n```\n![text](https://codersnack.com/assets/images/web-performance-browser-renders-domcontentloaded-0.png)\n\nFrom the above screenshot, we can tell that *DOMContentLoaded* the event was fired after 6.5s which is labelled with DCL while *window.onload* event was fired after 10s which is labelled with L.\n\nLet’s see the network panel and see how the browser is treating each resource individually. We are also logging DCL and L events.\n\n![text](https://codersnack.com/assets/images/web-performance-browser-renders-domcontentloaded.gif)\n\nAs you can see from the above screen recording, since the first external resource encountered while parsing DOM is an external CSS, hence request to fetch it was sent browser started loading it asynchronously. As CSS was loading in the background, normal DOM parsing continued and another external resource encountered which was a JavaScript file.\n\nDOM parsing stopped until JavaScript was loaded and parsed. This happened three times for three external JavaScript files. Once all JavaScript is loaded and DOM is constructed, browser waited for the stylesheet to load and parsed, after which it fired *DOMContentLoaded* after 5.3s.\n\nWe also had another external resource which is an image file and it keeps loading in the background. After it was loaded, window.onload event was fired after 10.2s.\n\n**But beware!** Even though from the above simulation is looked like CSS was loading in the background while DOM and JavaScript parsing were continued. **What if your JavaScript code was accessing DOM element’s style property which was supposed to be provided by CSSOM and it wasn’t ready yet because external stylesheet was still loading**.\n\nTo prevent such scenarios, the browser might load external JavaScript in a synchronous manner, but it won't parse the JavaScript and halt building DOM until CSSOM is ready.\n\nSince now we understood that both JavaScript and CSS can block critical rendering path, **what we can do about it?** Well for the starters, you can **optimize your CSS and make sure that it loads faster**. You can **load your JavaScript asynchronously using *async* or *defer* attributes.**\n\n**You can add *media* attributes to your external stylesheet** elements which will be loaded and parsed asynchronously based on environmental conditions.\n\n### Browser engine\n**The job of creating DOM Tree, CSSOM Tree and handle rendering logic is done using a piece of software called as Browser Engine** also called as Rendering Engine or Layout Engine. These Browser engines contain all the necessary elements and logic to render a web page from HTML file to actual pixels on the screen.\n\nIf you have ever heard of **WebKit**, all the time, you were talking about a browser engine. WebKit is used by Apples **Safari** browser and was default rendering engine for Google Chrome browser. As of now, the **Chromium** project uses **Blink** as the default rendering engine. Here is a list of different browser engine used by some of the top web browsers.\n\n","references":"- [Uday Hiwarale - How the Browser renders a web page?](https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969)","featured_image_url":"https://codersnack.com/assets/images/web-performance.png","slug":"web-performance-how-browser-renders-3","weblink":"https://codersnack.com/web-performance-how-browser-renders-3/","featured_image_preview":{"id":68,"name":"web-performance.png","hash":"2f9b51b8408245519c3ae7dbefc041dc","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/2f9b51b8408245519c3ae7dbefc041dc.png","provider":"local","provider_metadata":null,"created_at":"2020-02-24T21:52:10.847Z","updated_at":"2020-02-24T21:52:10.847Z"}},"codersnacks_quiz":{"id":50,"question":"What is the difference between DOMContentLoaded and window.onload events ? ","response_valid":"DOMContentLoaded event marks a point where all external JavaScript is parsed and DOM is fully ready, window.onload events marks a point where external stylesheets and files are downloaded and our webpage is completely ready","response_invalid1":"DOMContentLoaded event fires after window.onload event","response_invalid2":"window.onload event fires when you press enter in the browser's address bar and DOMContentLoaded even fires when page load finishes","created_at":"2020-02-24T22:06:31.162Z","updated_at":"2020-02-24T22:06:31.162Z"},"codersnacks_category":{"id":11,"header":"Web Performance","description":"Performance is about retaining users","snacks_by_cat_json_filename":"web-performance.snacks.json","key":"web-performance","image_url":"https://codersnack.com/assets/images/web-performance.png","created_at":"2020-02-23T16:32:16.566Z","updated_at":"2020-02-23T16:32:16.566Z","image_preview":{"id":63,"name":"web-performance.png","hash":"f82923fcbd6240f195cee5cae6d16a3c","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/f82923fcbd6240f195cee5cae6d16a3c.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:32:16.584Z","updated_at":"2020-02-23T16:32:16.584Z"}},"title":"Web performance Browser renders 3 DCL onload difference","created_at":"2020-02-24T22:07:25.555Z","updated_at":"2020-02-24T22:07:25.559Z"}]