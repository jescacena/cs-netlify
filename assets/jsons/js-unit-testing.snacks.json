[{"id":32,"codersnack":{"id":33,"header":"What is Unit Testing and TDD?","created_at":"2020-01-28T19:17:01.851Z","updated_at":"2021-11-29T21:50:29.915Z","explanation":"**A unit test runs some code over a segment of your program checking the input and output**. These tests allow developers to check individual areas of a program **to see where (and why) errors occur**.\n\nThis comes with an inherent understanding of what you’re trying to test for and how the code should function.\n\n>Every developer knows we should write unit tests in order to prevent defects from being deployed to production.\n\n#### Why Bother with Test Discipline?\n**Your tests are your first and best line of defense against software defects**. Your tests are more important than linting & static analysis (which can only find a subclass of errors, not problems with your actual program logic). Tests are as important as the implementation itself (all that matters is that the code meets the requirement — how it’s implemented doesn’t matter at all unless it’s implemented poorly).\n\nUnit tests combine many **features** that make them your secret weapon to application success:\n\n- **Design aid**: Writing tests first gives you a clearer perspective on the ideal API design.\n- **Feature documentation (for developers)**: Test descriptions enshrine in code every implemented feature requirement.\n- **Test your developer understanding**: Does the developer understand the problem enough to articulate in code all critical component requirements?\n- **Quality Assurance**: Manual QA is error prone. In my experience, it’s impossible for a developer to remember all features that need testing after making a change to refactor, add new features, or remove features.\n- **Continuous Delivery Aid**: Automated QA affords the opportunity to automatically prevent broken builds from being deployed to production.\n\nUnit tests don’t need to be twisted or manipulated to serve all of those broad-ranging goals. Rather, it is in the essential nature of a unit test to satisfy all of those needs. These benefits are all side-effects of a well-written test suite with good coverage.\n\n#### The Science of TDD\n**Test-driven development (TDD) is a software development process** that relies on the repetition of a very short development cycle: \n- requirements are turned into very specific test cases, \n- then the code is improved so that the tests pass\n\n>This is opposed to software development that allows code to be added that is not proven to meet requirements.\n\nThe evidence says:\n- **TDD can reduce bug density**.\n- **TDD can encourage more modular designs** (enhancing software agility/team velocity).\n- **TDD can reduce code complexity**.\n\nSays science: *There is significant empirical evidence that TDD works*.\n\n#### Write Tests First\nStudies from Microsoft Research, IBM, and Springer tested the efficacy of test-first vs test-after methodologies and consistently found that a test-first process produces better results than adding tests later. It is resoundingly clear: Before you implement, write the test.\n>Before you implement,write the test.\n\n#### How unit tests are used\n- **Design aid**: written during design phase, prior to implementation.\n- **Feature documentation & test of developer understanding**: The test should provide a clear description of the feature being tested.\n- **QA/Continuous Delivery**: The tests should halt the delivery pipeline on failure and produce a good bug report when they fail.\n","references":"- [Medium - What Every Unit Test needs](https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d)","featured_image_url":"https://codersnack.com/assets/images/js-unit-testing-icon.png","slug":"js-unit-testing-whatis-tdd","weblink":"https://codersnack.com/js-unit-testing-whatis-tdd","featured_image_preview":{"id":43,"name":"js-unit-testing-icon.png","hash":"de5b1b99548e4980ad07ab40ada046cd","sha256":"SdZK7F_99qiud4oti+JJfUnRK+0U8Dd3QZNg9MrAWG8","ext":".png","mime":"image/png","size":52.94,"url":"/uploads/de5b1b99548e4980ad07ab40ada046cd.png","provider":"local","provider_metadata":null,"created_at":"2020-01-28T19:17:01.864Z","updated_at":"2020-01-28T19:17:01.864Z"}},"codersnacks_category":{"id":8,"header":"Javascript Unit Testing","description":"All about testing single js artifacts","snacks_by_cat_json_filename":"js-unit-testing.snacks.json","key":"js-unit-testing","image_url":"https://codersnack.com/assets/images/js-unit-testing-icon.png","created_at":"2020-01-28T18:52:32.193Z","updated_at":"2020-01-28T18:52:32.193Z","image_preview":{"id":42,"name":"js-unit-testing-icon.png","hash":"d3bdf132b6614e11ac16237a1c36b0c7","sha256":"SdZK7F_99qiud4oti+JJfUnRK+0U8Dd3QZNg9MrAWG8","ext":".png","mime":"image/png","size":52.94,"url":"/uploads/d3bdf132b6614e11ac16237a1c36b0c7.png","provider":"local","provider_metadata":null,"created_at":"2020-01-28T18:52:32.207Z","updated_at":"2020-01-28T18:52:32.207Z"}},"title":"JS unit testing whatis tdd","created_at":"2020-01-28T19:17:57.794Z","updated_at":"2020-01-28T19:17:57.800Z"},{"id":118,"codersnack":{"id":120,"header":"Clean Code With Unit Tests","created_at":"2021-11-29T21:41:46.225Z","updated_at":"2021-11-29T21:41:46.225Z","explanation":"Unit tests are important. **They prevent regressions as you refactor code, serve as documentation, and save you hours of time not spent doing tedious manual testing**. In short, tests enable change.\n\n**But how much attention to cleanliness do we give our tests?** We refactor our app’s production code, give descriptive names to variables, extract methods for repeatable functionality, and make our code easy to reason about. But do we do the same for our tests?\n\nConsider this quote from Robert C. Martin:\n> “Test code is just as important as production code. **It is not a second-class citizen**. It requires thought, design, and care. It must be kept as clean as production code.”\n\nSo, how do we keep our test code clean? Let’s consider some ideas below.\n\n\n## Structuring Tests\n\n**Tests should be structured according to the *Arrange-Act-Assert pattern***. This pattern goes by many names and is sometimes referred to as the Build-Operate-Check, Setup-Exercise-Verify, or Given-When-Then pattern.I prefer Arrange-Act-Assert for the alluring alliteration. Regardless of what you call it, the pattern looks like this:\n\n- **Arrange**: Set up the test fixtures, objects, or components you’ll be working with.\n- **Act**: Perform some operation, perhaps by calling a function or clicking a button.\n- **Assert**: Assert that the expected behavior or output occurred.\n\n**In the React world**, applying this pattern when testing a simple toggle button component might look like this:\n![clean-code-unit-testing-react-world](https://codersnack.com/assets/images/clean-code-unit-testing-react-world.png)\n*Arrange-Act-Assert pattern when unit testing a toggle button component’s rendered content*\n\nWe arrange our code and act on it all in the same line by rendering the ToggleButton component. We then make assertions on the output that it renders a button to the DOM and that the button’s text is visible on the screen.\nA more complex example might look like this:\n\n![clean-code-unit-testing-complex-example](https://codersnack.com/assets/images/clean-code-unit-testing-complex-example.png)\n\n*Arrange-Act-Assert pattern when unit testing a toggle button component’s interactive behavior*\n\nHere, we arrange our code by creating a stateful component that allows the toggle button to be toggled on and off. We act by rendering the component. We then assert that the button is initially toggled off. Next, we act again by clicking the button and then make another assertion that the button is now toggled on. Just for good measure, we act again by clicking again, and we assert again by verifying the button is back to being toggled off.\n\nIt’s important to note here that you should generally only be writing code for the Arrange phase at the beginning of each test. After that, it’s OK to cycle between iterations of Act and Assert. **But if you find yourself back in the Arrange phase later on in the test, that’s probably a good sign that you’re testing a second concept and should move that to a separate test**. More on this later.\n\n\n## Test Object Builders\n\n**Test object builders are methods, classes, or constructor functions that allow you to created commonly needed objects**. For example, you might often be working with a User object that contains all sorts of data about any given user. This could include a first name, last name, email address, phone number, mailing address, job title, app permissions, and much more. Creating a new **User object in each of your tests could easily take several lines of code, leading to an unwieldy test file hundreds of lines long.**\n\nInstead, we can keep our **test code DRY by creating a helper test object builder method that returns a new User object for us.** Even better, we can allow the default values to be overridden for when we need to be more specific about the properties used in the object.\n\nOne library I find especially helpful is the ***faker.js* npm package**. We can use this package to generate mock data for all sorts of different fields like firstName, jobTitle, phoneNumber, and more.\n\nConsider this example for a User test object builder:\n\n![clean-code-unit-tests-faker](https://codersnack.com/assets/images/clean-code-unit-tests-faker.png)\n\nOur buildUser method returns a plain object representing a user. We can then use this buildUser method in our test files to create users that have random values by default (the user1 user) or users that have specific values we specify (the user2 user).\n\n\n## Evaluate a Single Concept per Test\n\nEach test should verify only one thing. **Don’t try to test several things all in the same test**. For example, a bad test for a date picker component might read something like “renders in various states” and then render eight different date pickers to illustrate the differences. A test like this is doing too much.\n\nA better test would be more specific — something like “renders the date picker when the user clicks the text input.”\n\n\n## Tests Should Be Fast\n\nSlow test suites are a pain to run. Even worse, when slow test suites are optional or not enforced as part of a CI pipeline, developers tend to choose to not run these test suites. No one likes to wait.\n\nFast test suites, on the other hand, can be run continuously while you’re writing production code. This short feedback loop enables you to develop more quickly and more confidently. Fast test suites also facilitate programming paradigms like test-driven development.\n\n> In the JavaScript world, **running Jest tests in watch mode** while you develop is a game-changer.\n\n\n## Tests Should Be Independent\n\n**Tests should be able to be run in any order.** In other words, any given test should not depend on the test before it. If you’re not **careful in doing a proper teardown or cleanup between tests in your test files**, you may end up modifying global variables in one test that then affect subsequent tests. This can lead to unexpected behavior and headaches. It’s always a fun debugging adventure when a single test passes when run in isolation but fails when run as part of the test suite.\n\n> If you’re using **Jest**, the **setup and teardown is typically done in beforeEach and afterEach code blocks**. \nIt’s also helpful to remember that each test file gets its own instance of JSDOM, but **tests within the same file share that same JSDOM instance.**\n\n\n## Tests Should Be Repeatable\n\n**Tests should be able to be run in any environment**. If the test suite passes on my machine, it should pass on your machine too. That also means it should pass in the CI pipeline. When tests are repeatable, there are no surprises where a test passes in one environment but fails in another. Flakiness like that decreases your confidence in your tests.\n\n\n## Tests Should Be Self-Validating\n\n**Tests should return a Boolean. Either the test passes or it fails. You shouldn’t need a human to interpret the results of the test**. This is one of many reasons why snapshot tests suck and should be avoided.\n\n> **Snapshot tests don’t tell you what the correct output should be**. They just tell you that something is different. It’s up to you as the developer to decide if it’s intentional that the snapshot changed or if this is an error that needs to be addressed. Oftentimes, though, what ends up happening is that developers blindly accept the changes to the snapshot and assume that the new snapshot is correct.\n\n\n## Tests Should Be Written in a Timely Manner\n\nTests should be written at the same time as the production code. **If you’re an advocate for test-driven development, then you believe tests should be written right before the production code. If you’re not as strict, then you probably write your tests shortly after the production code**. Either of those approaches is much better than writing tests months later when trying to play catch-up to increase your repository’s code coverage.\n\n\n## Make Sure Tests Fail When They Should\n\nHave you ever come across a test that doesn’t test what it says it does? **The test may be passing, but it definitely doesn’t test anything meaningful or what it claims to. Tests like these create a false sense of confidence**. Your test suite is passing, after all!\n\nConsider this quote from Martin Fowler:\n>“I like to see a test fail at least once when I write it.”\n\nThose are wise words! **It’s easy to verify that your test is doing its job by making a slight modification to either the test code or the production code to change the output to something intentionally incorrect**. If your test fails, great!\n\nDon’t forget to change your test back to get it passing again after doing this sanity check, of course.\n\n\n## Remember To Test Your Edge Cases\n\nIt’s a rookie mistake to only test the happy path. In addition to making sure the normal behavior works, **try to consider ways in which things could go wrong**. What if someone provided invalid arguments to your function? Or perhaps unexpected data types?\n\nConsider this example scenario: You’re writing a function that returns the type of a triangle based on the value of the length of the three sides of that triangle. We’ll call the function *triangleType*, and it’ll have three parameters so that the function signature looks like this: *triangleType(side1, side2, side3)*.\n\nWhat cases would you test for a function like this?\n\n![clean-code-unit-testing-triangle-example](https://codersnack.com/assets/images/clean-code-unit-testing-triangle-example.png)\n\nThe immediately obvious test cases might be to check that it can correctly identify a valid equilateral triangle, isosceles triangle, and scalene triangle. Your test cases might look like this:\n```\ntriangleType(4, 4, 4) // Equilateral Triangle\ntriangleType(6, 7, 6) // Isosceles Triangle\ntriangleType(6, 7, 8) // Scalene Triangle\n```\nInterestingly enough, testing those three cases would give you 100% code coverage based on the current implementation of the function. **But these three tests alone are not enough**.\n\nWhat if, for example, all zeros were provided to the function? That’s not a triangle. That’s a point. But the function would identify that as an equilateral triangle since all sides are equal.\n\nWhat if negative numbers were provided to the function? A triangle can’t have negative lengths. That doesn’t make any sense.\n\nOr what if two of the sides were much shorter than the third side? Then the sides wouldn’t connect, and we wouldn’t have a triangle.\n\nThose three additional test cases might look like this:\n```\ntriangleType(0, 0, 0) // Not a triangle\ntriangleType(-6, -7, -8) // Not a triangle\ntriangleType(5, 3, 100) // Not a triangle\n```\n\nAs you can see, it’s essential to test more than just the happy path in your code.\n\n\n## Test the Things You’re Most Worried About Going Wrong\n\n**I like to shoot for 100% test coverage, but it’s important to not be dogmatic about this number.** There is a law of diminishing returns, and each additional test adds less and less value. If you have 95% code coverage, it might not be worth it to get that last 5% of code coverage. Not everything is worth testing.\n\n**The important thing is to test the critical parts of the application**. What are the areas of your code where you’re most concerned about things going wrong? Focus on having good tests in place for that core functionality first. Then write additional tests to cover less critical paths. But as you do so, remember to focus your tests on specific behavior and product requirements — not just on getting that last hard-to-reach line covered.\n\n\n## Summary\n\nYou made it! If you need a quick refresher on everything we’ve covered in this article, here are my unit testing tips and tricks for clean code:\n\n- Structure your tests using the Arrange-Act-Assert pattern.\n- Use test object builders to make test setup easy for commonly used objects.\n- Evaluate a single concept per test.\n- F.I.R.S.T. — Tests should be fast, independent, repeatable, self-validating, and timely.\n- Make sure tests fail when they should.\n- Remember your boundaries and edge cases.\n- Test the things you’re most worried about going wrong.\n- Thanks for reading, and happy coding!\n","references":"- [Clean Code with Unit Tests](https://betterprogramming.pub/clean-code-with-unit-tests-5f28020828a5)","featured_image_url":"https://codersnack.com/assets/images/js-unit-testing-icon.png","slug":"js-unit-testing-clean-code","weblink":"https://codersnack.com/js-unit-testing-clean-code","featured_image_preview":{"id":156,"name":"js-unit-testing-icon.png","hash":"e504b3f081d64daaaa10b5b51d5136a1","sha256":"SdZK7F_99qiud4oti+JJfUnRK+0U8Dd3QZNg9MrAWG8","ext":".png","mime":"image/png","size":52.94,"url":"/uploads/e504b3f081d64daaaa10b5b51d5136a1.png","provider":"local","provider_metadata":null,"created_at":"2021-11-29T21:41:46.241Z","updated_at":"2021-11-29T21:41:46.241Z"}},"codersnacks_category":{"id":8,"header":"Javascript Unit Testing","description":"All about testing single js artifacts","snacks_by_cat_json_filename":"js-unit-testing.snacks.json","key":"js-unit-testing","image_url":"https://codersnack.com/assets/images/js-unit-testing-icon.png","created_at":"2020-01-28T18:52:32.193Z","updated_at":"2020-01-28T18:52:32.193Z","image_preview":{"id":42,"name":"js-unit-testing-icon.png","hash":"d3bdf132b6614e11ac16237a1c36b0c7","sha256":"SdZK7F_99qiud4oti+JJfUnRK+0U8Dd3QZNg9MrAWG8","ext":".png","mime":"image/png","size":52.94,"url":"/uploads/d3bdf132b6614e11ac16237a1c36b0c7.png","provider":"local","provider_metadata":null,"created_at":"2020-01-28T18:52:32.207Z","updated_at":"2020-01-28T18:52:32.207Z"}},"title":"Javascript Unit Testing code - Clean Code","created_at":"2021-11-29T21:42:20.201Z","updated_at":"2021-11-29T21:42:20.206Z"}]