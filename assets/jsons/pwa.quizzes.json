[{"id":63,"codersnack":{"id":79,"header":"What are Progressive Web Apps?","created_at":"2020-06-04T19:41:03.447Z","updated_at":"2020-06-05T08:56:44.082Z","explanation":"**The web is an incredible platform**. Its mix of ubiquity across devices and operating systems, its user-centered security model, and the fact that **neither its specification nor its implementation is controlled by a single company** makes the web a unique platform to develop software on. Combined with its inherent **linkability**, it's possible to search it and share what you've found with anyone, anywhere. **Whenever you go to a website, it's up-to-date**, and your experience with that site can be as ephemeral or as permanent as you'd like. Web applications can reach anyone, anywhere, on any device with a **single codebase**.\n\n**Native applications**, are known for being incredibly **rich and reliable**. They're ever-present, on home screens, docks, and taskbars. They work regardless of network connection. They launch in their **own standalone experience**. They can read and **write files from the local file system, access hardware** connected via USB, serial or bluetooth, and even interact with data stored on your device, like contacts and calendar events. In native applications, you can do things like take pictures, see playing songs listed on the home screen, or control song playback while in another app. Native applications **feel like part of the device they run on**.\n\nCapabilities vs. reach of native apps, web app, and progressive web apps.\n![Native apps & Web apps & PWA apps](https://codersnack.com/assets/images/capabilities-reach.png)\n\nIf you think about native apps and web apps in terms of capabilities and reach, native apps represent the best of capabilities whereas web apps represent the best of reach. So where do Progressive Web Apps fit in?\n\n**Progressive Web Apps (PWA) are built and enhanced with modern APIs to deliver native-like capabilities**, reliability, and installability while reaching anyone, anywhere, on any device with a single codebase.\n\n### The three app pillars\n\nProgressive Web Apps are web applications that have been **designed so they are capable, reliable, and installable**. These three pillars transform them into an experience that **feels like a native application**\n.\n#### Capable\n\n**The web is quite capable in its own right today**. For example, you can build a hyper-local video chat app using **WebRTC**, geolocation, and push notifications. You can make that app installable and take those conversations virtual with **WebGL** and b. With the introduction of **Web Assembly**, developers can tap into other ecosystems, like C, C++, and Rust, and bring decades of work and capabilities to the web too. Squoosh.app, for instance, leverages this for its advanced image compression.\n\nUntil recently, only native apps could really lay claim to these capabilities. While some capabilities are still out of the web's reach, new and upcoming APIs are looking to change that, expanding what the web can do with features like file system access, media controls, app badging, and full clipboard support. **All of these capabilities are built with the web's secure, user-centric permission model, ensuring that going to a website is never a scary proposition for users**.\n\nBetween modern APIs, Web Assembly, and new and upcoming APIs, web applications are more capable than ever, and those **capabilities are only growing**.\n\n#### Reliable\n\n**A reliable Progressive Web App feels fast and dependable regardless of the network**.\n\n**Speed is critical** for getting users to use your experience. In fact, as page load times go from 1 second to ten seconds, the probability of a user bouncing increases by 123%. **Performance doesn't stop after the onload event**. Users should never wonder whether their interaction—for example, clicking a button—was registered or not. Scrolling and animation should feel smooth. Performance affects your entire experience, from how users perceive your application to how it actually performs.\n\nFinally, reliable applications need to be **usable regardless of network connection**. Users expect apps to start up on slow or flaky network connections or even when offline. They expect the most recent content they've interacted with, like media tracks or tickets and itineraries, to be available and usable even if getting a request to your server is hard. When a request isn't possible, they expect to be told there's trouble instead of silently failing or crashing.\n\nUsers love apps that respond to interaction in the blink of an eye, and an experience they can depend on.\n\n#### Installable\n\n**Installed Progressive Web Apps run in a standalone window instead of a browser tab**. They're launchable from on the user's home screen, dock, taskbar, or shelf. It's possible to search for them on a device and jump between them with the app switcher, making them feel like part of the device they're installed on.\n\n**New capabilities open up after a web app is installed**. Keyboard shortcuts usually reserved when running in the browser, become available. Progressive Web Apps can register to accept content from other applications, or to be the default application to handle different types of files. When a Progressive Web App moves out of a tab and into a standalone app window, it transforms how users think about it and interact with it.\n\n#### The best of both worlds\n\nAt their heart, Progressive Web Apps are just web applications. Using **progressive enhancement**, new capabilities are enabled in modern browsers. **Using service workers and a web app manifest, your web application becomes reliable and installable**. **If the new capabilities aren't available, users still get the core experience**.\n\nThe numbers don't lie! **Companies that have launched Progressive Web Apps have seen impressive results**. For example, Twitter saw a 65% increase in pages per session, 75% more Tweets, and a 20% decrease in bounce rate, all while reducing the size of their app by over 97%. After switching to a PWA, Nikkei saw 2.3 times more organic traffic, 58% more subscriptions, and 49% more daily active users. Hulu replaced their native desktop experience with a Progressive Web App and saw a 27% increase in return visits.\n\nProgressive Web Apps provide you with a unique opportunity to deliver a web experience your users will love. Using the latest web features to bring native-like capabilities and reliability, Progressive Web Apps allow what you build to be installed by anyone, anywhere, on any device with a single codebase.\n\n### How Progressive Web Apps can drive business success\n\nProgressive Web Apps are on a lot of companies' roadmap to modernize their website and adapt to users' new expectations. Like all new concepts and technical capabilities, they raise questions: is it what my customers want, how much will it grow my business, what is technically feasible?\n\nTo shape your digital strategy, several stakeholders are often involved: the Product Manager and CMO are co-owners of the business impact of each feature, the CTO assesses the feasibility and reliability of a technology, the UX Researchers validate that a feature answers a real customer issue.\n\nThis article aims to help you answer those **three questions and shape your PWA project**. You will start from your customer needs, translate this into PWA features, and focus on measuring the business impact that each feature brings to the table.\n\n#### PWAs solve customer needs\nOne rule we love to follow at Google when making products is **\"focus on the user and all else will follow\"**. Think user-first: what are my customers' needs, and how does a PWA provide them?\n\nWhen doing user research, we find some interesting patterns:\n\n- **Users hate delays** and unreliability on mobile: the level of stress caused by mobile delays is comparable to watching a horror movie.\n- **Fifty percent of smartphone users** are more likely to use a company's mobile site when browsing or shopping because they **don't want to download an app**.\n- One of the **top reasons for uninstalling an app is the limited storage** (whereas an installed PWA usually takes less than 1MB).\n- **Smartphone users are more likely to purchase from mobile sites** that offer relevant recommendations on products, and 85% of smartphone users say mobile notifications are useful.\n\nAccording to those observations, we found out that **customers prefer experiences that are fast, installable, reliable, and engaging (F.I.R.E.)!**\n\n#### PWAs leverage modern web capabilities\n\nPWAs provide a set of best practices and modern web APIs that are aimed at meeting your customers' needs by making your site fast, installable, reliable, and engaging.\n\nFor example, using a service worker to cache your resources and doing predictive prefetching makes your site faster, and more reliable. Making your site Installable provides an easy way for your customers to access it directly from their home screen or app launcher. And new APIs like Web Push Notifications make it easier to re-engage your users with personalized content to generate loyalty.\n\n![PWA leverages modern web capabilities](https://codersnack.com/assets/images/pwa-modern-web-capabilities.jpg)\n\n\n### Understand the business impact\nThe business success definition can be a lot of things depending on your activity:\n\n- Users spending more time on your service\n- Reduced bounce rates for your leads\n- Improved conversion rates\n- More returning visitors\n\nMost PWA projects result in a higher mobile conversion rate, and you can learn more from the numerous PWA case studies. Depending on your objectives, you may want to prioritize some aspects of PWA that make more sense for your business, and it's completely OK. PWA features can be cherry-picked and launched separately.\n\nLet's measure the business impact of each of these great F.I.R.E features.\n\n#### The business impact of a fast website\n\nA recent study from Deloitte Digital shows that page speed has a significant impact on business metrics.\n\nThere's a lot you can do to optimize the speed of your site to optimize the critical user journeys for all of your users. If you don't know where to start, take a look at our Fast section, and use *Lighthouse* to prioritize the most important things to fix.\n\nWhen working on your speed optimizations, start measuring your site speed frequently with appropriate tools and metrics to monitor your progress. For example, measure your metrics with *Lighthouse*, fix clear targets like having \"Good\" Core Web Vitals scores, and incorporate a performance budget into your build process. Thanks to your daily measurements and the \"value of speed\" methodology, you can isolate the impact of your incremental speed changes and calculate how much extra revenue your work has generated.\n\nEbay made speed a company objective for 2019. They used techniques like performance budget, critical path optimization, and predictive prefetching. They concluded that for every 100 milliseconds improvement in search page loading time, add-to-card count increased by 0.5%.\n\nA 100ms improvement in load time resulted in a 0.5% increase in add to cart count for eBay\n\n#### The business impact of an installable website\n\nWhy would you want a user to install your PWA? To make it easier to come back to your site. Where a native app install would add at least three steps (redirection to Play Store, downloading, relaunching the native app at the top of the funnel), PWA installation is done seamlessly in one click, and it doesn't take the user away from the current conversion funnel.\n\nOnce installed, users are able to launch it in one click from the icon on their home screen, see it in their app tray when they are switching between apps, or find it via an app search result. We call this app dynamic Discover-Launch-Switch, and making your PWA installable is the key to unlocking access.\n\nIn addition to being accessible from familiar discovery and launch surfaces on their device, a PWA launches exactly like a native app: in a standalone experience, separate from the browser. Additionally, **it benefits from native device services such as the app switcher and settings**.\n\nUsers who install your PWA are likely your most engaged users, with better engagement metrics than casual visitors, including more repeat visits, longer time on site and higher conversion rates, often at parity with native app users on mobile devices.\n\nTo make your PWA installable, it needs to meet the base criteria. Once it meets those criteria, you can promote the installation within your user experience on desktop and mobile, including iOS.\n\n#### The business impact of a reliable website\n\n**The Chrome Dino game, offered when a user is offline, is played more than 270 million times a month**. This impressive number shows that network reliability is a considerable opportunity, especially in markets with unreliable or expensive mobile data like India, Brazil, Mexico, or Indonesia.\n\n> When a native app, installed from an app store, is launched, users expect it to open, regardless of whether they're connected to the internet. Progressive Web Apps should be no different.\n\n**At a minimum, a simple offline page that tells the user the app isn't available without a network connection should be served**. Then, consider taking the experience a step further by providing some functionality that makes sense while offline. For example, you could provide access to tickets or boarding passes, offline wish lists, call center contact information, articles or recipes that the user has recently viewed, etc.\n\n#### The business impact of an engaging website\n\n**Web push notifications allow users to opt-in to timely updates** from sites they love and allow you to effectively re-engage them with customized, relevant content.\n\n> Be careful, though. Asking users to sign up for web notifications when they first arrive and without exposing the benefits can be perceived as spammy and negatively affect your experience. Make sure to follow best practices when prompting for notifications and inspire acceptance through relevant usages like train delays, price tracking, out of stock products, etc.\n\n**Technically, push notifications on the web run in the background thanks to a service worker and are often sent by a system built for managing campaigns** (e.g. Firebase). This feature brings great business value for mobile (Android) and desktop users: it increases repeated visits and consequently sales and conversions.\n\n#### The P in PWA: a progressive launch, feature by feature\n\nPWAs are modern websites that benefit from the massive reach of the web, combined with all the user-friendly features that users love in native apps. They leverage a set of best practices and modern web APIs, that can be implemented independently depending on your business specificities and priorities.\n\nTo accelerate the modernization of your website and make it a real PWA, we encourage you to be agile: **launch feature by feature**. First, research with your users what features would bring them the most value, then deliver them with your designers and developers, and finally do not forget to measure precisely how much extra money your PWA generated.\n\n\n","references":"- [Web.dev - What are PWAs? (Sam Richard & Pete LePage)](https://web.dev/what-are-pwas/)\n- [Web.dev - How Progressive Web Apps can drive your business success? (Sébastien Fourault)](https://web.dev/drive-business-success/)","featured_image_url":"https://codersnack.com/assets/images/pwa-icon.png","slug":"pwa-what-are","weblink":"https://codersnack.com/pwa-what-are/","featured_image_preview":{"id":107,"name":"pwa-icon.png","hash":"5def9c9eeee0431da4dfe6d3b48d192f","sha256":"yhaR8kQkchU4dgBiCKV0H1hvLJeMjCVl1n6AB68F9L4","ext":".png","mime":"image/png","size":58.91,"url":"/uploads/5def9c9eeee0431da4dfe6d3b48d192f.png","provider":"local","provider_metadata":null,"created_at":"2020-06-04T19:41:03.462Z","updated_at":"2020-06-04T19:41:03.462Z"}},"codersnacks_quiz":{"id":63,"question":"PWA - What pillars transforms PWA apps feel like native apps?","response_valid":"Capable, Reliable and Installable","response_invalid1":"Security, Smooth UIs and Installable","response_invalid2":"Capable, Cross-Platform and Escalable","created_at":"2020-06-04T19:44:33.602Z","updated_at":"2020-06-04T19:44:33.602Z"},"codersnacks_category":{"id":14,"header":"Progresive Web Applications (PWA)","description":"Progressive Web Apps (PWA) are built and enhanced with modern APIs to deliver native-like capabilities","snacks_by_cat_json_filename":"pwa.snacks.json","key":"pwa","image_url":"https://codersnack.com/assets/images/pwa-icon.png","created_at":"2020-06-04T19:12:01.954Z","updated_at":"2020-06-04T19:12:01.954Z","image_preview":{"id":106,"name":"pwa-icon.png","hash":"a256329dd69541e1af9785f22f4d46e8","sha256":"yhaR8kQkchU4dgBiCKV0H1hvLJeMjCVl1n6AB68F9L4","ext":".png","mime":"image/png","size":58.91,"url":"/uploads/a256329dd69541e1af9785f22f4d46e8.png","provider":"local","provider_metadata":null,"created_at":"2020-06-04T19:12:01.970Z","updated_at":"2020-06-04T19:12:01.970Z"}},"title":"PWA - What are PWAs?","created_at":"2020-06-04T19:45:32.818Z","updated_at":"2020-06-04T19:45:32.822Z"},{"id":64,"codersnack":{"id":80,"header":"Service Workers: An Introduction","created_at":"2020-06-08T19:22:53.955Z","updated_at":"2020-06-08T19:22:53.955Z","explanation":"**Rich offline experiences, periodic background syncs, push notifications**—functionality that would normally require a native application—are coming to the web. **Service workers provide the technical foundation that all these features rely on**.\n\n## What is a service worker\n\n**A service worker is a script that your browser runs in the background, separate from a web page**, opening the door to **features that don't need a web page or user interaction**. Today, they already include features like **push notifications** and **background sync**. In the future, service workers might support other things like *periodic sync* or *geofencing*. The core feature discussed in this tutorial is the ability to **intercept and handle network requests, including programmatically managing a cache of responses**.\n\nThe reason this is such an exciting API is that it allows you to support offline experiences, giving developers complete control over the experience.\n\n> **Before service worker**, there was one other API that gave users an offline experience on the web called **AppCache**. There are a number of issues with the AppCache API that service workers were designed to avoid.\n\nThings to note about a service worker:\n\n- It's a JavaScript Worker, so it **can't access the DOM directly**. Instead, a service worker can *communicate with the pages it controls by responding to messages sent via the postMessage* interface, and those pages can manipulate the DOM if needed.\n- Service worker is a **programmable network proxy**, allowing you to control how network requests from your page are handled.\n- It's terminated when not in use, and restarted when it's next needed, so **you cannot rely on global state within a service worker's onfetch and onmessage handlers**. If there is information that **you need to persist** and reuse across restarts, service workers do have access to the **IndexedDB API**.\n- Service workers **make extensive use of promises**, so if you're new to promises, then you should stop reading this and check out *Promises*, an introduction.\n\n\n## The service worker life cycle\nA service worker has a **lifecycle that is completely separate from your web page**.\n\n**To install a service worker for your site, you need to register it**, which *you do in your page's JavaScript*. Registering a service worker will cause the browser to start the service worker install step in the background.\n\n**Typically during the install step, you'll want to cache some static assets**. If all the files are cached successfully, then the service worker becomes installed. If any of the files fail to download and cache, then the install step will fail and the service worker won't activate (i.e. won't be installed). If that happens, don't worry, it'll try again next time. But that means if it does install, you know you've got those static assets in the cache.\n\n**When installed, the activation step will follow** and this is a great opportunity for *handling any management of old caches*, which we'll cover during the service worker update section.\n\n**After the activation step, the service worker will control all pages that fall under its scope**, though the page that registered the service worker for the first time won't be controlled until it's loaded again. **Once a service worker is in control, it will be in one of two states**: \n- either the service worker *will be terminated to save memory,*\n- or it will *handle fetch and message events* that occur when a network request or message is made from your page.\n\n\nBelow is an overly simplified version of the service worker lifecycle on its first installation.\n\n\n![service worker lifecycle](https://codersnack.com/assets/images/sw-lifecycle.png)\n\n\n## Prerequisites\n\n### Browser support\n\nBrowser options are growing. Service workers are supported by Chrome, Firefox and Opera. Microsoft Edge is now showing public support. Even Safari has dropped hints of future development. You can follow the progress of all the browsers at Jake Archibald's is Serviceworker ready site.\n\n### You need HTTPS\nDuring development you'll be able to use service worker through localhost, but **to deploy it on a site you'll need to have HTTPS setup on your server**.\n\n> Using service worker you **can hijack connections, fabricate, and filter responses**. Powerful stuff. While you would use these powers for good, a man-in-the-middle might not. To avoid this, you can only register service workers on pages served over HTTPS, so we know the service worker the browser receives hasn't been tampered with during its journey through the network.\n\nGitHub Pages are served over HTTPS, so they're a great place to host demos.\n\n> If you want to add HTTPS to your server then you'll need to get a TLS certificate and set it up for your server. This varies depending on your setup, so check your server's documentation and be sure to check out Mozilla's SSL config generator for best practices.\n\n## Register a service worker\nTo install a service worker you need to kick start the process by registering it in your page. This **tells the browser where your service worker JavaScript file lives**.\n\n```\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', function() {\n    navigator.serviceWorker.register('/sw.js').then(function(registration) {\n      // Registration was successful\n      console.log('ServiceWorker registration successful with scope: ', registration.scope);\n    }, function(err) {\n      // registration failed :(\n      console.log('ServiceWorker registration failed: ', err);\n    });\n  });\n}\n```\n\nThis code checks to see if the service worker API is available, and if it is, the service worker at */sw.js* is registered once the page is loaded.\n\n> You can call *register()* every time a page loads without concern; the browser will figure out if the service worker is already registered or not and handle it accordingly.\n\nOne subtlety with the *register()* method is the location of the service worker file. You'll notice in this case that the **service worker file is at the root of the domain**. This means that the service worker's scope will be the entire origin. In other words, **this service worker will receive fetch events for everything on this domain**. If we register the service worker file at /example/sw.js, then the service worker would only see fetch events for pages whose URL starts with /example/ (i.e. /example/page1/, /example/page2/).\n\nNow you can check that a service worker is enabled by going to ```chrome://inspect/#service-workers``` and looking for your site.\n\n## Inspect service workers\n\nWhen service worker was first being implemented, you could also view your service worker details through ```chrome://serviceworker-internals```. This may still be useful, if for nothing more than learning about the life cycle of service workers, but don't be surprised if it gets replaced completely by ```chrome://inspect/#service-workers``` at a later date.\n\n**You may find it useful to test your service worker in an *Incognito window* so that you can close and reopen knowing that the previous service worker won't affect the new window**. Any registrations and caches created from within an Incognito window will be cleared out once that window is closed.\n\n## Install a service worker\n\nAfter a controlled page kicks off the registration process, let's shift to the point of view of the service worker script, which handles the install event.\n\nFor the most basic example, you need **to define a callback for the install event** and decide which files you want to cache.\n\n```\nself.addEventListener('install', function(event) {\n  // Perform install steps\n});\n```\n\nInside of our install callback, we need to take the following steps:\n\n- Open a cache.\n- Cache our files.\n- Confirm whether all the required assets are cached or not.\n\n```\nvar CACHE_NAME = 'my-site-cache-v1';\nvar urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/script/main.js'\n];\n\nself.addEventListener('install', function(event) {\n  // Perform install steps\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(function(cache) {\n        console.log('Opened cache');\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n```\n\nHere you can see we call ```caches.open()``` with our desired cache name, after which we call ```cache.addAll()``` and pass in our array of files. This is a chain of promises (*caches.open()* and *cache.addAll()*). The ```event.waitUntil()``` method takes a promise and uses it *to know how long installation takes*, and whether it succeeded or not.\n\n**If all the files are successfully cached, then the service worker will be installed. If any of the files fail to download, then the install step will fail**. This allows you to rely on having all the assets that you defined, but does mean you **need to be careful with the list of files you decide to cache** in the install step. Defining a long list of files will increase the chance that one file may fail to cache, leading to your service worker not getting installed.\n","references":"- [Google developers - Service Workers Introduction - Matt Gaunt](https://developers.google.com/web/fundamentals/primers/service-workers)","featured_image_url":"https://codersnack.com/assets/images/pwa-icon.png","slug":"pwa-service-workers-introduction","weblink":"https://codersnack.com/pwa-service-workers-introduction/","featured_image_preview":{"id":108,"name":"pwa-icon.png","hash":"89ed2158296142da88b1242fafcd55f5","sha256":"yhaR8kQkchU4dgBiCKV0H1hvLJeMjCVl1n6AB68F9L4","ext":".png","mime":"image/png","size":58.91,"url":"/uploads/89ed2158296142da88b1242fafcd55f5.png","provider":"local","provider_metadata":null,"created_at":"2020-06-08T19:22:53.973Z","updated_at":"2020-06-08T19:22:53.973Z"}},"codersnacks_quiz":{"id":64,"question":"What kind of thinks can do a Service Worker?","response_valid":"control network requests, access to the IndexedDB API","response_invalid1":"access to the DOM's page","response_invalid2":"read disk files","created_at":"2020-06-08T19:28:04.766Z","updated_at":"2020-06-08T19:28:04.766Z"},"codersnacks_category":{"id":14,"header":"Progresive Web Applications (PWA)","description":"Progressive Web Apps (PWA) are built and enhanced with modern APIs to deliver native-like capabilities","snacks_by_cat_json_filename":"pwa.snacks.json","key":"pwa","image_url":"https://codersnack.com/assets/images/pwa-icon.png","created_at":"2020-06-04T19:12:01.954Z","updated_at":"2020-06-04T19:12:01.954Z","image_preview":{"id":106,"name":"pwa-icon.png","hash":"a256329dd69541e1af9785f22f4d46e8","sha256":"yhaR8kQkchU4dgBiCKV0H1hvLJeMjCVl1n6AB68F9L4","ext":".png","mime":"image/png","size":58.91,"url":"/uploads/a256329dd69541e1af9785f22f4d46e8.png","provider":"local","provider_metadata":null,"created_at":"2020-06-04T19:12:01.970Z","updated_at":"2020-06-04T19:12:01.970Z"}},"title":"PWA - Service Worker Introduction","created_at":"2020-06-08T19:28:33.764Z","updated_at":"2020-06-08T19:28:33.768Z"}]