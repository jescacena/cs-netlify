[{"id":177,"codersnack":{"id":59,"header":"LitElement and lit-html Introduction","created_at":"2020-03-30T13:59:50.431Z","updated_at":"2020-04-14T15:08:28.972Z","explanation":"### What is LitElement?\n\n**LitElement** is a **simple base class for creating fast, lightweight web components** that work in any web page with any framework.\n\n**LitElement uses lit-html to render into shadow DOM**, and **adds API to manage properties and attributes**. *Properties are observed by default, and elements update asynchronously when their properties change*.\n\n### Setup\n**You need npm and Node.js** to work with LitElement.\n\n**LitElement uses JavaScript modules to import dependencies** by their npm package names. Since web browsers need to know a file's full URL to import it, your local development server needs to serve full, transformed URL paths to your web browser.\n\n**To deploy an optimized build** that works on your target browsers, you’ll also **need a build toolset** that can handle this transform, along with any bundling.\n\n**One option is Polymer CLI**, which includes a development server that converts module names to paths on the fly; and a configurable build tool that packages your code for deployment.\n\nTo install Polymer CLI with npm:\n```\nnpm install -g polymer-cli\n```\nTo serve a LitElement project locally:\n\n```\npolymer serve\n```\nSee the Polymer CLI documentation for more information on configuring these tools.\n\n\n### Create a LitElement component\nTo create a new class based on LitElement:\n\nIn your project folder, install the lit-element package from npm:\n\n```\nnpm install lit-element\n```\n\nWrite your new element:\n\n- Import the LitElement base class and the html helper function.\n- Create a new class that extends the LitElement base class.\n- Implement render to define a template for your web component.\n- Register your component’s HTML tag with the browser.\n\n*Example*\n\n**my-element.js**\n\n```\n// Import the LitElement base class and html helper function\nimport { LitElement, html } from 'lit-element';\n\n// Extend the LitElement base class\nclass MyElement extends LitElement {\n\n  /**\n   * Implement `render` to define a template for your element.\n   *\n   * You must provide an implementation of `render` for any element\n   * that uses LitElement as a base class.\n   */\n  render(){\n    /**\n     * `render` must return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function:\n     */\n    return html`\n      <!-- template content -->\n      <p>A paragraph</p>\n    `;\n  }\n}\n// Register the new element with the browser.\ncustomElements.define('my-element', MyElement);\n```\n\n### Use LitElement TypeScript decorators\nYou can use the **@customElement TypeScript decorator** to define your class as a custom element:\n\n```\n/**\n * Import LitElement base class, html helper function,\n * and TypeScript decorators\n **/\nimport {\n  LitElement, html, customElement, property\n} from 'lit-element';\n\n/**\n * Use the customElement decorator to define your class as\n * a custom element. Registers <my-element> as an HTML tag.\n */\n@customElement('my-element')\nexport class MyElement extends LitElement {\n\n  /**\n   * Create an observed property. Triggers update on change.\n   */\n  @property()\n  foo = 'foo';\n\n  /**\n   * Implement `render` to define a template for your element.\n   */\n  render(){\n    /**\n     * Use JavaScript expressions to include property values in\n     * the element template.\n     */\n    return html`<p>${this.foo}</p>`;\n  }\n}\n```\n\n### Import a component\nImport your own LitElement component\nIn an HTML document:\n\n```\n<head>\n  <script type=\"module\" src=\"/path/to/my-element.js\"></script>\n</head>\n<body>\n  <my-element></my-element>\n</body>\n```\n\nIn another JavaScript module:\n\n```\n// Use relative paths for peer dependencies\nimport './my-element.js';\n\nclass MyOtherElement extends LitElement{\n  render(){\n    return html`\n      <my-element></my-element>\n    `;\n  }\n}\ncustomElements.define('my-other-element', MyOtherElement);\n```\n### Import a third-party LitElement component\nRefer to third-party component documentation first. To work with any existing component made by a third party, see its documentation. This guide should work for most LitElement-based components if they are published on npm.\n\nMany components are published on npm and can be installed from the command line:\n\n```\ncd my-project-folder\nnpm install package-name\n```\nIn an HTML document, a component published on npm can be imported from the node_modules folder:\n\n```\n<head>\n  <script type=\"module\" src=\"node_modules/package-name/existing-element.js\"></script>\n</head>\n<body>\n  <existing-element></existing-element>\n</body>\n```\nTo import into another JavaScript module, use the component’s package name:\n\n```\nimport 'package-name/existing-element.js';\n\nclass MyElement extends LitElement{\n  render(){\n    return html`\n      <existing-element></existing-element>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### What is lit-html?\nlit-html is a simple, modern, safe, small and fast **HTML templating library for JavaScript.**\n\nlit-html lets you write HTML templates in JavaScript using **template literals with embedded JavaScript expressions**. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.\n\nBuilding components? **lit-html is not tied to any component model**, it focuses only on creating and updating DOM. If you want to build components, check out **LitElement**, a library for building web components using lit-html templates.\n\n### lit-html Templates\nlit-html templates are **tagged template literals** - they look like JavaScript strings but are enclosed in backticks (`) instead of quotes - and tagged with lit-html's html tag:\n\n```\nhtml`<h1>Hello ${name}</h1>`\n```\nSince lit-html templates almost always need to merge in data from JavaScript values, and be able to update DOM when that data changes, they'll most often be written within functions that take some data and return a lit-html template, so that the function can be called multiple times:\n\n```\nlet myTemplate = (data) => html`\n  <h1>${data.title}</h1>\n  <p>${data.body}</p>`;\n```\n**lit-html is lazily rendered**. Calling this function will evaluate the template literal using lit-html html tag, and return a **TemplateResult** - a record of the template to render and data to render it with. TemplateResults are very cheap to produce and no real work actually happens until they are rendered to the DOM.\n\n### Rendering\nTo render a TemplateResult, call the ```render()``` function with a result and DOM container to render to:\n\n```\nconst result = myTemplate({title: 'Hello', body: 'lit-html is cool'});\nrender(result, document.body);\n```\n\n","references":"- [lit-html project](https://lit-html.polymer-project.org/guide)\n- [Example LitElement project](https://github.com/PolymerLabs/start-lit-element)\n- [lit-element project](https://lit-element.polymer-project.org/)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"lit-element-lit-html-introduction","weblink":"https://codersnack.com/lit-element-lit-html-introduction/","featured_image_preview":{"id":95,"name":"litelement-icon.png","hash":"06b6d9e7bfb645fa926460601fc692d2","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/06b6d9e7bfb645fa926460601fc692d2.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:28.984Z","updated_at":"2020-04-14T15:08:28.984Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement and LitHtml Introduction (LitElement label)","created_at":"2022-04-26T08:00:25.890Z","updated_at":"2022-04-26T08:00:25.899Z"},{"id":178,"codersnack":{"id":60,"header":"LitElement Templates 1","created_at":"2020-03-31T08:59:29.566Z","updated_at":"2020-04-14T15:08:15.088Z","explanation":"Add a template to your component to define internal DOM to implement your component.\n\nTo encapsulate the templated DOM LitElement uses **shadow DOM**. Shadow DOM provides three benefits:\n\n- **DOM scoping**. DOM APIs like document.querySelector won’t find elements in the component’s shadow DOM, so it’s harder for global scripts to accidentally break your component.\n- **Style scoping**. You can write encapsulated styles for your shadow DOM that don’t affect the rest of the DOM tree.\n- **Composition**. The component’s shadow DOM (managed by the component) is separate from the component’s children. You can choose how children are rendered in your templated DOM. Component users can add and remove children using standard DOM APIs without accidentally breaking anything in your shadow DOM.\n\nWhere native shadow DOM isn’t available, LitElement uses the **Shady CSS polyfill**.\n\n### Define and render a template\nTo define a template for a LitElement component, write a render function for your element class:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>template content</p>`;\n  }\n}\n```\n\nWrite your template in HTML inside a JavaScript template literal by enclosing the raw HTML in back-ticks (``).\n\n**Tag your template literal with the html tag function**.\n\nThe component’s render method can return anything that lit-html can render. Typically, **it returns a single TemplateResult object** (the same type returned by the html tag function).\n\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n\n  // Implement `render` to define a template for your element.\n  render(){\n    /**\n     * Return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function.\n     */\n    return html`\n      <div>\n        <p>A paragraph</p>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n**LitElement uses lit-html templates**; this page summarizes the features of lit-html templates, for more details, see Writing templates and the Template syntax reference in the lit-html documentation.\n\n### Design a performant template\n**LitElement renders and re-renders asynchronously, updating in response to batched property changes** (see Element update lifecycle for more information).\n\n**During an update, only the parts of the DOM that change are re-rendered**. To get the performance benefits of this model, **you should design your element's template as a pure function of its properties**.\n\nTo do this, make sure the render function:\n\n- Does not change the element’s state.\n- Does not have any side effects.\n- Only depends on the element’s properties.\n- Returns the same result when given the same property values.\n- Also, avoid making DOM updates outside of render. Instead, express the element’s template as a function of its state, and capture its state in properties.\n\nThe following code uses inefficient DOM manipulation:\n\n**dom-manip.js**\n\n```\n// Anti-pattern. Avoid!\n\nconstructor() {\n  super();\n  this.addEventListener('stuff-loaded', (e) => {\n    this.shadowRoot.getElementById('message').innerHTML=e.detail;\n  });\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p id=\"message\">Loading</p>\n  `;\n}\n```\n\nWe can improve the template by capturing the load message as a property, and setting the property in response to the event:\n\n**update-properties.js**\n\n```\nconstructor() {\n  super();\n  this.message = 'Loading';\n  this.addEventListener('stuff-loaded', (e) => { this.message = e.detail } );\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p>${this.message}</p>\n  `;\n}\n```\n\n### Use properties, loops, and conditionals in a template\nWhen defining your element's template, you can **bind the element's properties to the template; the template is re-rendered whenever the properties change.**\n\n##### Properties\nTo add a property value to a template, insert it with ```${this.propName}```:\n\n```\nstatic get properties() {\n  return { myProp: String };\n}\n...\nrender() {\n  return html`<p>${this.myProp}</p>`;\n}\n```\n\n##### Loops\nIterate over an array:\n\n```\nhtml`<ul>\n  ${this.myArray.map(i => html`<li>${i}</li>`)}\n</ul>`;\n```\n##### Conditionals\nRender based on a Boolean condition:\n\n```\nhtml`\n  ${this.myBool?\n    html`<p>Render some HTML if myBool is true</p>`:\n    html`<p>Render some other HTML if myBool is false</p>`}\n`;\n```\n**Examples**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      myString: { type: String },\n      myArray: { type: Array },\n      myBool: { type: Boolean }\n    };\n  }\n  constructor() {\n    super();\n    this.myString = 'Hello World';\n    this.myArray = ['an','array','of','test','data'];\n    this.myBool = true;\n  }\n  render() {\n    return html`\n      <p>${this.myString}</p>\n      <ul>\n        ${this.myArray.map(i => html`<li>${i}</li>`)}\n      </ul>\n      ${this.myBool?\n        html`<p>Render some HTML if myBool is true</p>`:\n        html`<p>Render some other HTML if myBool is false</p>`}\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates","weblink":"https://codersnack.com/webcomponents-litelement-templates/","featured_image_preview":{"id":94,"name":"litelement-icon.png","hash":"b3ca5cab6412452092f10c43a1ab61c3","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/b3ca5cab6412452092f10c43a1ab61c3.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:15.101Z","updated_at":"2020-04-14T15:08:15.101Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement Templates 1 (Lit label)","created_at":"2022-04-26T08:00:52.543Z","updated_at":"2022-04-26T08:00:52.552Z"},{"id":179,"codersnack":{"id":61,"header":"LitElement Templates 2","created_at":"2020-03-31T14:13:31.829Z","updated_at":"2020-04-14T15:08:01.179Z","explanation":"### Bind properties to templated elements\nYou can insert JavaScript expressions as placeholders for HTML text content, attributes, Boolean attributes, properties, and event handlers.\n\n- Text content: ```<p>${...}</p>```\n- Attribute: ```<p id=\"${...}\"></p>```\n- Boolean attribute: ```?disabled=\"${...}\"```\n- Property: ```.value=\"${...}\"```\n- Event handler: ```@event=\"${...}\"```\n\nJavaScript expressions can include your element's properties. **LitElement observes and reacts to property changes, so your templates update automatically**.\n\n**Data bindings are always one-way (parent to child)**. \n> To share data from a child element to its parent, fire an event and capture the relevant data in the detail property**.\n\n#### Bind to text content\nBind prop1 to text content:\n\n```\nhtml`<div>${this.prop1}</div>`\n```\n#### Bind to an attribute\nBind prop2 to an attribute:\n\n```\nhtml`<div id=\"${this.prop2}\"></div>`\n```\nAttribute values are always strings, so an **attribute binding should return a value that can be converted into a string**.\n\n#### Bind to a boolean attribute\nBind prop3 to a boolean attribute:\n\n```\nhtml`<input type=\"text\" ?disabled=\"${this.prop3}\">`\n```\nBoolean attributes are added if the expression evaluates to a truthy value, and removed if it evaluates to a falsy value.\n\n#### Bind to a property\nBind prop4 to a property:\n\n```\nhtml`<input type=\"checkbox\" .value=\"${this.prop4}\"/>`\n```\n\n#### Bind to an event handler\nBind clickHandler to a click event:\n\n```\nhtml`<button @click=\"${this.clickHandler}\">pie?</button>`\n```\nThe default event context for ```@event``` expressions is this, so **there is no need to bind the handler function**.\n\n**Examples**\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: String,\n      prop2: String,\n      prop3: Boolean,\n      prop4: String\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 'text binding';\n    this.prop2 = 'mydiv';\n    this.prop3 = true;\n    this.prop4 = 'pie';\n  }\n  render() {\n    return html`\n      <!-- text binding -->\n      <div>${this.prop1}</div>\n\n      <!-- attribute binding -->\n      <div id=\"${this.prop2}\">attribute binding</div>\n\n      <!-- boolean attribute binding -->\n      <div>\n        boolean attribute binding\n        <input type=\"text\" ?disabled=\"${this.prop3}\"/>\n      </div>\n\n      <!-- property binding -->\n      <div>\n        property binding\n        <input type=\"text\" .value=\"${this.prop4}\"/>\n      </div>\n\n      <!-- event handler binding -->\n      <div>event handler binding\n        <button @click=\"${this.clickHandler}\">click</button>\n      </div>\n    `;\n  }\n  clickHandler(e) {\n    console.log(e.target);\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n\n### Render children with the slot element\nYour component may accept children (like a ```<ul>``` element can have ```<li>``` children).\n\n```\n<my-element>\n  <p>A child</p>\n</my-element>\n```\n\n**By default, if an element has a shadow tree, its children don't render at all. To render children, your template needs to include one or more ```<slot>``` elements, which act as placeholders for child nodes.**\n\n### Use the slot element\nTo render an element's children, create a ```<slot>``` for them in the element's template. For example:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot></slot>\n    </div>\n  `;\n}\n```\nChildren will now render in the ```<slot>```:\n\n```\n<my-element>\n  <p>Render me</p>\n</my-element>\n```\nThe children aren't moved in the DOM tree, but they’re rendered as if they were children of the ```<slot>```.\n\nArbitrarily many children can populate a single slot:\n\n```\n<my-element>\n  <p>Render me</p>\n  <p>Me too</p>\n  <p>Me three</p>\n</my-element>\n```\n\n### Use named slots\nTo assign a child to a specific slot, ensure that the child's slot attribute matches the slot's name attribute:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot name=\"one\"></slot>\n    </div>\n  `;\n}\n```\n**index.html**\n\n```\n<my-element>\n  <p slot=\"one\">Include me in slot \"one\".</p>\n</my-element>\n```\nNamed slots only accept children with a matching slot attribute.\n\nFor example, ```<slot name=\"one\"></slot>``` only accepts children with the attribute ```slot=\"one\"```.\n\nChildren with a slot attribute will only be rendered in a slot with a matching name attribute.\n\nFor example, ```<p slot=\"one\">...</p>``` will only be placed in ```<slot name=\"one\"></slot>```.\n\n**Examples**\n\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render(){\n    return html`\n      <div>\n        <slot name=\"one\"></slot>\n        <slot name=\"two\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*index.html*\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js\"></script>\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js\"></script>\n  \n  <script type=\"module\" src=\"./my-element.js\"></script>\n  <title>lit-element code sample</title>\n</head>\n<body>\n    <!-- Assign child to a specific slot -->\n\n    <my-element>\n      <p slot=\"two\">Include me in slot \"two\".</p>\n    </my-element>\n\n    <!-- \n      Named slots only accept children with a matching `slot` attribute. \n      \n      Children with a `slot` attribute can only go into a slot with a matching name. \n    -->\n\n    <my-element>\n      <p slot=\"one\">Include me in slot \"one\".</p>\n      <p slot=\"nope\">This one will not render at all.</p>\n      <p>No default slot, so this one won't render either.</p>\n    </my-element>\n</body>\n</html>\n```\n\n### Use name, not id, to select slots.\n\nNote that a slot’s id attribute has no effect!\n\n*my-element.js*\n\n```\nrender(){\n  return html`\n    <div>\n      <slot id=\"one\"></slot>\n    </div>\n  `;\n}\n```\n\n*index.html*\n\n```\n<my-element>\n  <p slot=\"one\">nope.</p>\n  <p>ohai..</p>\n</my-element>\n```","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates-2","weblink":"https://codersnack.com/webcomponents-litelement-templates-2/","featured_image_preview":{"id":93,"name":"litelement-icon.png","hash":"37397228be82426aba418750bb5b0e7a","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/37397228be82426aba418750bb5b0e7a.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:01.192Z","updated_at":"2020-04-14T15:08:01.192Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement Templates 2 (Lit label)","created_at":"2022-04-26T08:01:22.284Z","updated_at":"2022-04-26T08:01:22.291Z"},{"id":180,"codersnack":{"id":62,"header":"LitElement Templates 3","created_at":"2020-03-31T14:33:50.941Z","updated_at":"2020-04-14T15:07:30.838Z","explanation":"### Compose a template from other templates\nYou can compose LitElement templates from other LitElement templates. In the following example, we compose a template for an element called ```<my-page>``` from smaller templates for the standard HTML elements ```<header>```, ```<article>```, and ```<footer>```:\n\n```\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      ${this.headerTemplate}\n      ${this.articleTemplate}\n      ${this.footerTemplate}\n    `;\n  }\n  get headerTemplate() {\n    return html`<header>header</header>`;\n  }\n  get articleTemplate() {\n    return html`<article>article</article>`;\n  }\n  get footerTemplate() {\n    return html`<footer>footer</footer>`;\n  }\n}\n```\nYou can also compose templates by importing other elements and using them in your template:\n\n```\nimport './my-header.js';\nimport './my-article.js';\nimport './my-footer.js';\n\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      <my-header></my-header>\n      <my-article></my-article>\n      <my-footer></my-footer>\n    `;\n  }\n}\n```\n\n### Specify the render root\n**The node into which your component's template will render is called its render root**.\n\n**By default, LitElement creates an open shadowRoot and renders inside it,** producing the following DOM structure:\n\n```\n<my-element>\n  #shadow-root\n    <p>child 1</p>\n    <p>child 2</p>\n```\n\nTo customize a component's render root, implement **createRenderRoot** and return the node you want the template to render into.\n\nFor example, to render the template into the main DOM tree as your element's children:\n\n```\n<my-element>\n  <p>child 1</p>\n  <p>child 2</p>\n```\nImplement createRenderRoot and return this:\n\n```\nclass LightDom extends LitElement {\n  render() {\n    return html`\n      <p>This template renders without shadow DOM.</p>\n    `;\n  }\n  createRenderRoot() {\n  /**\n   * Render template without shadow DOM. Note that shadow DOM features like \n   * encapsulated CSS and slots are unavailable.\n   */\n    return this;\n  }\n}\n```\n\n### Using other lit-html features\nSince **LitElement uses the lit-html html tag function to define templates** you can take advantage of the entire lit-html feature set for writing your templates. This includes lit-html directives, special functions that customize the way lit-html renders a binding.\n\n**To import features directly from lit-html, your project should add lit-html as a direct dependency**. We recommend using the widest practical version range for lit-html, to minimize the chance of npm installing two different versions of lit-html:\n\n```\nnpm i lit-element@^2.0.0\nnpm i lit-html@^1.0.0\n```\n#### Import and use a lit-html directive\nYou can import and use a lit-html directive and use it as shown in the lit-html documentation.\n\n```\nimport { LitElement, html } from 'lit-element';\nimport { until } from 'lit-html/directives/until.js';\n\nconst content = fetch('./content.txt').then(r => r.text());\n\nhtml`${until(content, html`<span>Loading...</span>`)}`\n```\nFor a list of directives supplied with lit-html, see Built-in directives in the Template syntax reference.\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates-3","weblink":"https://codersnack.com/webcomponents-litelement-templates-3/","featured_image_preview":{"id":91,"name":"litelement-icon.png","hash":"84ac11553a3f4f228ba6fc881c25bf10","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/84ac11553a3f4f228ba6fc881c25bf10.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:30.851Z","updated_at":"2020-04-14T15:07:30.851Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement templates 3 (lit label)","created_at":"2022-04-26T08:01:52.846Z","updated_at":"2022-04-26T08:01:52.850Z"},{"id":181,"codersnack":{"id":63,"header":"LitElement Properties 1","created_at":"2020-03-31T15:08:19.241Z","updated_at":"2020-04-14T15:07:45.096Z","explanation":"### Overview\n**LitElement manages your declared properties and their corresponding attributes**. By default, LitElement will:\n\n- Ensure that an **element update is scheduled when any declared property changes**.\n- Capture instance values for declared properties. Apply any property values that are set before the browser registers a custom element definition.\n- **Set up an observed (not reflected) attribute** with the lowercased name of each property.\n- **Handle attribute conversion** for properties declared as type String, Number, Boolean, Array, and Object.\n- Use **direct comparison (oldValue !== newValue) to test for property changes**.\n- Apply any property options and accessors declared by a superclass.\n\n> Remember to declare all of the properties that you want LitElement to manage. For the property features above to be applied, you must declare the property.\n\n### Property options\nA property declaration is an object in the following format:\n```\n{ optionName1: optionValue1, optionName2: optionValue2, ... }\n```\n\nThe following options are available:\n\n- **converter**: Convert between properties and attributes.\n- **type**: Use LitElement’s default attribute converter.\n- **attribute**: Configure **observed** attributes.\n- **reflect**: Configure **reflected** attributes.\n- **noAccessor**: Whether to set up a default property accessor.\n- **hasChanged**: Specify what constitutes a property change.\n\n> All property declaration options can be specified in a static properties getter, or with TypeScript decorators.\n\n### Declare properties\nDeclare your element’s properties by implementing a static properties getter, or by using decorators:\n\n```\n// properties getter\nstatic get properties() {\n  return { \n    prop1: { type: String }\n  };\n}\n// Decorators (requires TypeScript or Babel)\nexport class MyElement extends LitElement {\n  @property( { type : String }  ) prop1 = '';\n```\n\n#### Declare properties in a static properties getter\nTo declare properties in a static properties getter:\n\n```\nstatic get properties() { \n  return { \n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean }\n  };\n}\n```\n\nIf you implement a static properties getter, initialize your property values in the element constructor.\n\n```\nconstructor() {\n  // Always call super() first\n  super();\n  this.prop1 = 'Hello World';\n  ...\n}\n```\n> Remember to call ```super()``` first in your constructor, or your element won’t render at all.\n\n**Example**: Declare properties with a static properties getter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = false;\n    this.prop4 = [1,2,3];\n    this.prop5 = { subprop1: 'prop 5 subprop1 value' }\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Declare properties with decorators\nYou can also declare properties with **decorators**:\n\n```\n@property({type : String})  prop1 = 'Hello World';\n```\n> Decorators are a proposed JavaScript feature, so you’ll need to use a transpiler like Babel or the TypeScript compiler to use decorators.\n\nIf you’re using Babel, you’ll need to use the ```@babel/plugin-proposal-decorators```  plugin.\n\nIf you’re using TypeScript, you’ll need to **enable the experimentalDecorators compiler option** (for example, by setting \"experimentalDecorators\": true in *tsconfig.json*). Enabling emitDecoratorMetadata is not required and not recommended.\n\n**Example**: Declare properties with decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'prop 5 subprop1 value' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n```\n\n#### Initialize property values\nInitialize property values in the element constructor\nIf you implement a static properties getter, initialize your property values in the element constructor:\n\n```\nstatic get properties() { return { /* Property declarations */ }; } \n\nconstructor() {\n  // Always call super() first\n  super();\n\n  // Initialize properties \n  this.prop1 = 'Hello World';\n}\n```\n> Remember to call super() first in your constructor, or your element won’t render at all.\n\n**Example**: Initialize property values in the element constructor\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = true;\n    this.prop4 = [1,2,3];\n    this.prop5 = { stuff: 'hi', otherStuff: 'wow' };\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### Initialize property values when using TypeScript decorators\nTypeScript users can initialize property values when they are declared with the @property decorator:\n\n```\n@property({ type : String }) prop1 = 'Hello World';\n```\n**Example**: Initialize property values when using TypeScript decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  // Declare and initialize properties\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'hi', thing: 'fasdfsf' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\n```\n\n#### Initialize property values from attributes in markup\nYou can also initialize property values from observed attributes in markup:\n\n*index.html*\n\n```\n<my-element \n  mystring=\"hello world\"\n  mynumber=\"5\"\n  mybool\n  myobj='{\"stuff\":\"hi\"}'\n  myarray='[1,2,3,4]'></my-element>\n```\n\nSee observed attributes and converting between properties and attributes for more information on setting up initialization from attributes.","references":"- [LitElement properties](https://lit-element.polymer-project.org/guide/properties)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-properties-1","weblink":"https://codersnack.com/webcomponents-litelement-properties-1/","featured_image_preview":{"id":92,"name":"litelement-icon.png","hash":"c591b268b2d142c7a416e5f1a2c4f06e","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/c591b268b2d142c7a416e5f1a2c4f06e.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:45.109Z","updated_at":"2020-04-14T15:07:45.109Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement Properties 1 (lit label)","created_at":"2022-04-26T08:02:24.410Z","updated_at":"2022-04-26T08:02:24.417Z"},{"id":182,"codersnack":{"id":64,"header":"LitElement Properties 2","created_at":"2020-03-31T15:56:12.994Z","updated_at":"2020-04-14T15:07:15.496Z","explanation":"### Properties vs Attributes\nThe difference between properties and attributes can be confusing. **Properties are available on a DOM node** when being manipulated by JavaScript:\n\n```\nconst myElem = document.querySelector('.my-elem');\nmyElem.className; // className is a property\n```\nAnd **attributes are provided in the HTML itself**. Here alt, width and height are all attributes:\n```\n<img src=\"/path/to/img.svg\" alt=\"My Image\" width=\"150\" height=\"250\">\n```\n**Attributes should only be used for scalar values like strings, numbers and boolean values**. **Properties, on the other hand, are perfectly suited to also hold values that are objects or arrays**.\n\n### Reflecting Properties to Attributes\n**Most properties reflect their values as attributes, meaning that if the property is changed using JavaScript, the corresponding attribute is also changed at the same time to reflect the new value**. This is useful for accessibility and to allow CSS selectors to work as intended.\n\nYou can try it out yourself for a concrete example. Just select, say, an image element in your browser’s developer tools, and then change one of its properties:\n\n```\nconst fancyImage = document.querySelector('.fancy-image');\n\nfancyImage.width = 777;\n```\nNotice how the with attribute in the DOM representation is automatically changed to the new value. The same is true if you change the value for the attribute manually in the DOM inspector, you’ll see that the property will now hold the new value.\n\n![attributes-properties](https://codersnack.com/assets/images/attributes-properties.png)\n\n### Reflecting properties to attributes in Custom Elements\nYour own Custom Elements should also follow this practice of reflecting properties to attributes. Luckily, it's quite easy to do using getters and setters.\n\nFor example, if you have a custom element that has a value property that should be reflected as an attribute, here’s how you would use a getter and a setter to get the value of the attribute when doing property access and setting the new value for the attribute when the property is changed:\n\n```\nget value() {\n  return this.getAttribute('value');\n}\n\nset value(newValue) {\n  this.setAttribute('value', newValue);\n}\n```\nOr, if you have a boolean property, like, say hidden:\n\n```\nget hidden() {\n  return this.hasAttribute('hidden');\n}\n\nset hidden(isHidden) {\n  if (isHidden) {\n    this.setAttribute('hidden', '');\n  } else {\n    this.removeAttribute('hidden');\n  }\n}\n```\n\n### Configure attributes\n\n#### Convert between properties and attributes\n\n**While element properties can be of any type, attributes are always strings**. This impacts the observed attributes and reflected attributes of non-string properties:\n\nTo observe an attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type.\n\nTo reflect an attribute (set an attribute from a property), the property value must be converted to a string.\n\n#### Use the default converter\nLitElement has a default converter which handles String, Number, Boolean, Array, and Object property types.\n\n**To use the default converter, specify the type option in your property declaration**:\n```\n// Use LitElement's default converter \nprop1: { type: String },\nprop2: { type: Number },\nprop3: { type: Boolean },\nprop4: { type: Array },\nprop5: { type: Object }\n```\nThe information below shows how the default converter handles conversion for each type.\n\n#### Convert from attribute to property\n\n- For Strings, when the attribute is defined, set the property to the attribute value.\n- For Numbers, when the attribute is defined, set the property to Number(attributeValue).\n- For Booleans, when the attribute is:\n     non-null, set the property to true.\n     null or undefined, set the property to false.\n- For Objects and Arrays, when the attribute is:\n     Defined, set the property value to JSON.parse(attributeValue).\n\n#### Convert from property to attribute\n\n- For Strings, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Numbers, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Booleans, when the property is:\n    truthy, create the attribute.\n    falsy, remove the attribute.\n- For Objects and Arrays, when the property is:\n    null or undefined, remove the attribute.\n    Defined and not null, set the attribute value to JSON.stringify(propertyValue).\n\n**Example**: Use the default converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String, reflect: true },\n    prop2: { type: Number, reflect: true },\n    prop3: { type: Boolean, reflect: true },\n    prop4: { type: Array, reflect: true },\n    prop5: { type: Object, reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = '';\n    this.prop2 = 0;\n    this.prop3 = false;\n    this.prop4 = [];\n    this.prop5 = { };\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    console.log('attribute change: ', name, newVal);\n    super.attributeChangedCallback(name, oldVal, newVal);\n  }\n\n  render() {\n    return html`\n      <p>prop1 ${this.prop1}</p>\n      <p>prop2 ${this.prop2}</p>\n      <p>prop3 ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.getAttribute('prop3');\n\n    this.setAttribute('prop1', randy.toString());\n    this.setAttribute('prop2', randy.toString());\n    this.setAttribute('prop3', myBool? '' : null);\n    this.setAttribute('prop4', JSON.stringify([...this.prop4, randy]));\n    this.setAttribute('prop5',\n      JSON.stringify(Object.assign({}, this.prop5, {[randy]: randy})));\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.prop3;\n\n    this.prop1 = randy.toString();\n    this.prop2 = randy;\n    this.prop3 = !myBool;\n    this.prop4 = [...this.prop4, randy];\n    this.prop5 = Object.assign({}, this.prop5, {[randy]: randy});\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Configure a custom converter\nYou can specify a custom property converter in your property declaration with the converter option:\n\n```\nmyProp: { \n  converter: // Custom property converter\n} \n```\nconverter can be an object or a function. If it is an object, it can have keys for fromAttribute and toAttribute:\n\n```\nprop1: { \n  converter: { \n    fromAttribute: (value, type) => { \n      // `value` is a string\n      // Convert it to a value of type `type` and return it\n    },\n    toAttribute: (value, type) => { \n      // `value` is of type `type` \n      // Convert it to a string and return it\n    }\n  }\n}\n```\nIf converter is a function, it is used in place of fromAttribute:\n\n```\nmyProp: { \n  converter: (value, type) => { \n    // `value` is a string\n    // Convert it to a value of type `type` and return it\n  }\n} \n```\nIf no **toAttribute** function is supplied for a reflected attribute, the attribute is set to the property value without conversion.\n\nDuring an update:\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n**Example**: Configure a custom converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: {\n      reflect: true,\n      converter: {\n        toAttribute(value) {\n          console.log('myProp\\'s toAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = String(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        },\n\n        fromAttribute(value) {\n          console.log('myProp\\'s fromAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = Number(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        }\n      }\n    },\n\n    theProp: {\n      reflect: true,\n      converter(value) {\n        console.log('theProp\\'s converter.');\n        console.log('Processing:', value, typeof(value));\n\n        let retVal = Number(value);\n        console.log('Returning:', retVal, typeof(retVal));\n        return retVal;\n      }},\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    // console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n    this.theProp='theProp ' + randomString;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure observed attributes\nAn **observed attribute fires** the custom elements API callback **attributeChangedCallback** whenever it changes. By default, whenever an attribute fires this callback, LitElement sets the property value from the attribute using the property's fromAttribute function. See Convert between properties and attributes for more information.\n\n**By default, LitElement creates a corresponding observed attribute for all declared properties**. The name of the observed attribute is the property name, lowercased:\n\n```\n// observed attribute name is \"myprop\"\nmyProp: { type: Number }\n```\nTo create an observed attribute with a different name, set attribute to a string:\n\n```\n// Observed attribute will be called my-prop\nmyProp: { attribute: 'my-prop' }\n```\n\n**To prevent an observed attribute from being created for a property**, set attribute to false. The property will not be initialized from attributes in markup, and attribute changes won’t affect it.\n\n```\n// No observed attribute for this property\nmyProp: { attribute: false }\n```\n\n**An observed attribute can be used to provide an initial value for a property via markup**. See Initialize properties with attributes in markup.\n\n**Example**: Configure observed attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { attribute: true },\n    theProp: { attribute: false },\n    otherProp: { attribute: 'other-prop' },\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n    this.otherProp = 'otherProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n      <p>otherProp ${this.otherProp}</p>\n\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.setAttribute('other-prop', 'other-prop ' + randomString);\n    this.requestUpdate();\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\nAn observed attribute can be used to provide an initial value for a property via markup. See Initialize properties with attributes in markup.\n\n### Configure reflected attributes\n**You can configure a property so that whenever it changes, its value is reflected to its observed attribute**. For example:\n\n```\n// Value of property \"myProp\" will reflect to attribute \"myprop\"\nmyProp: { reflect: true }\n```\n\nWhen the property changes, LitElement uses the toAttribute function in the property's converter to set the attribute value from the new property value.\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n- If toAttribute itself is undefined, the property value is set to the attribute value without conversion.\n\nLitElement tracks reflection state during updates. LitElement keeps track of state information to avoid creating an infinite loop of changes between a property and an observed, reflected attribute.\n\n**Example**: Configure reflected attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.myProp='myProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>${this.myProp}</p>\n\n      <button @click=\"${this.changeProperty}\">change property</button>\n    `;\n  }\n\n  changeProperty() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n  }\n\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure property changes\nAll declared properties have a function, **hasChanged**, which is **called whenever the property is set.**\n\nhasChanged compares the property's old and new values, and evaluates whether or not the property has changed. If hasChanged returns true, **LitElement starts an element update if one is not already scheduled**. See the Element update lifecycle documentation for more information on how updates work.\n\nBy default:\n\n- hasChanged returns true if newVal !== oldVal.\n- hasChanged returns false if both the new and old values are NaN.\n\nTo customize **hasChanged** for a property, specify it as a property option:\n\n```\nmyProp: { hasChanged(newVal, oldVal) {\n  // compare newVal and oldVal\n  // return `true` if an update should proceed\n}}\n```\n**Example**: Configure property changes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties(){ return {\n    myProp: {\n      type: Number,\n\n      /**\n       * Compare myProp's new value with its old value.\n       *\n       * Only consider myProp to have changed if newVal is larger than\n       * oldVal.\n       */\n      hasChanged(newVal, oldVal) {\n        if (newVal > oldVal) {\n          console.log(`${newVal} > ${oldVal}. hasChanged: true.`);\n          return true;\n        }\n        else {\n          console.log(`${newVal} <= ${oldVal}. hasChanged: false.`);\n          return false;\n        }\n      }\n    }};\n  }\n\n  constructor(){\n    super();\n    this.myProp = 1;\n  }\n\n  render(){\n    return html`\n      <p>${this.myProp}</p>\n      <button @click=\"${this.getNewVal}\">get new value</button>\n    `;\n  }\n\n  updated(){\n    console.log('updated');\n  }\n\n  getNewVal(){\n    let newVal = Math.floor(Math.random()*10);\n    this.myProp = newVal;\n  }\n\n}\ncustomElements.define('my-element', MyElement);\n```\n\n  ","references":"- [LitElement Properties](https://lit-element.polymer-project.org/guide/properties)\n- [Alligator.io attributes-properties](https://alligator.io/web-components/attributes-properties/)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-properties-2","weblink":"https://codersnack.com/webcomponents-litelement-properties-2/","featured_image_preview":{"id":90,"name":"litelement-icon.png","hash":"285d00e1391c4f73b8ec7ff893b42e9d","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/285d00e1391c4f73b8ec7ff893b42e9d.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:15.512Z","updated_at":"2020-04-14T15:07:15.512Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement Properties 2 (lit label)","created_at":"2022-04-26T08:02:48.814Z","updated_at":"2022-04-26T08:02:48.818Z"},{"id":183,"codersnack":{"id":65,"header":"LitElement Lifecycle 1","created_at":"2020-03-31T19:29:29.965Z","updated_at":"2020-04-14T15:07:00.130Z","explanation":"### Overview\n**LitElement-based components update asynchronously in response to observed property changes**. **Property changes are batched**—if more properties change after an update is requested, but before the update starts, all of the changes are captured in the same update.\n\nAt a high level, the update lifecycle is:\n\n- A property is set.\n- Check whether an update is needed. If an update is needed, request one.\n- Perform the update:\n    Process properties and attributes.\n    Render the element.\n- Resolve a Promise, indicating that the update is complete.\n\n#### LitElement and the browser event loop\n**The browser executes JavaScript code by processing a queue of tasks in the event loop**. In each iteration of the event loop, the browser takes a task from the queue and runs it to completion.\n\nWhen the task completes, before taking the next task from the queue, the browser allocates time to perform work from other sources—including DOM updates, user interactions, and the microtask queue.\n\nBy default, **LitElement updates are requested asynchronously, and queued as microtasks**. This means that Step 3 above (Perform the update) is executed at the end of the next iteration of the event loop.\n\n> You can change this behavior so that Step 3 awaits a Promise before performing the update. See performUpdate for more information.\n\n#### Lifecycle callbacks\nLitElement also inherits the default lifecycle callbacks from the Web Component standard:\n\n- **connectedCallback**: Invoked when a component is added to the document’s DOM.\n- **disconnectedCallback**: Invoked when a component is removed from the document’s DOM.\n- **adoptedCallback**: Invoked when a component is moved to a new document.\n- **attributeChangedCallback**: Invoked when component attribute changes.\n\n> Be aware that adoptedCallback is not polyfilled.\n\n**All lifecycle methods need to call the super method.**\n\n*Example*:\n\n```\nconnectedCallback() {\n  super.connectedCallback()\n\n  console.log('connected')\n}\n```\n\n#### Promises and asynchronous functions\n**LitElement uses *Promise* objects to schedule and respond to element updates**.\n\nUsing *async* and *await* makes it easy to work with *Promises*. For example, you can await the **updateComplete** Promise:\n\n```\n// `async` makes the function return a Promise & lets you use `await`\nasync myFunc(data) {\n  // Set a property, triggering an update\n  this.myProp = data;\n\n  // Wait for the updateComplete promise to resolve\n  await this.updateComplete;\n  // ...do stuff...\n  return 'done';\n}\n```\n\nBecause *async* functions return a *Promise*, you can await them, too:\n\n```\nlet result = await myFunc('stuff');\n// `result` is resolved! You can do something with it\n```\nSee the Web Fundamentals primer on Promises for a more in-depth tutorial.\n\n#### Methods and properties\n**In call order, the methods and properties in the update lifecycle are:**\n\n- **someProperty.hasChanged**\n- **requestUpdate**\n- **performUpdate**\n- **shouldUpdate**\n- **update**\n- **render**\n- **firstUpdated**\n- **updated**\n- **updateComplete**\n\n#### someProperty.hasChanged\n\nAll declared properties have a function, *hasChanged*, which is called whenever the property is set; if *hasChanged* returns true, an update is scheduled.\n\nSee the Properties documentation for information on configuring hasChanged to customize what constitutes a property change.\n\n#### requestUpdate\n\n```\n// Manually start an update\nthis.requestUpdate();\n\n// Call from within a custom property setter\nthis.requestUpdate(propertyName, oldValue);\n```\nParams:\n- propertyName: Name of property to be updated.\n- oldValue: Previous property value.\n\nReturns:\n- Promise: Returns the updateComplete Promise, which resolves on completion of the update.\n\nUpdates?:\n - No: Property changes inside this method will not trigger an element update.\n\nIf *hasChanged* returned true, requestUpdate fires, and the update proceeds.\n\n**To manually start an element update, call requestUpdate with no parameters**.\n\nTo implement a custom property setter that supports property options, pass the property name and its previous value as parameters.\n\n*Example*: Manually start an element update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  constructor() {\n    super();\n\n    // Request an update in response to an event\n    this.addEventListener('load-complete', async (e) => {\n      console.log(e.detail.message);\n      console.log(await this.requestUpdate());\n    });\n  }\n  render() {\n    return html`\n      <button @click=\"${this.fire}\">Fire a \"load-complete\" event</button>\n    `;\n  }\n  fire() {\n    let newMessage = new CustomEvent('load-complete', {\n      detail: { message: 'hello. a load-complete happened.' }\n    });\n    this.dispatchEvent(newMessage);\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*Example*: Call **requestUpdate from a custom property setter**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { \n    return { prop: { type: Number } };\n  }\n\n  set prop(val) {\n    let oldVal = this._prop;\n    this._prop = Math.floor(val);\n    this.requestUpdate('prop', oldVal);\n  }\n\n  get prop() { return this._prop; }\n\n  constructor() {\n    super();\n    this._prop = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop: ${this.prop}</p>\n      <button @click=\"${() =>  { this.prop = Math.random()*10; }}\">\n        change prop\n      </button>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### performUpdate\n```\n/**\n * Implement to override default behavior.\n */\nperformUpdate() { ... }\n```\nReturns: void or Promise: Performs an update.\nUpdates?: No : Property changes inside this method will not trigger an element update.\n\n**By default, performUpdate is scheduled as a *microtask* after the end of the next execution of the browser event loop**. To schedule *performUpdate*, implement it as an asynchronous method that awaits some state before calling *super.performUpdate()*. For example:\n\n```\nasync performUpdate() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n  super.performUpdate();\n}\n```\n\n#### shouldUpdate\n```\n/**\n * Implement to override default behavior.\n */\nshouldUpdate(changedProperties) { ... }\n```\nParams:\n- *changedProperties*: Map. Keys are the names of changed properties; Values are the corresponding previous values.\n\nReturns: Boolean: If true, update proceeds. Default return value is true.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Controls whether an update should proceed**. Implement shouldUpdate to specify which property changes should cause updates. By default, this method always returns true.\n\n*Example*: Customize which property changes should cause updates\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number },\n      prop2: { type: Number }\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 0;\n    this.prop2 = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <button @click=\"${() => this.prop1=this.change()}\">Change prop1</button>\n      <button @click=\"${() => this.prop2=this.change()}\">Change prop2</button>\n    `;\n  }\n\n  /**\n   * Only update element if prop1 changed.\n   */\n  shouldUpdate(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    return changedProperties.has('prop1');\n  }\n\n  change() {\n    return Math.floor(Math.random()*10);\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### update\nParams:\n- changedProperties:Map. Keys are the names of changed properties; Values are the corresponding previous values.\n\nUpdates? : No: Property changes inside this method do not trigger an element update.\n\n**Reflects property values to attributes and calls render to render DOM via lit-html**. Provided here for reference. **You don’t need to override or call this method**.\n\n##### render\n```\n/**\n * Implement to override default behavior.\n */\nrender() { ... }\n```\nReturns: TemplateResult: Must return a lit-html TemplateResult.\nUpdates?: No: Property changes inside this method will not trigger an element update.\n\n**Uses *lit-html* to render the element template**. You must implement render for any component that extends the LitElement base class.\n\n","references":"- [LitElement lifecycle](https://lit-element.polymer-project.org/guide/lifecycle)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-lifecycle","weblink":"https://codersnack.com/webcomponents-litelement-lifecycle/","featured_image_preview":{"id":89,"name":"litelement-icon.png","hash":"4b68f145870a41f2ba23b2775fa2b1b8","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/4b68f145870a41f2ba23b2775fa2b1b8.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:00.148Z","updated_at":"2020-04-14T15:07:00.148Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement LifeCycle 1 (lit label)","created_at":"2022-04-26T08:03:29.790Z","updated_at":"2022-04-26T08:03:29.794Z"},{"id":184,"codersnack":{"id":66,"header":"LitElement Lifecycle 2","created_at":"2020-03-31T19:51:01.653Z","updated_at":"2020-04-14T15:06:42.160Z","explanation":"#### firstUpdated\n```\n/**\n * Implement to override default behavior.\n */\nfirstUpdated(changedProperties) { ... }\n```\nParams: changedProperties: Map. Keys are the names of changed properties; Values are the corresponding previous values.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Called after the element's DOM has been updated the first time, immediately before updated is called**.\n\n> Implement firstUpdated to perform one-time work after the element's template has been created.\n\n*Example*: Focus an input element on first update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      textAreaId: { type: String },\n      startingText: { type: String }\n    };\n  }\n  constructor() {\n    super();\n    this.textAreaId = 'myText';\n    this.startingText = 'Focus me on first update';\n  }\n  render() {\n    return html`\n      <textarea id=\"${this.textAreaId}\">${this.startingText}</textarea>\n    `;\n  }\n  firstUpdated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    const textArea = this.shadowRoot.getElementById(this.textAreaId);\n    textArea.focus();\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### updated\n```\n/**\n * Implement to override default behavior.\n */\nupdated(changedProperties) { ... }\n```\nParams: changedProperties:Map. Keys are the names of changed properties; Values are the corresponding previous values.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Called when the element’s DOM has been updated and rendered**. Implement to perform some task after an update.\n\n**Example**: Focus an element after update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number },\n      prop2: { type: Number }\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 0;\n    this.prop2 = 0;\n  }\n  render() {\n    return html`\n      <style>button:focus { background-color: aliceblue; }</style>\n\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n\n      <button id=\"a\" @click=\"${() => this.prop1=Math.random()}\">prop1</button>\n      <button id=\"b\" @click=\"${() => this.prop2=Math.random()}\">prop2</button>\n    `;\n  }\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    let b = this.shadowRoot.getElementById('b');\n    b.focus();\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### updateComplete\n```\n// Await Promise property.\nawait this.updateComplete;\n```\nType: Promise: Resolves with a Boolean when the element has finished updating.\nResolves: true if there are no more pending updates.false if this update cycle triggered another update.\n\nThe *updateComplete* Promise resolves when the element has finished updating. **Use updateComplete to wait for an update**:\n```\n  await this.updateComplete;\n  // do stuff\n  this.updateComplete.then(() => { /* do stuff */ });\n```\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number }\n    };\n  }\n\n  constructor() {\n    super();\n    this.prop1 = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <button @click=\"${this.changeProp}\">prop1</button>\n    `;\n  }\n\n  async getMoreState() {\n    return;\n  }\n\n  async changeProp() {\n    this.prop1 = Math.random();\n    await Promise.all([this.updateComplete, this.getMoreState()]);\n    console.log('Update complete. Other state completed.');\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Overriding updateComplete\n\nTo await additional state before fulfilling the *updateComplete* promise, override the *_getUpdateComplete* method. For example, it may be useful to await the update of a child element here. First await *super._getUpdateComplete()*, then any subsequent state.\n\n> It’s recommended to override the *_getUpdateComplete* method instead of the *updateComplete* getter to ensure compatibility with users who are using TypeScript’s ES5 output (see TypeScript#338).\n\n```\n  class MyElement extends LitElement {\n    async _getUpdateComplete() {\n      await super._getUpdateComplete();\n      await this._myChild.updateComplete;\n    }\n  }\n```\n### Examples\n#### Control when updates are processed\nImplement **performUpdate**:\n\n```\nasync performUpdate() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve());\n  super.performUpdate();\n}\n```\n\n#### Customize which property changes should cause an update\nImplement **shouldUpdate**:\n\n```\nshouldUpdate(changedProps) {\n  return changedProps.has('prop1');\n}\n```\n\n#### Customize what constitutes a property change\nSpecify *hasChanged* for the property. See the Properties documentation.\n\nManage property changes and updates for object subproperties\n\n> **Mutations** (changes to object subproperties and array items) **are not observable**. Instead, either rewrite the whole object, or call requestUpdate after a mutation.\n\n```\n// Option 1: Rewrite whole object, triggering an update\nthis.prop1 = Object.assign({}, this.prop1, { subProp: 'data' });\n\n// Option 2: Mutate a subproperty, then call requestUpdate\nthis.prop1.subProp = 'data';\nthis.requestUpdate();\n```\n#### Update in response to something that isn’t a property change\nCall **requestUpdate**:\n```\n// Request an update in response to an event\nthis.addEventListener('load-complete', async (e) => {\n  console.log(e.detail.message);\n  console.log(await this.requestUpdate());\n});\n```\n\n#### Request an update regardless of property changes\nCall **requestUpdate()**:\n\n```\nthis.requestUpdate();\n```\n#### Request an update for a specific property\nCall requestUpdate(propName, oldValue):\n\n```\nlet oldValue = this.prop1;\nthis.prop1 = 'new value';\nthis.requestUpdate('prop1', oldValue);\n\n```\n#### Do something after the first update\nImplement **firstUpdated**:\n\n```\nfirstUpdated(changedProps) {\n  console.log(changedProps.get('prop1'));\n}\n```\n\n#### Do something after every update\nImplement updated:\n\n```\nupdated(changedProps) {\n  console.log(changedProps.get('prop1'));\n}\n```\n\n#### Do something when the element next updates\nAwait the updateComplete promise:\n\n```\nawait this.updateComplete;\n// do stuff\nthis.updateComplete.then(() => {\n  // do stuff\n});\n```\n#### Wait for an element to finish updating\nAwait the **updateComplete** promise:\n\n```\nlet done = await updateComplete;\nupdateComplete.then(() => {\n  // finished updating\n});\n```","references":"- [LitElement lifecycle](https://lit-element.polymer-project.org/guide/lifecycle)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-lifecycle-2","weblink":"https://codersnack.com/webcomponents-litelement-lifecycle-2/","featured_image_preview":{"id":88,"name":"litelement-icon.png","hash":"897d28ee02da49f6ab54b64860992121","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/897d28ee02da49f6ab54b64860992121.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:06:42.176Z","updated_at":"2020-04-14T15:06:42.176Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement lifecycle 2 (lit label)","created_at":"2022-04-26T08:04:00.001Z","updated_at":"2022-04-26T08:04:00.007Z"},{"id":185,"codersnack":{"id":86,"header":"LitElement Styles 1","created_at":"2020-08-20T21:31:57.650Z","updated_at":"2020-08-20T21:31:57.650Z","explanation":"This page describes how to add styles to your component.\n\nYour component’s template is rendered to its shadow DOM tree. **The styles you add to your component are automatically scoped to the shadow tree, so they don’t leak out and affect other elements**.\n\n### Add styles to your component\n\nFor optimal performance, define **scoped styles in a static ```styles``` property**.\n\nDefine styles in a tagged template literal, using the **css tag function**:\n\n```\nimport { LitElement, css, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return css`\n      div { color: red; }\n    `;\n  }\n  render() { \n    return html`\n      <div>I'm styled!</div> \n    `;\n  }\n}\n```\n\nThe styles you add to your component are scoped using **shadow DOM**. For a quick overview of shadow DOM styling, see Shadow DOM styling overview.\n\nThe value of the static styles property can be:\n\nA **single** tagged template literal.\n\n```\nstatic get styles() {\n  return css`...`;\n} \n```\nAn **array** of tagged template literals.\n\n```\nstatic get styles() {\n  return [ css`...`, css`...`];\n}\n```\nThe static styles property is usually the best way to add styles to your component, but there are some use cases you can’t handle this way ; for example, linking to an external style sheet. For alternate ways to add styles, see Define scoped styles in the template.\n\n#### Expressions in static styles\n\n**Static styles apply to all instances of a component**. Any expressions in CSS are evaluated once, then reused for all instances.\n\n> To allow for theming or per-instance style customization, use CSS variables and custom properties to create configurable styles.\n\nTo prevent LitElement-based components from evaluating potentially malicious code, **the css tag only allows nested expressions that are themselves css tagged strings or numbers.**\n\n```\nimport { LitElement, html, css } from 'lit-element';\n\nconst mainColor = css`red`;\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return css`\n      div { color: ${mainColor} }\n    `;\n  }\n  render() {\n    return html`<div>Some content in a div</div>`;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\nThis restriction exists to protect applications from security vulnerabilities whereby malicious styles, or even malicious code, can be injected from untrusted sources such as URL parameters or database values.\n\nIf you must use an expression in a css literal that is not itself a css literal, and **you are confident that the expression is from a fully trusted source** such as a constant defined in your own code, then you can wrap the expression with the **unsafeCSS** function:\n\n```\nimport { LitElement, html, css, unsafeCSS } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    const mainColor = 'red';\n\n    return css`\n      div { color: ${unsafeCSS(mainColor)} }\n    `;\n  }\n  render() {\n    return html`<div>Some content in a div</div>`;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n**Only use the unsafeCSS tag with trusted input**. Injecting unsanitized CSS is a security risk. For example, malicious CSS can “phone home” by adding an image URL that points to a third-party server.\n\n#### Inheriting styles\n\nUsing an array of tagged template literals, a component can **inherit the styles from a LitElement superclass,** and add its own styles:\n\n```\nclass MyElement extends SuperElement {\n  static get styles() {\n    return [\n      super.styles,\n      css`...`\n    ];\n  }\n}\n```\n\n#### Sharing styles\n\nYou can share styles between components by **creating a module that exports tagged styles**:\n\n```\nimport { css } from 'lit-element';\n\nexport const buttonStyles = css`\n  .blue-button {\n    color: white;\n    background-color: blue;\n  }\n  .blue-button:disabled {\n    background-color: grey;\n  }`;\n```\n\nYour element can then import the styles and add them to its static styles property:\n\n```\nimport { buttonStyles } from './button-styles.js';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return [\n      buttonStyles,\n      css`\n        :host { display: block;\n          border: 1px solid black;\n        }`\n    ]\n  }\n  ...\n}\n```\nYou can also **import an external style sheet** by adding a ```<link>```  element to your template, but this has a number of limitations. For details, see Import an external stylesheet.\n\n### Shadow DOM styling overview\n\nThis section gives a brief overview of shadow DOM styling.\n\nStyles you add to a component can affect:\n\n- The shadow tree (your component’s rendered template).\n- The component itself.\n- The component’s children.\n\n#### Style the shadow tree\n\nLitElement templates are rendered into a shadow tree by default. Styles scoped to an element’s shadow tree don’t affect the main document or other shadow trees. Similarly, with the exception of inherited CSS properties, **document-level styles don’t affect the contents of a shadow tree**.\n\n**When you use standard CSS selectors, they only match elements in your component’s shadow tree.**\n\n```\nclass MyElement extends LitElement {\n  static get styles() {\n    // Write styles in standard CSS\n    return css`\n      * { color: red; }\n      p { font-family: sans-serif; }\n      .myclass { margin: 100px; }\n      #main { padding: 30px; }\n      h1 { font-size: 4em; }\n    `;\n  }\n  render() {\n    return html`\n      <p>Hello World</p>\n      <p class=\"myclass\">Hello World</p>\n      <p id=\"main\">Hello World</p>\n      <h1>Hello World</h1>\n    `;\n  }\n}\n```\n\n#### Style the component itself\n\nYou can style the component itself using special ```:host selectors```. (The element that owns, or “hosts” a shadow tree is called the host element.)\n\nTo create default styles for the host element, use the ```:host``` CSS **pseudo-class** and ```:host()``` CSS **pseudo-class function**.\n\n```:host``` **selects the host element**.\n\n```:host(selector)``` selects the host element, but **only if the host element matches selector**.\n\n```\nstatic get styles() {\n  return css`\n    /* Selects the host element */\n    :host { \n      display: block; \n    }\n\n    /* Selects the host element if it is hidden */\n    :host([hidden]) { \n      display: none; \n    }\n  `;\n}\n```\nNote that the host element can be affected by styles from outside the shadow tree, as well, so you should consider the styles **you set in :host and :host() rules as default styles that can be overridden by the user**. For example:\n\n```\nmy-element {\n  display: inline-block;\n}\n```\n\n#### Style the component’s children\n\nYour component may accept children (like a ```<ul>``` element can have ```<li>``` children). To render children, **your template needs to include one or more ```<slot>``` elements**, as described in Render children with the slot element.\n\nThe ```<slot>``` element acts as a **placeholder in a shadow tree where the host element’s children are displayed**. For example:\n\n```\nclass MyElement extends LitElement {\n  render() {\n    return html`<slot></slot>`;\n  }\n}\n<my-element><p>Slotted content</p></my-element>\n```\n\nUse the ```::slotted()``` **CSS pseudo-element** to select children that are included in your template via ```<slot>```s.\n\n```::slotted(*)``` matches all slotted elements.\n\n```::slotted(p)``` matches slotted paragraphs.\n\n```p ::slotted(*)``` matches slotted elements where the <slot> is a descendant of a paragraph element.\n\n```\n<p>\n  <slot></slot>\n</p>\n```\n```\nimport { LitElement, html, css } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return css`\n      ::slotted(*) { font-family: Roboto; }\n      ::slotted(p) { color: blue; }\n      div ::slotted(*) { color: red; }\n    `;\n  }\n  render() {\n    return html`\n      <slot></slot>\n      <div><slot name=\"hi\"></slot></div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\nNote that only direct slotted children can be styled with ```::slotted()```.\n\n```\n<my-element>\n  <div>Stylable with ::slotted()</div>\n</my-element>\n\n<my-element>\n  <div><p>Not stylable with ::slotted()</p></div>\n</my-element>\n```\nAlso, **children can be styled from outside the shadow tree**, so you should regard your ```::slotted()``` **styles as default styles that can be overridden**.\n\n```\nmy-element div {\n  // Outside style targetting a slotted child can override ::slotted() styles\n}\n```\nWatch out for limitations in the Shady CSS polyfill around slotted content! See the Shady CSS limitations for details on how to use the ```::slotted()``` syntax in a polyfill-friendly way.\n\n#### Configurable styles with custom properties\n\n**Static styles are evaluated once per class. Use CSS variables and custom properties to make styles that can be configured at runtime**:\n\n```\nstatic get styles() {\n  return css`\n    :host { color: var(--themeColor); }\n  `;\n} \n<style>\n  html { \n    --themeColor: #123456;\n  }\n</style>\n<my-element></my-element>\n```\nSee the section on CSS custom properties for more information.\n\n","references":"- [LitElement styles](https://lit-element.polymer-project.org/guide/styles)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-styles","weblink":"https://codersnack.com/webcomponents-litelement-styles/","featured_image_preview":{"id":117,"name":"litelement-icon.png","hash":"605483703faa4a01b95975da4c744050","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/605483703faa4a01b95975da4c744050.png","provider":"local","provider_metadata":null,"created_at":"2020-08-20T21:31:57.669Z","updated_at":"2020-08-20T21:31:57.669Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement styles 1 (lit label)","created_at":"2022-04-26T08:04:31.755Z","updated_at":"2022-04-26T08:04:31.759Z"},{"id":186,"codersnack":{"id":87,"header":"LitElement Styles 2","created_at":"2020-08-21T14:02:13.403Z","updated_at":"2020-08-21T14:02:13.403Z","explanation":"### Define scoped styles in the template\n\n> We recommend using static styles for optimal performance. However, sometimes you may want to define styles in the LitElement template. \n\nThere are two ways to add scoped styles in the template:\n\n- Add styles using a ```<style>``` element.\n- Add styles using an **external style sheet**.\n\nEach of these techniques has its own set of **advantages and drawbacks**.\n\n#### In a style element\n\nWe recommend using static styles for optimal performance. However, **static styles are evaluated once per class. Sometimes, you might need to evaluate styles per instance.**\n\nWe recommend using CSS properties to create customizable styles. However, you can also include ```<style>``` elements in a LitElement template. These are **updated per instance**.\n\n```\nrender() {\n  return html`\n    <style>\n      /* updated per instance */\n    </style>\n    <div>template content</div>\n  `;\n}\n```\n\n### Expressions and style elements\n\nThe most intuitive way to evaluate per-instance styles has some important limitations and performance issues. We consider the example below to be an **anti-pattern**:\n\n```\n// Anti-pattern!\nrender() {\n  return html`\n    <style>\n      :host {\n        /* Warning: this approach has limitations & performance issues! */\n        color: ${myColor}\n      } \n    </style>\n    <div>template content</div>\n  `;\n}\n```\n> Expressions inside a ```<style>``` element won’t update per instance in ShadyCSS, due to limitations of the ShadyCSS polyfill. See the ShadyCSS readme for more information.\n\nAdditionally, evaluating an expression inside a ```<style>``` element is inefficient. When any text inside a ```<style>``` element changes, the **browser must re-parse the whole** ```<style>``` element, resulting in unnecessary work.\n\nIf you need to evaluate expressions inside a ```<style>``` element, use the following strategy to avoid creating performance problems:\n\n- **Separate styles that require per-instance evaluation from those that don’t**.\n\n- Evaluate per-instance CSS properties by **creating an expression that captures that property inside a complete** ```<style>``` block. Include it in your template.\n\nExample\n\n```\nimport { LitElement, html } from 'lit-element';\n\nconst perClassStyle = html`\n  <style>\n    :host {\n      display: block;\n      font-family: Roboto;\n      font-size: 14px; \n    }\n  </style>\n`;\n\nconst blueText = html`\n  <style> :host { color: blue; } </style>\n`;\n\nconst redText = html`\n  <style> :host { color: red; } </style>\n`;\n\nclass MyElement extends LitElement {\n  constructor() {\n    super();\n    this.perInstanceStyle = redText;\n  }\n  render() {\n    return html`\n      ${perClassStyle}\n      ${this.perInstanceStyle}\n      <div>Hello World</div>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Import an external stylesheet\n\nWe recommend placing your styles in a static styles property for optimal performance. However, **you can include an external style sheet in your template with a** ```<link>```:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`\n      <link rel=\"stylesheet\" href=\"./app-styles.css\">\n      <button>a button</button>\n      <div>a div</div>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\nThere are some important caveats though:\n\n- The ShadyCSS polyfill doesn’t support external style sheets.\n\n- External styles can cause a **flash-of-unstyled-content (FOUC) ** while they load.\n\n- The URL in the **href attribute is relative to the main document**. This is okay if you’re building an app and your asset URLs are well-known, but **avoid using external style sheets when building a reusable element**.\n\n### Dynamic classes and styles\n\n**One way to make styles dynamic is to add bindings to the class or style attributes in your template.**\n\nThe **lit-html** library offers two **directives**, **classMap** and **styleMap**, to conveniently **apply classes and styles in HTML templates**.\n\nFor more information on these and other lit-html directives, see the documentation on lit-html built-in directives.\n\nTo use styleMap and/or classMap:\n\n- Import classMap and/or styleMap:\n\n```\nimport { classMap } from 'lit-html/directives/class-map';\nimport { styleMap } from 'lit-html/directives/style-map';\n```\n\n- Use **classMap** and/or **styleMap** in your element template:\n\n```\nconstructor() {\n  super();\n  this.classes = { mydiv: true, someclass: true };\n  this.styles = { color: 'green', fontFamily: 'Roboto' };\n}\nrender() {\n  return html`\n    <div class=${classMap(this.classes)} style=${styleMap(this.styles)}>\n      Some content\n    </div>\n  `;\n}\n```\n\n#### classMap syntax\n\nclassMap applies a set of classes to an HTML element:\n\n```\n<div class=${classMap({alert:true,info:true})}>Content.</div>\n<!-- Equivalent: <div class=\"alert info\">Content.</div> -->\n```\n\n#### styleMap syntax\n\nstyleMap applies a set of CSS rules to an HTML element:\n\n```\n<button style=${styleMap({\n  backgroundColor: 'blue',\n  border: '1px solid black'\n})}>A button</button>\n\n<!-- Equivalent: \n  <button style=\"\n    background-color:blue;\n    border: 1px solid black;\n  \">A button</button>\n-->\n```\n\nTo refer to hyphenated properties such as ```font-family```, use the camelCase equivalent (**fontFamily**) or place the hyphenated property name in quotes ('font-family').\n\nTo refer to custom CSS properties such as ```--custom-color```, place the whole property name in quotes ('--custom-color').\n\n**Inline style or CSS\t|     styleMap equivalent**\n\nbackground-color: blue; | backgroundColor: 'blue' or 'background-color': 'blue'\n\nfont-family: Roboto, Arial, sans-serif;\t|    fontFamily: 'Roboto, Arial, sans-serif' or 'font-family': 'Roboto, Arial, sans-serif'\n```--custom-color: #FFFABC;```\t|   \t'--custom-color': '#FFFABC;'\n```--otherCustomColor: #FFFABC;```\t|   \t'--otherCustomColor': '#FFFABC;'\n```color: var(--customprop, blue);```\t|   \tcolor: 'var(--customprop, blue)'\n\nExamples\n\n*Inline style syntax:*\n\n```\n<div style=\"\n  background-color:blue;\n  font-family:Roboto;\n  --custom-color:#e26dd2;\n  --otherCustomColor:#77e26d;\">\n</div>\n```\n*Equivalent CSS syntax:*\n\n```\ndiv {\n  background-color: blue;\n  font-family: Roboto;\n  --custom-color: #e26dd2;\n  --otherCustomColor: #77e26d;\n}\n```\n\n*Equivalent styleMap syntax:*\n\n```\nhtml`\n  <div style=${styleMap({\n    'background-color': 'blue',\n    fontFamily: 'Roboto',\n    '--custom-color': '#e26dd2',\n    '--otherCustomColor': '#77e26d'\n  })}></div>\n`\n```\n\n### Theming\n\nUse **CSS inheritance to propagate style information to LitElement** components and their rendered templates.\n\n```\n<style>\n  html {\n    --themeColor: #123456;\n    font-family: Roboto;\n  }\n</style>\n\n<!-- host inherits `--themeColor` and `font-family` and\n     passes these properties to its rendered template -->\n<my-element></my-element>\n```\n\n**Use CSS variables and custom properties to configure styles per-instance**.\n\n```\n<style>\n  html {\n    --my-element-background-color: /* some color */;\n  }\n  .stuff {\n    --my-element-background-color: /* some other color */;\n  }\n</style>\n\n<my-element></my-element>\n\n<my-element class=\"stuff\"></my-element>\n\n// MyElement's static styles\nstatic get styles() {\n  return css`\n    :host {\n      background-color: var(--my-element-background-color);\n    }\n  `;\n}\n```\n\n#### CSS inheritance\n\nCSS inheritance lets parent and host elements propagate certain CSS properties to their descendents.\n\n**Not all CSS properties inherit. Inherited CSS properties include**:\n\n- color\n- font-family and other font-* properties\n- All CSS custom properties (--*)\n\nSee CSS Inheritance on MDN for more information.\n\nYou can use CSS inheritance to set styles on an ancestor element that are inherited by its descendents:\n\n```\n<style>\nhtml { \n  font-family: Roboto;\n}\n</style>\n\n<div>\n  <p>Uses Roboto</p>\n</div>\n```\nSimilarly, **host elements pass down inheritable CSS properties to their shadow trees**.\n\nYou can use the **host element's type selector to style it**:\n\n```\n<style>\n  my-element { font-family: Roboto; }\n</style>\n\n<my-element></my-element>\n\nclass MyElement extends LitElement {\n  render() { \n    return html`<p>Uses Roboto</p>`; \n  }\n}\n```\n\nYou can also use the ```:host``` **CSS pseudo-class** to **style the host from inside** its own template:\n\n```\nstatic get styles() {\n  return css`\n    :host {\n      font-family: Roboto;\n    }\n  `;\n}\nrender() {\n  return html`\n    <p>Uses Roboto</p>\n  `;\n}\n```\n\n> Type selectors have higher specificity than ```:host```.\n\nAn element type selector has higher specificity than the ```:host``` pseudo-class selector. Styles set for a custom element tag will override styles set with :host and :host():\n\n```\n<style>\n  my-element { font-family: Courier; }\n</style>\n\n<my-element></my-element>\n\nclass MyElement extends LitElement {\n  static get styles() { \n    return css`:host { font-family: Roboto; }`\n  }\n  render() {\n    return html`<p>Will use courier</p>`;\n  }\n}\n```\n\n#### CSS custom properties\n\n**All CSS custom properties (--custom-property-name) inherit**. You can use this to make your component’s styles configurable from outside.\n\nThe following component sets its background color to a CSS variable. The CSS variable uses the value of --my-background if it’s available, and otherwise defaults to yellow:\n\n```\nclass MyElement extends LitElement {\n  static get styles() { \n    return css`\n      :host { \n        background-color: var(--my-background, yellow); \n      }\n    `;\n  }\n  render() {\n    return html`<p>Hello world</p>`;\n  }\n}\n```\n\nUsers of this component can set the value of --my-background, using the my-element tag as a CSS selector:\n\n```\n<style>\n  my-element {\n    --my-background: rgb(67, 156, 144);\n  }\n</style>\n\n<my-element></my-element>\n```\n```--my-background``` is configurable per instance of my-element:\n\n```\n<style>\n  my-element {\n    --my-background: rgb(67, 156, 144);\n  }\n  my-element.stuff {\n    --my-background: #111111;\n  }\n</style>\n<my-element></my-element>\n<my-element class=\"stuff\"></my-element>\n```\n\nIf a component user has an existing app theme, they can easily set the host’s configurable properties to use theme properties:\n\n```\n<html>\n  <head>\n    <title>lit-element code sample</title>\n    <script type=\"module\" src=\"./my-element.js\"></script>\n    <style>\n      html { --themeColor1: rgb(67, 156, 144); }\n      my-element {\n        --myBackground: var(--themeColor1);\n        --myColor: rgb(156, 67, 152);\n      }\n    </style>\n  </head>\n  <body>\n    <my-element></my-element>\n  </body>\n</html>\n```\nSee CSS Custom Properties on MDN for more information.\n\n*A simple example theme*\n**index.html**\n\n```\n<html>\n  <head>\n    <script type=\"module\" src=\"./my-element.js\"></script>\n    <title>lit-element code sample</title>\n    <style>\n      html {\n        --theme-primary: green;\n        --theme-secondary: aliceblue;\n        --theme-warning: red;\n        --theme-font-family: Roboto;\n      }\n      my-element { \n        --my-element-text-color: var(--theme-primary); \n        --my-element-background-color: var(--theme-secondary); \n        --my-element-font-family: var(--theme-font-family);\n      } \n      .warning {\n        --my-element-text-color: var(--theme-warning); \n      }\n    </style>\n  </head>\n  <body>\n    <my-element></my-element>\n    <my-element class=\"warning\"></my-element>\n  </body>\n</html>\n```\n\n**my-element.js**\n\n```\nimport { LitElement, html, css } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() { \n    return css`\n      :host { \n        display: block;\n        color: var(--my-element-text-color, black); \n        background: var(--my-element-background-color, white);  \n        font-family: var(--my-element-font-family, Roboto);\n      }\n      :host([hidden]) {\n        display: none;\n      }\n    `;\n  }\n  render() {\n    return html`<div>Hello World</div>`;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```","references":"- [LitElement styles](https://lit-element.polymer-project.org/guide/styles)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-styles-ii","weblink":"https://codersnack.com/webcomponents-litelement-styles-ii/","featured_image_preview":{"id":118,"name":"litelement-icon.png","hash":"140e68e8867c4ae288bd9d4f4ce7e29f","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/140e68e8867c4ae288bd9d4f4ce7e29f.png","provider":"local","provider_metadata":null,"created_at":"2020-08-21T14:02:13.443Z","updated_at":"2020-08-21T14:02:13.443Z"}},"codersnacks_category":{"id":27,"header":"LitElement","description":"LitElement is a simple base class for creating fast, lightweight web components that work in any web page with any framework.","snacks_by_cat_json_filename":"litelement.snacks.json","key":"litelement","image_url":"https://codersnack.com/assets/images/litelement-icon.png","created_at":"2022-04-26T07:58:27.332Z","updated_at":"2022-04-26T07:58:27.332Z","image_preview":{"id":214,"name":"litelement-icon.png","hash":"0dcf14da63e2469babdd9296e762f02c","sha256":"rhsnGuEg_XGj2QfOnnJ5nvth-FuYFXeoATh7iP-oQGs","ext":".png","mime":"image/png","size":5.65,"url":"/uploads/0dcf14da63e2469babdd9296e762f02c.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:58:27.347Z","updated_at":"2022-04-26T07:58:27.347Z"}},"title":"LitElement styles 2 - lit label","created_at":"2022-04-26T08:05:01.068Z","updated_at":"2022-04-26T08:05:01.070Z"}]