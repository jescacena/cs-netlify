[{"id":50,"codersnack":{"id":51,"header":"How the browser renders a web page? (I)","created_at":"2020-02-23T16:58:43.010Z","updated_at":"2020-02-23T16:58:43.010Z","explanation":"### Document Object Model (DOM)\n\nWhen the browser reads HTML code, whenever it encounters an HTML element like html, body, div etc., **it creates a JavaScript object called as *Node*. **Eventually, **all HTML elements will be converted to JavaScript objects**. Since every different HTML element has different properties, the Node object will be created from different classes (constructor functions).\n\nFor example, the Node object for the div element is created from **HTMLDivElement** which inherits Node class. The browser comes with built-in classes like HTMLDivElement, HTMLScriptElement, Node etc.\n\nAfter the browser has created Nodes from the HTML document, it has to **create a tree-like structure of these node objects**. Since our HTML element will be nested inside each other, **browser needs to replicate that but using Node objects it has previously created**. This will help the browser efficiently render and manage the webpage through its lifecycle.\n\n![text](https://codersnack.com/assets/images/web-performance-dom-tree.png)\n\n> A DOM node doesn’t always have to be an HTML element. When the browser creates a DOM tree, it also saved things like comments, attributes, text as separate nodes in the tree. But for the simplicity, we will just consider DOM nodes for HTML elements AKA DOM element. Here is the list of all [DOM node types](https://www.w3schools.com/jsref/prop_node_nodetype.asp)\n\n**JavaScript doesn’t understand what DOM is**, it is not part of the JavaScript specifications. **DOM is a high-level Web API provided by the browser** to efficiently render a webpage and expose it publically for the developer to dynamically manipulate DOM elements for various purposes.\n\n> Using DOM API, developers can add or remove HTML elements, change its appearance or bind event listeners. Using DOM API, HTML elements can be created or cloned in memory and maniuplated without affecting the rendered DOM tree. This gives developers the ability to construct highly dynamic web page with rich user experience.\n\n### CSS Object Model (CSSOM)\n\nAfter constructing the DOM, **the browser reads CSS** from all the sources (external, embedded, inline, user-agent, etc.) and **construct a *CSSOM***. CSSOM stands for CSS Object Model which is a Tree Like structure just like DOM.\n\n**Each node in this tree contains CSS style information for that particular DOM element.** CSSOM, however, does not contain DOM elements which can't be printed on the screen like `<meta>`, `<script>`, `<title>` etc.\n\nAs we know, **most of the browser comes with its own stylesheet which is called as *user agent stylesheet***, the browser first computes final CSS properties for DOM element by overriding user agent styles with CSS provided by the developer properties (using specificity rules) and then construct a node.\n\nEven if a CSS property for a particular HTML element isn’t defined by either the developer or the browser, its value is set to the default **value of that property as specified by W3C CSS standard**. While selecting the default value of a CSS property, some rules of inheritance are used if a property qualifies for the inheritance as mentioned in the W3C documentation.\n\nFor example, *color* and *font-size* among others **inherits the value of the parent if these properties are missing an HTML element**. So you can imagine having these properties on an HTML element and all its children inheriting it. This is called as cascading of styles and **that’s why CSS is called as Cascading Style Sheet.** This is the very reason why the browser constructs a CSSOM, a tree-like structure to compute styles based on CSS cascading rules.\n\n![text](https://codersnack.com/assets/images/web-performance-cssom-tree.png)\n\n","references":"- [Uday Hiwarale - How the Browser renders a web page?](https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969)","featured_image_url":"https://codersnack.com/assets/images/web-performance.png","slug":"web-performance-how-browser-renders","weblink":"https://codersnack.com/web-performance-how-browser-renders/","featured_image_preview":{"id":66,"name":"web-performance.png","hash":"fdf43fa458bf45b2bace1222ffb74f41","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/fdf43fa458bf45b2bace1222ffb74f41.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:58:43.019Z","updated_at":"2020-02-23T16:58:43.019Z"}},"codersnacks_category":{"id":11,"header":"Web Performance","description":"Performance is about retaining users","snacks_by_cat_json_filename":"web-performance.snacks.json","key":"web-performance","image_url":"https://codersnack.com/assets/images/web-performance.png","created_at":"2020-02-23T16:32:16.566Z","updated_at":"2020-02-23T16:32:16.566Z","image_preview":{"id":63,"name":"web-performance.png","hash":"f82923fcbd6240f195cee5cae6d16a3c","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/f82923fcbd6240f195cee5cae6d16a3c.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:32:16.584Z","updated_at":"2020-02-23T16:32:16.584Z"}},"title":"Web performance browser renders I","created_at":"2020-02-23T16:59:18.250Z","updated_at":"2020-02-23T16:59:18.253Z"},{"id":51,"codersnack":{"id":52,"header":"How the browser renders a web page? (II)","created_at":"2020-02-23T21:37:29.712Z","updated_at":"2020-02-23T21:37:29.712Z","explanation":"### Render Tree\n\n**Render-Tree is a tree-like structure constructed by combining DOM and CSSOM trees**. The browser has to calculate the layout of each visible element and paint them on the screen, for that browser uses Render-Tree. Hence, unless Render-Tree isn’t constructed, nothing will get printed on the screen.\n\nAs Render-Tree is a low-level representation of what will eventually get painted on the screen, **it won’t contain nodes that do not hold any area in the pixel matrix**. For example, display:none elements have dimensions of 0px X 0px hence they won't be present in Render-Tree.\n\n![Web performance DOM + CSSOM tree](https://codersnack.com/assets/images/web-performance-dom-cssom.png)\n\nAs you can see from the above diagram, **Render-Tree combines DOM and CSSOM to generate a tree-like structure containing only the elements which will be printed on the screen**.\n\nSince in CSSOM, p element inside div has *display:none* property set on it, it and its children won't be present in Render-Tree, since it occupies no space on the screen. However, if you have elements with *visibility:hidden* or opacity:0, they will occupy space on the screen hence they will be present in the Render-Tree.\n\nUnlike DOM API which gives access to the DOM elements in the DOM tree constructed by the browser, **CSSOM is kept hidden from the user. But since browser combines DOM and CSSOM to form the Render Tree, browser exposes CSSOM node of a DOM element by providing high-level API on the DOM element itself**. This enables the developer to access or change the CSS properties of a CSSOM node.\n\n### Rendering Sequence\n\nWhen a web page is loaded, the browser first reads the TEXT HTML and constructs DOM Tree from it. Then it processes the CSS whether that is inline, embedded or external CSS and constructs the CSSOM Tree from it. After these trees are constructed, then it constructs the Render-Tree from it. Once the Render-Tree is constructed, then the browser starts the printing individual elements on the screen.\n\n#### Layout operation\n\n**The first browser creates the layout of each individual Render-Tree node**. The layout consists of the size of each node in pixels and where (position) it will be printed on the screen.\n\n> This process is also called as **reflow** or **browser reflow** and it can also occur when you scroll, resize the window or manipulate DOM elements. Here is a list of events which can trigger reflow of the elements.\n\n#### Paint operation\n\nUntil now we have a list of geometries that needs be printed on the screen. Since elements (or a sub-tree) in the Render-Tree can overlap each other and they can have properties that make them frequently change the look, position or geometry, the browser creates a layer for it.\n\n**Creating layers helps browser efficiently perform painting operations** throughout the lifecycle of a web page for example while scrolling or resizing. Having layers also help browser correctly draw elements in the order (along the z-axis) they were intended by the developer.\n\nNow that we have layers, we can combine them and draw it on the screen. But the browser does not draw all the layers in a single image. Each layer is drawn separately first.\n\nInside each layer, the browser fills the individual pixels with whatever visible property of the element is like border, background colour, shadow, text, etc. This process is also called as **rasterization**. To increase performance, the browser may use different threads to perform rasterization.\n\n**The analogy of layers in Photoshop can be applied to how the browser renders a web page as well**. You can visualize different layers on a web page from Chrome DevTools. Open DevTools and from more tools options, select **Layers**. You can also visualize layer borders from **Rendering panel**.\n\n**Rasterization is normally done in CPU which makes it slow and expensive but we now have new techniques to do it in GPU for performance enhancement**. \n\n#### Compositing operation\n\nUntil now, we haven’t drawn a single pixel on the screen. What we have are different layers (bitmap images) which should be drawn on the screen in a specific order. In compositing operations, these layers are sent to GPU to finally draw it on the screen.\nSending entire layers to draw is clearly inefficient because this has to happen every time there is a reflow or repaint. Hence, **a layer is broken down into different tiles which then will be drawn on the screen**. You can also visualize these tiles in **Chrome DevTool Rendering panel**.\n\nFrom the above information, we can construct a sequence of events, the browser goes through when a web page is loaded for the first time.\n\n![Web performance Critical Rendering path](https://codersnack.com/assets/images/critical-rendering-path.png)\n\n\nThese sequence of event is also called a **critical rendering path**.\n\n\n","references":"- [Uday Hiwarale - How the Browser renders a web page?](https://itnext.io/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969)","featured_image_url":"https://codersnack.com/assets/images/web-performance.png","slug":"web-performance-how-browser-renders-2","weblink":"https://codersnack.com/web-performance-how-browser-renders-2/","featured_image_preview":{"id":67,"name":"web-performance.png","hash":"65a7a1e6633a4467bb4ccfdee763ce22","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/65a7a1e6633a4467bb4ccfdee763ce22.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T21:37:29.724Z","updated_at":"2020-02-23T21:37:29.724Z"}},"codersnacks_category":{"id":11,"header":"Web Performance","description":"Performance is about retaining users","snacks_by_cat_json_filename":"web-performance.snacks.json","key":"web-performance","image_url":"https://codersnack.com/assets/images/web-performance.png","created_at":"2020-02-23T16:32:16.566Z","updated_at":"2020-02-23T16:32:16.566Z","image_preview":{"id":63,"name":"web-performance.png","hash":"f82923fcbd6240f195cee5cae6d16a3c","sha256":"Sz4sG2UNza50vT8uu2L4z1NcmEVuIOXpLPqOMUblIG8","ext":".png","mime":"image/png","size":11.88,"url":"/uploads/f82923fcbd6240f195cee5cae6d16a3c.png","provider":"local","provider_metadata":null,"created_at":"2020-02-23T16:32:16.584Z","updated_at":"2020-02-23T16:32:16.584Z"}},"title":"Web performance renders II","created_at":"2020-02-23T21:45:33.826Z","updated_at":"2020-02-23T21:45:33.832Z"}]