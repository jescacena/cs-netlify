[{"id":51,"codersnack":{"id":54,"header":"Introduction to Web Components","created_at":"2020-02-29T11:06:51.993Z","updated_at":"2020-02-29T21:31:43.928Z","explanation":"### What are Web Components, anyway?\n\nWeb Components consist of **three separate technologies that are used together:**\n\n- **Custom Elements**. Quite simply, these are fully-valid HTML elements with custom templates, behaviors and tag names (e.g. ```<one-dialog>```) made with a set of JavaScript APIs. Custom Elements are defined in the *HTML Living Standard specification*.\n- **Shadow DOM**. Capable of isolating CSS and JavaScript, almost like an ```<iframe>```. This is defined in the *Living Standard DOM specification*.\n- **HTML templates**. User-defined templates in HTML that aren't rendered until called upon. The ```<template>``` tag is defined in the *HTML Living Standard specification*.\n\nThese are what make up the *Web Components specification*.\n\n> **HTML Modules** is likely to be the fourth technology in the stack, but it has yet to be implemented in any of the big four browsers. The Chrome team has announced it an intent to implement them in a future release.\n\n**Web Components are generally available in all of the major browsers** with the exception of Microsoft Edge and Internet Explorer 11, but polyfills exist to fill in those gaps.\n\nReferring to any of these as Web Components is technically accurate because the term itself is a bit overloaded. As a result, each of the technologies can be used independently or combined with any of the others. In other words, they are not mutually exclusive.\n\n### Custom elements\nAs the name implies, **custom elements are HTML elements,** like ```<div>```, ```<section>``` or ```<article>```, but something **we can name ourselves that are defined via a browser API**. Custom elements are just like those standard HTML elements — names in angle brackets — except **they always have a dash in them**, like ```<news-slider>``` or ```<bacon-cheeseburger>```. Going forward, browser vendors have committed not to create new built-in elements containing a dash in their names to prevent conflicts.\n\nCustom elements contain their own semantics, behaviors, markup and can be shared across frameworks and browsers.\n```\nclass MyComponent extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `<h1>Hello world</h1>`;\n  }\n}\ncustomElements.define('my-component', MyComponent);\n```\n![Custom Elements](https://codersnack.com/assets/images/web-components-custom-elements.png)\n\nIn this example, we define ```<my-component>```, our very own HTML element. Admittedly, it doesn’t do much, however this is the basic building block of a custom element. **All custom elements must in some way extend an HTMLElement in order to be registered with the browser.**\n\n**Custom elements exist without third-party frameworks** and the browser vendors are dedicated to the continued backward compatibility of the spec, all but guaranteeing that components written according to the specifications will not suffer from breaking API changes. What’s more, **these components can generally be used out-of-the-box with today’s most popular frameworks**, including Angular, React, Vue, and others with minimal effort.\n\n### Shadow DOM\n**The shadow DOM is an encapsulated version of the DOM**. This allows authors to effectively isolate DOM fragments from one another, including anything that could be used as a CSS selector and the styles associated with them. Generally, any content inside of the document's scope is referred to as the light DOM, and anything inside a shadow root is referred to as the shadow DOM.\n\nImagine the following scenario:\n```\n<div>\n  <div id=\"example\">\n    <!-- Pseudo-code used to designate a shadow root -->\n    <#shadow-root>\n      <style>\n      button {\n        background: tomato;\n        color: white;\n      }\n      </style>\n      <button id=\"button\">This will use the CSS background tomato</button>\n    </#shadow-root>\n  </div>\n  <button id=\"button\">Not tomato</button>\n</div>\n```\nAside from the pseudo-code of ```<#shadow-root>``` (which is used here to demarcate the shadow boundary which has no HTML element), the HTML is fully valid. To attach a shadow root to the node above, we would run something like:\n\n```\nconst shadowRoot = document.getElementById('example').attachShadow({ mode: 'open' });\nshadowRoot.innerHTML = `<style>\nbutton {\n  color: tomato;\n}\n</style>\n<button id=\"button\">This will use the CSS color tomato <slot></slot></button>`;\n```\nA shadow root can also include content from its containing document by using the ```<slot>``` element. **Using a slot will drop user content from the outer document at a designated spot in your shadow root**.\n\n### HTML templates\nThe aptly-named HTML ```<template>```  element allows us to stamp out **re-usable templates of code inside a normal HTML flow that won't be immediately rendered, but can be used at a later time**.\n\n```\n<template id=\"book-template\">\n  <li><span class=\"title\"></span> &mdash; <span class=\"author\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\nThe example above wouldn’t render any content until a script has consumed the template, instantiated the code and told the browser what to do with it.\n\n```\nconst fragment = document.getElementById('book-template');\nconst books = [\n  { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald' },\n  { title: 'A Farewell to Arms', author: 'Ernest Hemingway' },\n  { title: 'Catch 22', author: 'Joseph Heller' }\n];\n\nbooks.forEach(book => {\n  // Create an instance of the template content\n  const instance = document.importNode(fragment.content, true);\n  // Add relevant content to the template\n  instance.querySelector('.title').innerHTML = book.title;\n  instance.querySelector('.author').innerHTML = book.author;\n  // Append the instance ot the DOM\n  document.getElementById('books').appendChild(instance);\n});\n```\n\nNotice that this example creates a template (```<template id=\"book-template\">```) without any other Web Components technology, illustrating again that **the three technologies in the stack can be used independently or collectively**.\n\nOstensibly, the consumer of a service that utilizes the template API could write a template of any shape or structure that could be created at a later time. Another page on a site might use the same service, but structure the template this way:\n\n```\n<template id=\"book-template\">\n  <li><span class=\"author\"></span>'s classic novel <span class=\"title\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\n","references":"- [CSS trick - Calleb Williams - Introduction to web components](https://css-tricks.com/an-introduction-to-web-components/)\n- [HTML Living Standard specification](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements)\n- [Living Standard DOM specification](https://dom.spec.whatwg.org/#shadow-trees)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-introduction","weblink":"https://codersnack.com/web-components-introduction/","featured_image_preview":{"id":70,"name":"web-components.png","hash":"bb73ea6081f440319172079b80849d32","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bb73ea6081f440319172079b80849d32.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T11:06:52.003Z","updated_at":"2020-02-29T11:06:52.003Z"}},"codersnacks_quiz":{"id":51,"question":"Web Components consist of three separate technologies that are used together ...","response_valid":"Customs Elements, Shadow DOM, HTML Templates","response_invalid1":"Custom Elements, DOM API manipulation, CSS","response_invalid2":"Shadow DOM, HTML5 elements, CSS3","created_at":"2020-02-29T21:34:48.550Z","updated_at":"2020-02-29T21:34:48.550Z"},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web components introduction three technologies","created_at":"2020-02-29T21:35:45.119Z","updated_at":"2020-02-29T21:35:45.122Z"},{"id":54,"codersnack":{"id":59,"header":"LitElement and lit-html Introduction","created_at":"2020-03-30T13:59:50.431Z","updated_at":"2020-04-14T15:08:28.972Z","explanation":"### What is LitElement?\n\n**LitElement** is a **simple base class for creating fast, lightweight web components** that work in any web page with any framework.\n\n**LitElement uses lit-html to render into shadow DOM**, and **adds API to manage properties and attributes**. *Properties are observed by default, and elements update asynchronously when their properties change*.\n\n### Setup\n**You need npm and Node.js** to work with LitElement.\n\n**LitElement uses JavaScript modules to import dependencies** by their npm package names. Since web browsers need to know a file's full URL to import it, your local development server needs to serve full, transformed URL paths to your web browser.\n\n**To deploy an optimized build** that works on your target browsers, you’ll also **need a build toolset** that can handle this transform, along with any bundling.\n\n**One option is Polymer CLI**, which includes a development server that converts module names to paths on the fly; and a configurable build tool that packages your code for deployment.\n\nTo install Polymer CLI with npm:\n```\nnpm install -g polymer-cli\n```\nTo serve a LitElement project locally:\n\n```\npolymer serve\n```\nSee the Polymer CLI documentation for more information on configuring these tools.\n\n\n### Create a LitElement component\nTo create a new class based on LitElement:\n\nIn your project folder, install the lit-element package from npm:\n\n```\nnpm install lit-element\n```\n\nWrite your new element:\n\n- Import the LitElement base class and the html helper function.\n- Create a new class that extends the LitElement base class.\n- Implement render to define a template for your web component.\n- Register your component’s HTML tag with the browser.\n\n*Example*\n\n**my-element.js**\n\n```\n// Import the LitElement base class and html helper function\nimport { LitElement, html } from 'lit-element';\n\n// Extend the LitElement base class\nclass MyElement extends LitElement {\n\n  /**\n   * Implement `render` to define a template for your element.\n   *\n   * You must provide an implementation of `render` for any element\n   * that uses LitElement as a base class.\n   */\n  render(){\n    /**\n     * `render` must return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function:\n     */\n    return html`\n      <!-- template content -->\n      <p>A paragraph</p>\n    `;\n  }\n}\n// Register the new element with the browser.\ncustomElements.define('my-element', MyElement);\n```\n\n### Use LitElement TypeScript decorators\nYou can use the **@customElement TypeScript decorator** to define your class as a custom element:\n\n```\n/**\n * Import LitElement base class, html helper function,\n * and TypeScript decorators\n **/\nimport {\n  LitElement, html, customElement, property\n} from 'lit-element';\n\n/**\n * Use the customElement decorator to define your class as\n * a custom element. Registers <my-element> as an HTML tag.\n */\n@customElement('my-element')\nexport class MyElement extends LitElement {\n\n  /**\n   * Create an observed property. Triggers update on change.\n   */\n  @property()\n  foo = 'foo';\n\n  /**\n   * Implement `render` to define a template for your element.\n   */\n  render(){\n    /**\n     * Use JavaScript expressions to include property values in\n     * the element template.\n     */\n    return html`<p>${this.foo}</p>`;\n  }\n}\n```\n\n### Import a component\nImport your own LitElement component\nIn an HTML document:\n\n```\n<head>\n  <script type=\"module\" src=\"/path/to/my-element.js\"></script>\n</head>\n<body>\n  <my-element></my-element>\n</body>\n```\n\nIn another JavaScript module:\n\n```\n// Use relative paths for peer dependencies\nimport './my-element.js';\n\nclass MyOtherElement extends LitElement{\n  render(){\n    return html`\n      <my-element></my-element>\n    `;\n  }\n}\ncustomElements.define('my-other-element', MyOtherElement);\n```\n### Import a third-party LitElement component\nRefer to third-party component documentation first. To work with any existing component made by a third party, see its documentation. This guide should work for most LitElement-based components if they are published on npm.\n\nMany components are published on npm and can be installed from the command line:\n\n```\ncd my-project-folder\nnpm install package-name\n```\nIn an HTML document, a component published on npm can be imported from the node_modules folder:\n\n```\n<head>\n  <script type=\"module\" src=\"node_modules/package-name/existing-element.js\"></script>\n</head>\n<body>\n  <existing-element></existing-element>\n</body>\n```\nTo import into another JavaScript module, use the component’s package name:\n\n```\nimport 'package-name/existing-element.js';\n\nclass MyElement extends LitElement{\n  render(){\n    return html`\n      <existing-element></existing-element>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### What is lit-html?\nlit-html is a simple, modern, safe, small and fast **HTML templating library for JavaScript.**\n\nlit-html lets you write HTML templates in JavaScript using **template literals with embedded JavaScript expressions**. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.\n\nBuilding components? **lit-html is not tied to any component model**, it focuses only on creating and updating DOM. If you want to build components, check out **LitElement**, a library for building web components using lit-html templates.\n\n### lit-html Templates\nlit-html templates are **tagged template literals** - they look like JavaScript strings but are enclosed in backticks (`) instead of quotes - and tagged with lit-html's html tag:\n\n```\nhtml`<h1>Hello ${name}</h1>`\n```\nSince lit-html templates almost always need to merge in data from JavaScript values, and be able to update DOM when that data changes, they'll most often be written within functions that take some data and return a lit-html template, so that the function can be called multiple times:\n\n```\nlet myTemplate = (data) => html`\n  <h1>${data.title}</h1>\n  <p>${data.body}</p>`;\n```\n**lit-html is lazily rendered**. Calling this function will evaluate the template literal using lit-html html tag, and return a **TemplateResult** - a record of the template to render and data to render it with. TemplateResults are very cheap to produce and no real work actually happens until they are rendered to the DOM.\n\n### Rendering\nTo render a TemplateResult, call the ```render()``` function with a result and DOM container to render to:\n\n```\nconst result = myTemplate({title: 'Hello', body: 'lit-html is cool'});\nrender(result, document.body);\n```\n\n","references":"- [lit-html project](https://lit-html.polymer-project.org/guide)\n- [Example LitElement project](https://github.com/PolymerLabs/start-lit-element)\n- [lit-element project](https://lit-element.polymer-project.org/)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"lit-element-lit-html-introduction","weblink":"https://codersnack.com/lit-element-lit-html-introduction/","featured_image_preview":{"id":95,"name":"litelement-icon.png","hash":"06b6d9e7bfb645fa926460601fc692d2","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/06b6d9e7bfb645fa926460601fc692d2.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:28.984Z","updated_at":"2020-04-14T15:08:28.984Z"}},"codersnacks_quiz":{"id":54,"question":"LitElement is a ...","response_valid":"simple base class for creating fast, lightweight web components that work in any web page with any framework.","response_invalid1":"a rule for naming tiny web component","response_invalid2":"a new frontend full framework based on small web components","created_at":"2020-03-30T16:09:24.804Z","updated_at":"2020-03-30T16:09:24.804Z"},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - LitElement is","created_at":"2020-03-30T16:10:08.600Z","updated_at":"2020-03-30T16:10:08.610Z"},{"id":55,"codersnack":{"id":60,"header":"LitElement Templates 1","created_at":"2020-03-31T08:59:29.566Z","updated_at":"2020-04-14T15:08:15.088Z","explanation":"Add a template to your component to define internal DOM to implement your component.\n\nTo encapsulate the templated DOM LitElement uses **shadow DOM**. Shadow DOM provides three benefits:\n\n- **DOM scoping**. DOM APIs like document.querySelector won’t find elements in the component’s shadow DOM, so it’s harder for global scripts to accidentally break your component.\n- **Style scoping**. You can write encapsulated styles for your shadow DOM that don’t affect the rest of the DOM tree.\n- **Composition**. The component’s shadow DOM (managed by the component) is separate from the component’s children. You can choose how children are rendered in your templated DOM. Component users can add and remove children using standard DOM APIs without accidentally breaking anything in your shadow DOM.\n\nWhere native shadow DOM isn’t available, LitElement uses the **Shady CSS polyfill**.\n\n### Define and render a template\nTo define a template for a LitElement component, write a render function for your element class:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>template content</p>`;\n  }\n}\n```\n\nWrite your template in HTML inside a JavaScript template literal by enclosing the raw HTML in back-ticks (``).\n\n**Tag your template literal with the html tag function**.\n\nThe component’s render method can return anything that lit-html can render. Typically, **it returns a single TemplateResult object** (the same type returned by the html tag function).\n\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n\n  // Implement `render` to define a template for your element.\n  render(){\n    /**\n     * Return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function.\n     */\n    return html`\n      <div>\n        <p>A paragraph</p>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n**LitElement uses lit-html templates**; this page summarizes the features of lit-html templates, for more details, see Writing templates and the Template syntax reference in the lit-html documentation.\n\n### Design a performant template\n**LitElement renders and re-renders asynchronously, updating in response to batched property changes** (see Element update lifecycle for more information).\n\n**During an update, only the parts of the DOM that change are re-rendered**. To get the performance benefits of this model, **you should design your element's template as a pure function of its properties**.\n\nTo do this, make sure the render function:\n\n- Does not change the element’s state.\n- Does not have any side effects.\n- Only depends on the element’s properties.\n- Returns the same result when given the same property values.\n- Also, avoid making DOM updates outside of render. Instead, express the element’s template as a function of its state, and capture its state in properties.\n\nThe following code uses inefficient DOM manipulation:\n\n**dom-manip.js**\n\n```\n// Anti-pattern. Avoid!\n\nconstructor() {\n  super();\n  this.addEventListener('stuff-loaded', (e) => {\n    this.shadowRoot.getElementById('message').innerHTML=e.detail;\n  });\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p id=\"message\">Loading</p>\n  `;\n}\n```\n\nWe can improve the template by capturing the load message as a property, and setting the property in response to the event:\n\n**update-properties.js**\n\n```\nconstructor() {\n  super();\n  this.message = 'Loading';\n  this.addEventListener('stuff-loaded', (e) => { this.message = e.detail } );\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p>${this.message}</p>\n  `;\n}\n```\n\n### Use properties, loops, and conditionals in a template\nWhen defining your element's template, you can **bind the element's properties to the template; the template is re-rendered whenever the properties change.**\n\n##### Properties\nTo add a property value to a template, insert it with ```${this.propName}```:\n\n```\nstatic get properties() {\n  return { myProp: String };\n}\n...\nrender() {\n  return html`<p>${this.myProp}</p>`;\n}\n```\n\n##### Loops\nIterate over an array:\n\n```\nhtml`<ul>\n  ${this.myArray.map(i => html`<li>${i}</li>`)}\n</ul>`;\n```\n##### Conditionals\nRender based on a Boolean condition:\n\n```\nhtml`\n  ${this.myBool?\n    html`<p>Render some HTML if myBool is true</p>`:\n    html`<p>Render some other HTML if myBool is false</p>`}\n`;\n```\n**Examples**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      myString: { type: String },\n      myArray: { type: Array },\n      myBool: { type: Boolean }\n    };\n  }\n  constructor() {\n    super();\n    this.myString = 'Hello World';\n    this.myArray = ['an','array','of','test','data'];\n    this.myBool = true;\n  }\n  render() {\n    return html`\n      <p>${this.myString}</p>\n      <ul>\n        ${this.myArray.map(i => html`<li>${i}</li>`)}\n      </ul>\n      ${this.myBool?\n        html`<p>Render some HTML if myBool is true</p>`:\n        html`<p>Render some other HTML if myBool is false</p>`}\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates","weblink":"https://codersnack.com/webcomponents-litelement-templates/","featured_image_preview":{"id":94,"name":"litelement-icon.png","hash":"b3ca5cab6412452092f10c43a1ab61c3","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/b3ca5cab6412452092f10c43a1ab61c3.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:15.101Z","updated_at":"2020-04-14T15:08:15.101Z"}},"codersnacks_quiz":{"id":55,"question":"LitElement Templates - Shadow DOM provides three benefits:","response_valid":"DOM scoping, style scoping and composition","response_invalid1":"reusability , scalability and performance","response_invalid2":"a better performance DOM rendering","created_at":"2020-03-31T12:18:18.515Z","updated_at":"2020-03-31T12:18:18.515Z"},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Template","created_at":"2020-03-31T12:28:38.975Z","updated_at":"2020-03-31T12:28:38.984Z"},{"id":69,"codersnack":{"id":84,"header":"Using the Shadow DOM","created_at":"2020-06-23T12:09:16.576Z","updated_at":"2020-06-23T12:39:11.606Z","explanation":"An important aspect of web components is **encapsulation** , being able to keep the markup structure, style, and behavior hidden and separate from other code on the page so that different parts do not clash, and the code can be kept nice and clean. \n\nThe **Shadow DOM API** is a key part of this, providing a way to **attach a hidden separated DOM to an element**. This article covers the basics of using the Shadow DOM.\n\n\n## High-level view\n\nThis article assumes you are already familiar with the concept of the **DOM (Document Object Model)**, a tree-like structure of connected nodes that represents the different elements and strings of text appearing in a markup document (usually an HTML document in the case of web documents). As an example, consider the following HTML fragment:\n``` \n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Simple DOM example</title>\n  </head>\n  <body>\n      <section>\n        <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\">\n        <p>Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a></p>\n      </section>\n  </body>\n</html>\n``` \nThis fragment produces the following DOM structure:\n![dom screenshot](https://codersnack.com/assets/images/wc-dom-screenshot.png)\n\n\n**Shadow DOM allows hidden DOM trees to be attached to elements in the regular DOM tree** ; this shadow DOM tree starts with a shadow root, underneath which can be attached to any elements you want, in the same way as the normal DOM.\n\n![Shadow dom](https://codersnack.com/assets/images/wc-shadow-dom.png)\n\nThere are some **bits of shadow DOM terminology to be aware of**:\n\n- **Shadow host**: The regular DOM node that the shadow DOM is attached to.\n- **Shadow tree**: The DOM tree inside the shadow DOM.\n- **Shadow boundary**: the place where the shadow DOM ends, and the regular DOM begins.\n- **Shadow root**: The root node of the shadow tree.\n\n**You can affect the nodes in the shadow DOM in exactly the same way as non-shadow nodes** ; for example appending children or setting attributes, styling individual nodes using ```element.style.foo```, or adding style to the entire shadow DOM tree inside a ```<style>``` element. **The difference is that none of the code inside a shadow DOM can affect anything outside it, allowing for handy encapsulation**.\n\nNote that the shadow DOM is not a new thing by any means ; **browsers have used it for a long time to encapsulate the inner structure of an element**. Think for example of a ```<video>``` element, with the default browser controls exposed. All you see in the DOM is the ```<video>``` element, but it contains a series of buttons and other controls inside its shadow DOM. The shadow DOM spec has made it so that you are allowed to actually manipulate the shadow DOM of your own custom elements.\n\n## Basic usage\nYou can attach a shadow root to any element using the **Element.attachShadow()** method. This takes as its parameter an options object that contains one option ; *mode* ; with a value of open or closed:\n```\nlet shadow = elementRef.attachShadow({mode: 'open'});\nlet shadow = elementRef.attachShadow({mode: 'closed'});\n```\n***open* means that you can access the shadow DOM using JavaScript written in the main page context**, for example using the **Element.shadowRoot** property:\n\n```\nlet myShadowDom = myCustomElem.shadowRoot;\n```\n**If you attach a shadow root to a custom element with *mode: closed* set, you won't be able to access the shadow DOM from the outside** ; ``` myCustomElem.shadowRoot``` returns null. This is the case with built in elements that contain shadow DOMs, such as ```<video>```.\n\n> ***Note***: As this blog post shows, it is actually fairly easy to work around closed shadow DOMs, and the hassle to completely hide them is often more than it's worth.\n\nIf you are **attaching a shadow DOM to a custom element as part of its constructor** (by far the most useful application of the shadow DOM), you would use something like this:\n\n```\nlet shadow = this.attachShadow({mode: 'open'});\n```\nWhen you've attached a shadow DOM to an element, manipulating it is a matter of just using the same DOM APIs as you use for the regular DOM manipulation:\n\n```\nvar para = document.createElement('p');\nshadow.appendChild(para);\n// etc.\n```\n\n## Working through a simple example\n\nNow let's walk through a simple example to demonstrate the shadow DOM in action inside a custom element ; ```<popup-info-box>``` (see a live example also). This takes an image icon and a text string, and embeds the icon into the page. When the icon is focused, it displays the text in a pop up information box to provide further in-context information. To begin with, in our JavaScript file we define a class called *PopUpInfo*, which extends HTMLElement:\n\n```\nclass PopUpInfo extends HTMLElement {\n  constructor() {\n    // Always call super first in constructor\n    super();\n\n    // write element functionality in here\n\n    ...\n  }\n}\n```\n\nInside the class definition we define the element's **constructor**, which defines all the **functionality the element will have when an instance of it is instantiated**.\n\n### Creating the shadow root\n\nWe first attach a shadow root to the custom element:\n\n```\n// Create a shadow root\nvar shadow = this.attachShadow({mode: 'open'});\n```\n\n### Creating the shadow DOM structure\n\nNext, we use some DOM manipulation to create the element's internal shadow DOM structure:\n\n```\n// Create spans\nvar wrapper = document.createElement('span');\nwrapper.setAttribute('class','wrapper');\nvar icon = document.createElement('span');\nicon.setAttribute('class','icon');\nicon.setAttribute('tabindex', 0);\nvar info = document.createElement('span');\ninfo.setAttribute('class','info');\n\n// Take attribute content and put it inside the info span\nvar text = this.getAttribute('text');\ninfo.textContent = text;\n\n// Insert icon\nvar imgUrl;\nif(this.hasAttribute('img')) {\n  imgUrl = this.getAttribute('img');\n} else {\n  imgUrl = 'img/default.png';\n}\nvar img = document.createElement('img');\nimg.src = imgUrl;\nicon.appendChild(img);\n```\n\n### Styling the shadow DOM\n\nAfter that we create a ```<style>``` element and populate it with some CSS to style it:\n\n```\n// Create some CSS to apply to the shadow dom\nvar style = document.createElement('style');\n\nstyle.textContent = `\n.wrapper {\n  position: relative;\n}\n\n.info {\n  font-size: 0.8rem;\n  width: 200px;\n  display: inline-block;\n  border: 1px solid black;\n  padding: 10px;\n  background: white;\n  border-radius: 10px;\n  opacity: 0;\n  transition: 0.6s all;\n  position: absolute;\n  bottom: 20px;\n  left: 10px;\n  z-index: 3;\n}\n\nimg {\n  width: 1.2rem;\n}\n\n.icon:hover + .info, .icon:focus + .info {\n  opacity: 1;\n}`;\n```\n\n### Attaching the shadow DOM to the shadow root\n\nThe final step is to attach all the created elements to the shadow root:\n\n```\n// attach the created elements to the shadow dom\nshadow.appendChild(style);\nshadow.appendChild(wrapper);\nwrapper.appendChild(icon);\nwrapper.appendChild(info);\n```\n\n### Using our custom element\n\nOnce the class is defined, using the element is as simple as defining it, and putting it on the page, as explained in Using custom elements:\n\n```\n// Define the new element\ncustomElements.define('popup-info', PopUpInfo);\n```\n\n```\n<popup-info img=\"img/alt.png\" text=\"Your card validation code (CVC) is an extra \n                                    security feature — it is the last 3 or 4\n                                    numbers on the back of your card.\">\n```\n\n### Internal versus external styles\n\nIn the above example we apply style to the Shadow DOM using a ```<style>``` element, but it is perfectly possible to do it by referencing an external stylesheet from a ```<link>``` element instead.\n\nFor example, take a look at this code from our *popup-info-box-external-stylesheet* example (see the source code):\n\n```\n// Apply external styles to the shadow dom\nconst linkElem = document.createElement('link');\nlinkElem.setAttribute('rel', 'stylesheet');\nlinkElem.setAttribute('href', 'style.css');\n\n// Attach the created element to the shadow dom\nshadow.appendChild(linkElem);\n```\n\nNote that ```<link>``` elements **do not block paint of the shadow root, so there may be a flash of unstyled content** (FOUC) while the stylesheet loads.\n\n> Many modern browsers implement an optimization for ```<style>``` tags either cloned from a common node or that have identical text, to allow them to share a single backing stylesheet. With this optimization the performance of external and internal styles should be similar.","references":"- [MDN  - Using the Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM#:~:text=let%20shadow%20%3D%20elementRef.,for%20example%20using%20the%20Element.)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-shadow-dom","weblink":"https://codersnack.com/web-components-shadow-dom/","featured_image_preview":{"id":115,"name":"web-components.png","hash":"5ae94abde1204a748c846f218b77c985","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/5ae94abde1204a748c846f218b77c985.png","provider":"local","provider_metadata":null,"created_at":"2020-06-23T12:09:16.609Z","updated_at":"2020-06-23T12:09:16.609Z"}},"codersnacks_quiz":{"id":69,"question":"The Shadow DOM API ...","response_valid":"allows hidden DOM trees to be attached to elements in the regular DOM tree","response_invalid1":"allows to encapsulate some styling rules","response_invalid2":"creates a cloned component","created_at":"2020-06-23T12:13:22.582Z","updated_at":"2020-06-23T12:13:22.582Z"},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web Component - Using the Shadow DOM - Shadow DOM API","created_at":"2020-06-23T12:14:09.506Z","updated_at":"2020-06-23T12:14:09.510Z"},{"id":70,"codersnack":{"id":85,"header":"Web Components - Using Templates and Slots","created_at":"2020-06-23T14:13:26.825Z","updated_at":"2020-06-23T14:13:26.825Z","explanation":"This article explains how you can use the ```<template>``` and ```<slot>``` elements to create a flexible template that can then be used to populate the shadow DOM of a web component.\n\n## The truth about templates\n\n**When you have to reuse the same markup structures repeatedly on a web page, it makes sense to use some kind of a template rather than repeating the same structure over and over again**. This was possible before, but it is made a lot easier by the HTML ```<template>``` element (which is well-supported in modern browsers: https://www.w3schools.com/tags/tag_template.asp ). This element and its contents are not rendered in the DOM, but it can still be referenced using JavaScript.\n\nLet's look at a trivial quick example:\n\n```\n<template id=\"my-paragraph\">\n  <p>My paragraph</p>\n</template>\n```\nThis won't appear in your page until you grab a reference to it with JavaScript and then append it to the DOM, using something like the following:\n\n```\nlet template = document.getElementById('my-paragraph');\nlet templateContent = template.content;\ndocument.body.appendChild(templateContent);\n```\n\nAlthough trivial, you can already start to see how this could be useful.\n\n## Using templates with web components\n\nTemplates are useful on their own, but they work even better with web components. Let's define a web component that uses our template as the content of its shadow DOM. We'll call it ```<my-paragraph>```:\n\n```\ncustomElements.define('my-paragraph',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      let template = document.getElementById('my-paragraph');\n      let templateContent = template.content;\n\n      const shadowRoot = this.attachShadow({mode: 'open'})\n        .appendChild(templateContent.cloneNode(true));\n    }\n  }\n);\n```\n\nThe key point to note here is that **we append a clone of the template content to the shadow root**, created using the **Node.cloneNode()** method.\n\nAnd because we are appending its contents to a shadow DOM, **we can include some styling information inside the template** in a ```<style>``` element, which is then encapsulated inside the custom element. This wouldn't work if we just appended it to the standard DOM.\n\nSo for example:\n\n```\n<template id=\"my-paragraph\">\n  <style>\n    p {\n      color: white;\n      background-color: #666;\n      padding: 5px;\n    }\n  </style>\n  <p>My paragraph</p>\n</template>\n```\n\nNow we can use it by just adding it to our HTML document:\n```\n<my-paragraph></my-paragraph>\n```\n> ***Note***: Templates are well-supported in browsers; the Shadow DOM API is supported by default in Firefox (version 63 onwards), Chrome, Opera, Safari, and Edge (starting with version 79).\n\n## Adding flexibility with slots\n\nSo far so good, but the element isn't very flexible. We can only display one bit of text inside it, meaning that at the moment it is even less useful than a regular paragraph! We can make it possible to **display different text in each element instance** in a nice declarative way using the ```<slot>```  element. This has more limited support than ```<template>```,  available since Chrome 53, Opera 40, Safari 10, Firefox 59, and Edge 79.\n\n**Slots are identified by their name attribute**, and **allow you to define *placeholders* in your template that can be filled with any markup fragment** you want when the element is used in the markup.\n\nSo, if we want to add a slot into our trivial example, we could update our template's paragraph element like this:\n\n```\n<p><slot name=\"my-text\">My default text</slot></p>\n```\nIf the slot's content isn't defined when the element is included in the markup, or if the browser doesn't support slots, ```<my-paragraph>```  just contains the **fallback content** ```\"My default text\"```.\n\nTo define the slot's content, we include an HTML structure inside the ```<my-paragraph>``` element with a **slot attribute** whose *value* is equal to the name of the slot we want it to fill. As before, this can be anything you like, for example:\n\n```<my-paragraph>\n  <span slot=\"my-text\">Let's have some different text!</span>\n</my-paragraph>\n```\nor\n\n```\n<my-paragraph>\n  <ul slot=\"my-text\">\n    <li>Let's have some different text!</li>\n    <li>In a list!</li>\n  </ul>\n</my-paragraph>\n```\n> Note: Elements that can be inserted into slots are known as **Slotable**; when an element has been inserted in a slot, it is said to be slotted.\n\n> Note: An **unnamed** ```<slot>``` will be **filled with all of the custom element's top-level child nodes** that do not have the slot attribute. This includes text nodes.\n\nAnd that's it for our trivial example. If you want to play with it some more, you can find it on GitHub (see it running live also).\n\n## A more involved example\n\nTo finish off the article, let's look at something a little less trivial.\n\nThe following set of code snippets show how to use ```<slot>``` together with ```<template>``` and some JavaScript to:\n\n- create a ```<element-details>``` element with named slots in its shadow root\n- design the ```<element-details>``` element in such a way that, when used in documents, it is rendered from composing the element’s content together with content from its shadow root; that is, pieces of the element’s content are used to fill in named slots in its shadow root\n\nNote that it is technically possible to use ```<slot>``` element without a ```<template>``` element, e.g., within say a regular ```<div>``` element, and still take advantage of the place-holder features of  ```<slot>``` for Shadow DOM content, and doing so may indeed avoid the small trouble of needing to first access the template element's content property (and clone it). However, it is generally more practical to add slots within a ```<template>``` element, since you are unlikely to need to define a pattern based on an already-rendered element.\n\nIn addition, even if it is not already rendered, the purpose of the container as a template should be more semantically clear when using the ```<template>```. In addition, ```<template>``` can have items directly added to it, like ```<td>```, which would disappear when added to a ```<div>```.\n\n### Creating a template with some slots\n\nFirst of all, we use the ```<slot>``` element within a ```<template>``` element to create a new \"element-details-template\" document fragment containing some named slots:\n\n```\n<template id=\"element-details-template\">\n  <style>\n  details {font-family: \"Open Sans Light\",Helvetica,Arial}\n  .name {font-weight: bold; color: #217ac0; font-size: 120%}\n  h4 { margin: 10px 0 -8px 0; }\n  h4 span { background: #217ac0; padding: 2px 6px 2px 6px }\n  h4 span { border: 1px solid #cee9f9; border-radius: 4px }\n  h4 span { color: white }\n  .attributes { margin-left: 22px; font-size: 90% }\n  .attributes p { margin-left: 16px; font-style: italic }\n  </style>\n  <details>\n    <summary>\n      <span>\n        <code class=\"name\">&lt;<slot name=\"element-name\">NEED NAME</slot>&gt;</code>\n        <i class=\"desc\"><slot name=\"description\">NEED DESCRIPTION</slot></i>\n      </span>\n    </summary>\n    <div class=\"attributes\">\n      <h4><span>Attributes</span></h4>\n      <slot name=\"attributes\"><p>None</p></slot>\n    </div>\n  </details>\n  <hr>\n</template>\n```\nThat ```<template>``` element has several features:\n\nThe ```<template>``` has a ```<style>``` element with a **set of CSS styles that are scoped just to the document fragment** the  ```<template>``` creates.\nThe ```<template>``` uses ```<slot>``` and its *name* attribute to make three *named slots*:\n- ```<slot name=\"element-name\">```\n- ```<slot name=\"description\">```\n- ```<slot name=\"attributes\">```\n\nThe ```<template>``` wraps the named slots in a ```<details>``` element.\n\n### Creating a new ```<element-details>``` element from the ```<template>```\n\nNext, let’s create a new custom element named ```<element-details>``` and use **Element.attachShadow** to attach to it, as its shadow root, that document fragment we created with our ```<template>``` element above. This uses exactly the same pattern as we saw in our earlier trivial example.\n\n```\ncustomElements.define('element-details',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      var template = document\n        .getElementById('element-details-template')\n        .content;\n      const shadowRoot = this.attachShadow({mode: 'open'})\n        .appendChild(template.cloneNode(true));\n    }\n  }\n);\n```\n\n### Using the ```<element-details>``` custom element with named slots\n\nNow let’s take that ```<element-details>``` element and actually use it in our document:\n\n```\n<element-details>\n  <span slot=\"element-name\">slot</span>\n  <span slot=\"description\">A placeholder inside a web\n    component that users can fill with their own markup,\n    with the effect of composing different DOM trees\n    together.</span>\n  <dl slot=\"attributes\">\n    <dt>name</dt>\n    <dd>The name of the slot.</dd>\n  </dl>\n</element-details>\n```\n\n```\n<element-details>\n  <span slot=\"element-name\">template</span>\n  <span slot=\"description\">A mechanism for holding client-\n    side content that is not to be rendered when a page is\n    loaded but may subsequently be instantiated during\n    runtime using JavaScript.</span>\n</element-details> \n```\n\nAbout that snippet, notice these points:\n\n- The snippet has two instances of ```<element-details>``` elements which both use the *slot* attribute to reference the named slots \"element-name\" and \"description\" we put in the ```<element-details>``` shadow root .\n\n- Only the first of those two ```<element-details>``` elements references the \"attributes\" named slot. The second ```<element-details>``` element lacks any reference to the \"attributes\" named slot.\n\n- The first ```<element-details>``` element references the \"attributes\" named slot using a ```<dl>``` element with ```<dt>``` and ```<dd>``` children.\n\n### Adding a final bit of style\n\nAs a finishing touch, we'll add a tiny bit more CSS for the ```<dl>```, ```<dt>```, and ```<dd>``` elements in our doc:\n\n ```\n dl { margin-left: 6px; }\n  dt { font-weight: bold; color: #217ac0; font-size: 110% }\n  dt { font-family: Consolas, \"Liberation Mono\", Courier }\n  dd { margin-left: 16px }\n```\nResult\nFinally let’s put all the snippets together and see what the rendered result looks like.\n\t\nNotice the following points about this rendered result:\n\n- Even though the instances of the ```<element-details>``` element in the document do not directly use the ```<details>``` element, they get rendered using ```<details>``` because the shadow root causes them to get populated with that.\n- Within the rendered ```<details>``` output, the content in the ```<element-details>``` elements fills the named slots from the shadow root. In other words, the DOM tree from the ```<element-details>``` elements get composed together with the content of the shadow root.\n- For both ```<element-details>``` elements, an *Attributes* heading gets automatically added from the shadow root before the position of the \"attributes\" named slot.\n- Because the first ```<element-details>``` has a ```<dl>``` element which explicitly references the \"attributes\" named slot from its shadow root, the contents of that ```<dl>``` replace the \"attributes\" named slot from the shadow root.\n- Because the second ```<element-details>``` doesn’t explicitly reference the \"attributes\" named slot from its shadow root, its content for that named slot gets filled with the default content for it from the shadow root.","references":"- [MDN - Using Templates and Slots](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-templates-slots","weblink":"https://codersnack.com/web-components-templates-slots/","featured_image_preview":{"id":116,"name":"web-components.png","hash":"3b6d136b6dbf483185b25055e533b752","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/3b6d136b6dbf483185b25055e533b752.png","provider":"local","provider_metadata":null,"created_at":"2020-06-23T14:13:26.868Z","updated_at":"2020-06-23T14:13:26.868Z"}},"codersnacks_quiz":{"id":70,"question":"Web component - Using templates ...","response_valid":"makes sense to use some kind of a html snippet rather than repeating the same structure over and over again","response_invalid1":"allows to export html snippets to external components","response_invalid2":"allows to import a sketch design","created_at":"2020-06-23T14:17:35.818Z","updated_at":"2020-06-23T14:17:35.818Z"},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - Using templates and Slots -Using templates","created_at":"2020-06-23T14:18:25.878Z","updated_at":"2020-06-23T14:18:25.890Z"}]