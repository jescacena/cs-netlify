[{"id":81,"codersnack":{"id":82,"header":"What is Angular?","created_at":"2020-06-15T09:44:23.825Z","updated_at":"2020-06-16T21:21:09.533Z","explanation":"**Angular is a platform and framework for building single-page client applications using HTML and TypeScript**. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps.\n\nThe architecture of an Angular application relies on certain fundamental concepts. The basic building blocks are **NgModules**, which provide **a compilation context for components**. NgModules collect related code into functional sets; **an Angular app is defined by a set of NgModules**. An app always has at least a root module that enables bootstrapping, and typically has many more feature modules.\n\n**Components define views**, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.\n\n**Components use services**, which provide specific functionality not directly related to views. Service providers can be injected into components as dependencies, making your code modular, reusable, and efficient.\n\n**Both components and services are simply classes, with decorators** that mark their type and provide metadata that tells Angular how to use them.\n\nThe metadata for a component class associates it with a template that defines a view. A template combines ordinary HTML with Angular directives and binding markup that allow Angular to modify the HTML before rendering it for display.\n\n> The metadata for a service class provides the information Angular needs to make it available to components through **dependency injection (DI)**.\n\nAn app's components typically define many views, arranged hierarchically. Angular provides the **Router service** to help you define navigation paths among views. The router provides sophisticated in-browser navigational capabilities.\n\n\n## Modules\n\n*Angular NgModules differ from and complement JavaScript (ES2015) modules*. **An NgModule declares a compilation context for a set of components that is dedicated to an application domain**, a workflow, or a closely related set of capabilities. An NgModule can associate its components with related code, such as services, to form functional units.\n\n**Every Angular app has a root module, conventionally named AppModule**, which provides the bootstrap mechanism that launches the application. An app typically contains many functional modules.\n\n**Like JavaScript modules, NgModules can import functionality from other NgModules**, and allow their own functionality to be exported and used by other NgModules. For example, to use the router service in your app, you import the Router NgModule.\n\n> Organizing your code into distinct functional modules helps in managing development of complex applications, and in designing for reusability. In addition, this technique lets you take advantage of lazy-loading, that is, loading modules on demand, to minimize the amount of code that needs to be loaded at startup.\n\n\n## Components\n\n**Every Angular application has at least one component, the root component that connects a component hierarchy with the page document object model (DOM)**. Each component defines a class that contains application data and logic, and is associated with an HTML template that defines a view to be displayed in a target environment.\n\nThe **@Component() decorator** identifies the class immediately below it as a component, and provides the template and related component-specific metadata.\n\n**Decorators are functions that modify JavaScript classes**. Angular defines a number of decorators that attach specific kinds of metadata to classes, so that the system knows what those classes mean and how they should work.\n\n\n\n## Templates, directives, and data binding\n\n**A template combines HTML with Angular markup that can modify HTML elements before they are displayed**. *Template directives provide program logic, and binding markup connects your application data and the DOM*. There are two types of data binding:\n\n- **Event binding** lets your app respond to user input in the target environment by updating your application data.\n- **Property binding** lets you interpolate values that are computed from your application data into the HTML.\n\nBefore a view is displayed, Angular evaluates the directives and resolves the binding syntax in the template to modify the HTML elements and the DOM, according to your program data and logic. Angular supports **two-way data binding**, meaning that changes in the DOM, such as user choices, are also reflected in your program data.\n\nYour templates can use **pipes to improve the user experience by transforming values for display**. For example, use pipes to display dates and currency values that are appropriate for a user's locale. Angular provides predefined pipes for common transformations, and you can also define your own pipes.\n\n\n## Services and dependency injection\n\n**For data or logic that isn't associated with a specific view, and that you want to share across components, you create a service class**. A service class definition is immediately preceded by the **@Injectable() decorator.** The decorator provides the metadata that allows other providers to be injected as dependencies into your class.\n\nDependency injection (DI) lets you keep your component classes lean and efficient. They don't fetch data from the server, validate user input, or log directly to the console; they delegate such tasks to services.\n\n## Routing\n\nThe Angular Router NgModule provides a service that lets you define a navigation path among the different application states and view hierarchies in your app. It is modeled on the familiar browser navigation conventions:\n\n- **Enter a URL in the address bar** and the browser navigates to a corresponding page.\n\n- **Click links** on the page and the browser navigates to a new page.\n\n- **Click the browser's back** and forward buttons and the browser navigates backward and forward through the history of pages you've seen.\n\n**The router maps URL-like paths to views instead of pages**. When a user performs an action, such as clicking a link, that would load a new page in the browser, the router intercepts the browser's behavior, and shows or hides view hierarchies.\n\nIf the router determines that the current application state requires particular functionality, and the module that defines it hasn't been loaded, the **router can lazy-load the module on demand.**\n\nThe router interprets a link URL according to your app's view navigation rules and data state. You can navigate to new views when the user clicks a button or selects from a drop box, or in response to some other stimulus from any source. **The router logs activity in the browser's history, so the back and forward buttons work as well**.\n\nTo define navigation rules, you associate navigation paths with your components. A path uses a URL-like syntax that integrates your program data, in much the same way that template syntax integrates your views with your program data. You can then apply program logic to choose which views to show or to hide, in response to user input and your own access rules.\n\n\n![angular overview](https://codersnack.com/assets/images/angular-overview2.png)\n\n\n- A decorator on a component class adds the metadata, including a pointer to the associated template.\n- Directives and binding markup in a component's template modify views based on program data and logic.\n- The dependency injector provides services to a component, such as the router service that lets you define navigation among views.\n","references":"- [Angular.io Architecture](https://angular.io/guide/architecture)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-what-is","weblink":"https://codersnack.com/angular-what-is","featured_image_preview":{"id":112,"name":"angular-icon.png","hash":"dfe02d1bea914ebd87a76c38b95ea20d","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/dfe02d1bea914ebd87a76c38b95ea20d.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T09:44:23.836Z","updated_at":"2020-06-15T09:44:23.836Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular What is","created_at":"2020-06-15T09:44:44.777Z","updated_at":"2020-06-15T09:44:44.780Z"},{"id":82,"codersnack":{"id":83,"header":"Angular Data Biding and Pipes and Directives","created_at":"2020-06-15T17:04:11.159Z","updated_at":"2020-06-16T21:03:05.124Z","explanation":"## Data binding\n\n**Without a framework, you would be responsible for pushing data values into the HTML controls** and turning user responses into actions and value updates. Writing such push and pull logic by hand is tedious, error-prone, and a nightmare to read, as any experienced front-end JavaScript programmer can attest.\n\n**Angular supports two-way data binding**, a mechanism for coordinating the parts of a template with the parts of a component. Add binding markup to the template HTML to tell Angular how to connect both sides.\n\nThe following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both.\n\n![angular databinding](https://codersnack.com/assets/images/angular-databinding.png)\n\nThis example from the HeroListComponent template uses three of these forms.\n\n*src/app/hero-list.component.html (binding)*\n```\n<li>{{hero.name}}</li>\n<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>\n<li (click)=\"selectHero(hero)\"></li>\n```\n\nThe ``` {{hero.name}} ``` interpolation displays the component's *hero.name* property value within the ``` <li> ``` element.\n\nThe ```[hero]``` property binding passes the value of *selectedHero* from the parent *HeroListComponent* to the *hero* property of the child *HeroDetailComponent*.\n\nThe ```(click)``` event binding calls the component's *selectHero* method when the user clicks a hero's name.\n\n**Two-way data binding (used mainly in template-driven forms) combines property and event binding in a single notation**. Here's an example from the *HeroDetailComponent* template that uses two-way data binding with the *ngModel directive*.\n\n*src/app/hero-detail.component.html (ngModel)*\n```\n<input [(ngModel)]=\"hero.name\">\n```\nIn two-way binding, a data property value flows to the input box from the component as with property binding. The user's changes also flow back to the component, resetting the property to the latest value, as with event binding.\n\n> Angular processes all data bindings once for each JavaScript event cycle, from the root of the application component tree through all child components.\n\n\nData binding plays an important role in communication between a template and its component, and is also important for communication between parent and child components.\n\n## Pipes\n\n**Angular pipes let you declare display-value transformations in your template HTML**. A class with the **@Pipe decorator** defines a function that transforms input values to output values for display in a view.\n\n**Angular defines various pipes**, such as the date pipe and currency pipe; for a complete list, see the Pipes API list. You can also define new pipes.\n\nTo specify a value transformation in an HTML template, use the **pipe operator (|)**.\n```\n{{interpolated_value | pipe_name}}\n```\n\n**You can chain pipes**, sending the output of one pipe function to be transformed by another pipe function. **A pipe can also take arguments** that control how it performs its transformation. For example, you can pass the desired format to the date pipe.\n\n\n\n## Directives\n\nAngular templates are dynamic. **When Angular renders them, it transforms the DOM according to the instructions given by directives**. **A directive is a class with a @Directive() decorator**.\n\n> A component is technically a directive. However, components are so distinctive and central to Angular applications that Angular defines the **@Component()** decorator, which extends the **@Directive()** decorator with template-oriented features.\n\n**In addition to components, there are two other kinds of directives: structural and attribute**. Angular defines a number of directives of both kinds, and you can define your own using the **@Directive()** decorator.\n\nJust as for components, the metadata for a directive associates the decorated class with a selector element that you use to insert it into HTML. In templates, directives typically appear within an element tag as attributes, either by name or as the target of an assignment or a binding.\n\n### Structural directives\n\n**Structural directives alter layout by adding, removing, and replacing elements in the DOM**. The example template uses two built-in structural directives to add application logic to how the view is rendered.\n\n*src/app/hero-list.component.html (structural)*\n```\n<li *ngFor=\"let hero of heroes\"></li>\n<app-hero-detail *ngIf=\"selectedHero\"></app-hero-detail>\n```\n\n``` *ngFor ``` is an **iterative**:  it tells Angular to stamp out one ``` <li> ``` per hero in the heroes list.\n``` *ngIf ``` is a **conditional**: it includes the *HeroDetail* component only if a selected hero exists.\n\n### Attribute directives\n\n**Attribute directives alter the appearance or behavior of an existing element**. In templates they look like regular HTML attributes, hence the name.\n\nThe **ngModel** directive, which implements two-way data binding, is an example of an attribute directive. ngModel modifies the behavior of an existing element (typically ```<input>```) by setting its display value property and responding to change events.\n\n*src/app/hero-detail.component.html (ngModel)*\n```\n<input [(ngModel)]=\"hero.name\">\n```\n**Angular has more pre-defined directives** that either alter the layout structure (for example, ngSwitch) or modify aspects of DOM elements and components (for example, ngStyle and ngClass).\n\n","references":"- [Angular.io Architecture Components](https://angular.io/guide/architecture-components)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-data-binding-pipes-directives","weblink":"https://codersnack.com/angular-data-binding-pipes-directives","featured_image_preview":{"id":113,"name":"angular-icon.png","hash":"95a0b7ed921145449b6a97243a0ed410","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/95a0b7ed921145449b6a97243a0ed410.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T17:04:11.173Z","updated_at":"2020-06-15T17:04:11.173Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Data Binding & Pipes & Directives","created_at":"2020-06-15T17:04:59.993Z","updated_at":"2020-06-15T17:04:59.999Z"},{"id":90,"codersnack":{"id":91,"header":"Angular - Observables","created_at":"2021-04-11T16:02:37.392Z","updated_at":"2021-04-11T16:02:37.392Z","explanation":"\nAngular makes use of **observables as an interface to handle a variety of common asynchronous operations**. For example:\n\t•\tYou can define **custom events** that send observable output data from a child to a parent component.\n\t•\tThe HTTP module uses observables to **handle AJAX requests and responses**.\n\t•\tThe **Router and Forms modules use observables** to listen for and respond to user-input events.\n\n### Transmitting data between components\n\nAngular provides an **EventEmitter** class that is used when publishing values from a component through the ```@Output()``` decorator. EventEmitter extends RxJS\nSubject, adding an **emit()** method so it can send arbitrary values. When you call **emit()**, it passes the emitted value to the **next()** method of any **subscribed observer**.\nA good example of usage can be found in the EventEmitter documentation. Here is the example component that listens for open and close events:\n```\n<app-zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></app-zippy>\n```\n\nHere is the component definition:\n\n**ZippyComponent**\n```\n@Component({\n  selector: 'app-zippy',\n  template: `\n    <div class=\"zippy\">\n      <div (click)=\"toggle()\">Toggle</div>\n      <div [hidden]=\"!visible\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  `,\n})\nexport class ZippyComponent {\n  visible = true;\n  @Output() open = new EventEmitter<any>();\n  @Output() close = new EventEmitter<any>();\n\n  toggle() {\n    this.visible = !this.visible;\n    if (this.visible) {\n      this.open.emit(null);\n    } else {\n      this.close.emit(null);\n    }\n  }\n}\n```\n\n### HTTP\n\n**Angular’s HttpClient returns observables from HTTP method calls**. For instance, ```http.get(‘/api’)``` returns an observable. This provides **several advantages over promise-based HTTP APIs**:\n\n- Observables **do not mutate the server response** (as can occur through chained .then() calls on promises). Instead, you can use a series of **operators to transform values** as needed.\n- HTTP requests are **cancellable** through the unsubscribe() method.\n- Requests can be configured to **get progress event updates**.\n- **Failed requests can be retried easily**.\n\n### Async pipe\n\n**The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted**. When a new value is emitted, the pipe marks the component to be checked for changes.\n\nThe following example binds the time observable to the component's view. The observable continuously updates the view with the current time.\n\n```\n@Component({\n  selector: 'async-observable-pipe',\n  template: `<div><code>observable|async</code>:\n       Time: {{ time | async }}</div>`\n})\nexport class AsyncObservablePipeComponent {\n  time = new Observable<string>(observer => {\n    setInterval(() => observer.next(new Date().toString()), 1000);\n  });\n}\n```\n\n### Router\n\n**Router.events** provides **events as observables**. You can use the ```filter()``` operator from **RxJS** to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process. Here's an example:\n\n```\nimport { Router, NavigationStart } from '@angular/router';\nimport { filter } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable1Component implements OnInit {\n\n  navStart: Observable<NavigationStart>;\n\n  constructor(private router: Router) {\n    // Create a new Observable that publishes only the NavigationStart event\n    this.navStart = router.events.pipe(\n      filter(evt => evt instanceof NavigationStart)\n    ) as Observable<NavigationStart>;\n  }\n\n  ngOnInit() {\n    this.navStart.subscribe(evt => console.log('Navigation Started!'));\n  }\n}\n```\n\nThe **ActivatedRoute** is an injected router service that makes use of observables to get information about a route path and parameters. For example, ActivatedRoute.url contains an observable that reports the route path or paths. Here's an example:\n\n```\nimport { ActivatedRoute } from '@angular/router';\n\n@Component({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable2Component implements OnInit {\n  constructor(private activatedRoute: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.activatedRoute.url\n      .subscribe(url => console.log('The URL changed to: ' + url));\n  }\n}\n```\n\n### Reactive forms\n\n**Reactive forms have properties that use observables to monitor form control values**. The **FormControl** properties **valueChanges** and **statusChanges** contain observables that raise **change events**. Subscribing to an observable form-control property **is a way of triggering application logic within the component class**. For example:\n```\nimport { FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'my-component',\n  template: 'MyComponent Template'\n})\nexport class MyComponent implements OnInit {\n  nameChangeLog: string[] = [];\n  heroForm: FormGroup;\n\n  ngOnInit() {\n    this.logNameChange();\n  }\n  logNameChange() {\n    const nameControl = this.heroForm.get('name');\n    nameControl.valueChanges.forEach(\n      (value: string) => this.nameChangeLog.push(value)\n    );\n  }\n}\n```\n\n\n","references":"- [Angular.io Observables](https://angular.io/guide/observables-in-angular)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-observables","weblink":"https://codersnack.com/angular-observables","featured_image_preview":{"id":123,"name":"angular-icon.png","hash":"7cb94f9a2140470686ef7b74af452dbd","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb94f9a2140470686ef7b74af452dbd.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T16:02:37.408Z","updated_at":"2021-04-11T16:02:37.408Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Observables","created_at":"2021-04-11T16:33:33.694Z","updated_at":"2021-04-11T16:33:33.697Z"},{"id":91,"codersnack":{"id":92,"header":"Angular - Forms Overview","created_at":"2021-04-11T16:33:05.489Z","updated_at":"2021-04-11T16:33:05.489Z","explanation":"Angular provides **two different approaches** to handling user input through forms: **reactive and template-driven**. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.\n\nThis guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.\n\n\n### Choosing an approach\n\nReactive forms and template-driven forms **process and manage form data differently**. Each approach offers different advantages.\n\n**Reactive forms provide direct, explicit access to the underlying forms object model**. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.\n\n**Template-driven forms rely on directives in the template to create and manipulate the underlying object model**. They are useful for adding a simple form to an app, such as an email list signup form. They're easy to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit.\n\n### Key differences\nThe table below summarizes the key differences between reactive and template-driven forms.\n\n- Setup of form model: REACTIVE: Explicit, created in component class\tTEMPLATE-DRIVEN: Implicit, created by directives\n- Data model:\t REACTIVE: Structured and immutable\tTEMPLATE-DRIVEN: Unstructured and mutable\n- Predictability: REACTIVE: \tSynchronous\tTEMPLATE-DRIVEN:  Asynchronous\n- Form validations: REACTIVE:  Functions\tTEMPLATE-DRIVEN:  Directives\n\n### Scalability\nIf forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical.\n\nReactive forms are more scalable than template-driven forms. They provide direct access to the underlying form API, and synchronous access to the form data model, making creating large-scale forms easier. Reactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation.\n\nTemplate-driven forms focus on simple scenarios and are not as reusable. They abstract away the underlying form API, and provide only asynchronous access to the form data model. The abstraction of template-driven forms also affects testing. Tests are deeply reliant on manual change detection execution to run properly, and require more setup.\n\n### Setting up the form model\nBoth reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.\n\n#### Common form foundation classes\nBoth reactive and template-driven forms are built on the following base classes.\n\n- **FormControl** tracks the value and validation status of an individual form control.\n\n- **FormGroup** tracks the same values and status for a collection of form controls.\n\n- **FormArray** tracks the same values and status for an array of form controls.\n\n- **ControlValueAccessor** creates a **bridge between Angular FormControl instances and native DOM elements**.\n\n#### Setup in reactive forms\nWith reactive forms, you define the form model directly in the component class. The ```[formControl]``` directive links the explicitly created **FormControl** instance to a specific form element in the view, using an internal value accessor.\n\nThe following component implements an input field for a single control, using reactive forms. In this example, the form model is the FormControl instance.\n\n```\n\rimport { Component } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}\n```\n\nFigure 1 shows how, in reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the ```[formControl]``` directive on the input element.\n\nFigure 1. Direct access to forms model in a reactive form.\n![angular reative forms form model](https://codersnack.com/assets/images/angular-reactive-forms-form-model.png)\n\n#### Setup in template-driven forms\nIn template-driven forms, the form model is implicit, rather than explicit. The directive **NgModel** creates and manages a **FormControl** instance for a given form element.\n\nThe following component implements the same input field for a single control, using template-driven forms.\n\n```\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n```\n![angular template driven forms form model](https://codersnack.com/assets/images/angular-template-driven-forms-form-model.png)\n\n\n","references":"- [Angular.io Reactive Forms](https://angular.io/guide/forms-overview)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-forms-overview","weblink":"https://codersnack.com/angular-forms-overview","featured_image_preview":{"id":124,"name":"angular-icon.png","hash":"fb4b660af51e467585f8f489b6dc1778","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/fb4b660af51e467585f8f489b6dc1778.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T16:33:05.501Z","updated_at":"2021-04-11T16:33:05.501Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Forms overview","created_at":"2021-04-11T16:34:05.963Z","updated_at":"2021-04-11T16:34:05.966Z"}]