[{"id":81,"codersnack":{"id":82,"header":"What is Angular?","created_at":"2020-06-15T09:44:23.825Z","updated_at":"2020-06-16T21:21:09.533Z","explanation":"**Angular is a platform and framework for building single-page client applications using HTML and TypeScript**. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps.\n\nThe architecture of an Angular application relies on certain fundamental concepts. The basic building blocks are **NgModules**, which provide **a compilation context for components**. NgModules collect related code into functional sets; **an Angular app is defined by a set of NgModules**. An app always has at least a root module that enables bootstrapping, and typically has many more feature modules.\n\n**Components define views**, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.\n\n**Components use services**, which provide specific functionality not directly related to views. Service providers can be injected into components as dependencies, making your code modular, reusable, and efficient.\n\n**Both components and services are simply classes, with decorators** that mark their type and provide metadata that tells Angular how to use them.\n\nThe metadata for a component class associates it with a template that defines a view. A template combines ordinary HTML with Angular directives and binding markup that allow Angular to modify the HTML before rendering it for display.\n\n> The metadata for a service class provides the information Angular needs to make it available to components through **dependency injection (DI)**.\n\nAn app's components typically define many views, arranged hierarchically. Angular provides the **Router service** to help you define navigation paths among views. The router provides sophisticated in-browser navigational capabilities.\n\n\n## Modules\n\n*Angular NgModules differ from and complement JavaScript (ES2015) modules*. **An NgModule declares a compilation context for a set of components that is dedicated to an application domain**, a workflow, or a closely related set of capabilities. An NgModule can associate its components with related code, such as services, to form functional units.\n\n**Every Angular app has a root module, conventionally named AppModule**, which provides the bootstrap mechanism that launches the application. An app typically contains many functional modules.\n\n**Like JavaScript modules, NgModules can import functionality from other NgModules**, and allow their own functionality to be exported and used by other NgModules. For example, to use the router service in your app, you import the Router NgModule.\n\n> Organizing your code into distinct functional modules helps in managing development of complex applications, and in designing for reusability. In addition, this technique lets you take advantage of lazy-loading, that is, loading modules on demand, to minimize the amount of code that needs to be loaded at startup.\n\n\n## Components\n\n**Every Angular application has at least one component, the root component that connects a component hierarchy with the page document object model (DOM)**. Each component defines a class that contains application data and logic, and is associated with an HTML template that defines a view to be displayed in a target environment.\n\nThe **@Component() decorator** identifies the class immediately below it as a component, and provides the template and related component-specific metadata.\n\n**Decorators are functions that modify JavaScript classes**. Angular defines a number of decorators that attach specific kinds of metadata to classes, so that the system knows what those classes mean and how they should work.\n\n\n\n## Templates, directives, and data binding\n\n**A template combines HTML with Angular markup that can modify HTML elements before they are displayed**. *Template directives provide program logic, and binding markup connects your application data and the DOM*. There are two types of data binding:\n\n- **Event binding** lets your app respond to user input in the target environment by updating your application data.\n- **Property binding** lets you interpolate values that are computed from your application data into the HTML.\n\nBefore a view is displayed, Angular evaluates the directives and resolves the binding syntax in the template to modify the HTML elements and the DOM, according to your program data and logic. Angular supports **two-way data binding**, meaning that changes in the DOM, such as user choices, are also reflected in your program data.\n\nYour templates can use **pipes to improve the user experience by transforming values for display**. For example, use pipes to display dates and currency values that are appropriate for a user's locale. Angular provides predefined pipes for common transformations, and you can also define your own pipes.\n\n\n## Services and dependency injection\n\n**For data or logic that isn't associated with a specific view, and that you want to share across components, you create a service class**. A service class definition is immediately preceded by the **@Injectable() decorator.** The decorator provides the metadata that allows other providers to be injected as dependencies into your class.\n\nDependency injection (DI) lets you keep your component classes lean and efficient. They don't fetch data from the server, validate user input, or log directly to the console; they delegate such tasks to services.\n\n## Routing\n\nThe Angular Router NgModule provides a service that lets you define a navigation path among the different application states and view hierarchies in your app. It is modeled on the familiar browser navigation conventions:\n\n- **Enter a URL in the address bar** and the browser navigates to a corresponding page.\n\n- **Click links** on the page and the browser navigates to a new page.\n\n- **Click the browser's back** and forward buttons and the browser navigates backward and forward through the history of pages you've seen.\n\n**The router maps URL-like paths to views instead of pages**. When a user performs an action, such as clicking a link, that would load a new page in the browser, the router intercepts the browser's behavior, and shows or hides view hierarchies.\n\nIf the router determines that the current application state requires particular functionality, and the module that defines it hasn't been loaded, the **router can lazy-load the module on demand.**\n\nThe router interprets a link URL according to your app's view navigation rules and data state. You can navigate to new views when the user clicks a button or selects from a drop box, or in response to some other stimulus from any source. **The router logs activity in the browser's history, so the back and forward buttons work as well**.\n\nTo define navigation rules, you associate navigation paths with your components. A path uses a URL-like syntax that integrates your program data, in much the same way that template syntax integrates your views with your program data. You can then apply program logic to choose which views to show or to hide, in response to user input and your own access rules.\n\n\n![angular overview](https://codersnack.com/assets/images/angular-overview2.png)\n\n\n- A decorator on a component class adds the metadata, including a pointer to the associated template.\n- Directives and binding markup in a component's template modify views based on program data and logic.\n- The dependency injector provides services to a component, such as the router service that lets you define navigation among views.\n","references":"- [Angular.io Architecture](https://angular.io/guide/architecture)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-what-is","weblink":"https://codersnack.com/angular-what-is","featured_image_preview":{"id":112,"name":"angular-icon.png","hash":"dfe02d1bea914ebd87a76c38b95ea20d","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/dfe02d1bea914ebd87a76c38b95ea20d.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T09:44:23.836Z","updated_at":"2020-06-15T09:44:23.836Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular What is","created_at":"2020-06-15T09:44:44.777Z","updated_at":"2020-06-15T09:44:44.780Z"},{"id":82,"codersnack":{"id":83,"header":"Angular Data Biding and Pipes and Directives","created_at":"2020-06-15T17:04:11.159Z","updated_at":"2020-06-16T21:03:05.124Z","explanation":"## Data binding\n\n**Without a framework, you would be responsible for pushing data values into the HTML controls** and turning user responses into actions and value updates. Writing such push and pull logic by hand is tedious, error-prone, and a nightmare to read, as any experienced front-end JavaScript programmer can attest.\n\n**Angular supports two-way data binding**, a mechanism for coordinating the parts of a template with the parts of a component. Add binding markup to the template HTML to tell Angular how to connect both sides.\n\nThe following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both.\n\n![angular databinding](https://codersnack.com/assets/images/angular-databinding.png)\n\nThis example from the HeroListComponent template uses three of these forms.\n\n*src/app/hero-list.component.html (binding)*\n```\n<li>{{hero.name}}</li>\n<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>\n<li (click)=\"selectHero(hero)\"></li>\n```\n\nThe ``` {{hero.name}} ``` interpolation displays the component's *hero.name* property value within the ``` <li> ``` element.\n\nThe ```[hero]``` property binding passes the value of *selectedHero* from the parent *HeroListComponent* to the *hero* property of the child *HeroDetailComponent*.\n\nThe ```(click)``` event binding calls the component's *selectHero* method when the user clicks a hero's name.\n\n**Two-way data binding (used mainly in template-driven forms) combines property and event binding in a single notation**. Here's an example from the *HeroDetailComponent* template that uses two-way data binding with the *ngModel directive*.\n\n*src/app/hero-detail.component.html (ngModel)*\n```\n<input [(ngModel)]=\"hero.name\">\n```\nIn two-way binding, a data property value flows to the input box from the component as with property binding. The user's changes also flow back to the component, resetting the property to the latest value, as with event binding.\n\n> Angular processes all data bindings once for each JavaScript event cycle, from the root of the application component tree through all child components.\n\n\nData binding plays an important role in communication between a template and its component, and is also important for communication between parent and child components.\n\n## Pipes\n\n**Angular pipes let you declare display-value transformations in your template HTML**. A class with the **@Pipe decorator** defines a function that transforms input values to output values for display in a view.\n\n**Angular defines various pipes**, such as the date pipe and currency pipe; for a complete list, see the Pipes API list. You can also define new pipes.\n\nTo specify a value transformation in an HTML template, use the **pipe operator (|)**.\n```\n{{interpolated_value | pipe_name}}\n```\n\n**You can chain pipes**, sending the output of one pipe function to be transformed by another pipe function. **A pipe can also take arguments** that control how it performs its transformation. For example, you can pass the desired format to the date pipe.\n\n\n\n## Directives\n\nAngular templates are dynamic. **When Angular renders them, it transforms the DOM according to the instructions given by directives**. **A directive is a class with a @Directive() decorator**.\n\n> A component is technically a directive. However, components are so distinctive and central to Angular applications that Angular defines the **@Component()** decorator, which extends the **@Directive()** decorator with template-oriented features.\n\n**In addition to components, there are two other kinds of directives: structural and attribute**. Angular defines a number of directives of both kinds, and you can define your own using the **@Directive()** decorator.\n\nJust as for components, the metadata for a directive associates the decorated class with a selector element that you use to insert it into HTML. In templates, directives typically appear within an element tag as attributes, either by name or as the target of an assignment or a binding.\n\n### Structural directives\n\n**Structural directives alter layout by adding, removing, and replacing elements in the DOM**. The example template uses two built-in structural directives to add application logic to how the view is rendered.\n\n*src/app/hero-list.component.html (structural)*\n```\n<li *ngFor=\"let hero of heroes\"></li>\n<app-hero-detail *ngIf=\"selectedHero\"></app-hero-detail>\n```\n\n``` *ngFor ``` is an **iterative**:  it tells Angular to stamp out one ``` <li> ``` per hero in the heroes list.\n``` *ngIf ``` is a **conditional**: it includes the *HeroDetail* component only if a selected hero exists.\n\n### Attribute directives\n\n**Attribute directives alter the appearance or behavior of an existing element**. In templates they look like regular HTML attributes, hence the name.\n\nThe **ngModel** directive, which implements two-way data binding, is an example of an attribute directive. ngModel modifies the behavior of an existing element (typically ```<input>```) by setting its display value property and responding to change events.\n\n*src/app/hero-detail.component.html (ngModel)*\n```\n<input [(ngModel)]=\"hero.name\">\n```\n**Angular has more pre-defined directives** that either alter the layout structure (for example, ngSwitch) or modify aspects of DOM elements and components (for example, ngStyle and ngClass).\n\n","references":"- [Angular.io Architecture Components](https://angular.io/guide/architecture-components)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-data-binding-pipes-directives","weblink":"https://codersnack.com/angular-data-binding-pipes-directives","featured_image_preview":{"id":113,"name":"angular-icon.png","hash":"95a0b7ed921145449b6a97243a0ed410","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/95a0b7ed921145449b6a97243a0ed410.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T17:04:11.173Z","updated_at":"2020-06-15T17:04:11.173Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Data Binding & Pipes & Directives","created_at":"2020-06-15T17:04:59.993Z","updated_at":"2020-06-15T17:04:59.999Z"},{"id":90,"codersnack":{"id":91,"header":"Angular - Observables","created_at":"2021-04-11T16:02:37.392Z","updated_at":"2021-11-10T11:56:49.923Z","explanation":"\nAngular makes use of **observables as an interface to handle a variety of common asynchronous operations**. For example:\n- You can define **custom events** that send observable output data from a child to a parent component.\n- The HTTP module uses observables to **handle AJAX requests and responses**.\n- The **Router and Forms modules use observables** to listen for and respond to user-input events.\n\n### Transmitting data between components\n\nAngular provides an **EventEmitter** class that is used when publishing values from a component through the** ```@Output()```** decorator. \n\nEventEmitter extends **RxJS Subject**, adding an **emit()** method so it can send arbitrary values. When you call **emit()**, it passes the emitted value to the **next()** method of any **subscribed observer**.\n\nA good example of usage can be found in the EventEmitter documentation. Here is the example component that listens for open and close events:\n```\n<app-zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></app-zippy>\n```\n\nHere is the component definition:\n\n**ZippyComponent**\n```\n@Component({\n  selector: 'app-zippy',\n  template: `\n    <div class=\"zippy\">\n      <div (click)=\"toggle()\">Toggle</div>\n      <div [hidden]=\"!visible\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  `,\n})\nexport class ZippyComponent {\n  visible = true;\n  @Output() open = new EventEmitter<any>();\n  @Output() close = new EventEmitter<any>();\n\n  toggle() {\n    this.visible = !this.visible;\n    if (this.visible) {\n      this.open.emit(null);\n    } else {\n      this.close.emit(null);\n    }\n  }\n}\n```\n\n### HTTP\n\n\n**Angular’s HttpClient returns observables from HTTP method calls**. For instance, ```http.get(‘/api’)``` returns an observable. This provides **several advantages over promise-based HTTP APIs**:\n\n- Observables **do not mutate the server response** (as can occur through chained .then() calls on promises). Instead, you can use a series of **operators to transform values** as needed.\n- HTTP requests are **cancellable** through the unsubscribe() method.\n- Requests can be configured to **get progress event updates**.\n- **Failed requests can be retried easily**.\n\n### Async pipe\n\n**The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted**. When a new value is emitted, the pipe marks the component to be checked for changes.\n\nThe following example binds the time observable to the component's view. The observable continuously updates the view with the current time.\n\n```\n@Component({\n  selector: 'async-observable-pipe',\n  template: `<div><code>observable|async</code>:\n       Time: {{ time | async }}</div>`\n})\nexport class AsyncObservablePipeComponent {\n  time = new Observable<string>(observer => {\n    setInterval(() => observer.next(new Date().toString()), 1000);\n  });\n}\n```\n\n### Router\n\n**Router.events** provides **events as observables**. You can use the ```filter()``` operator from **RxJS** to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process. Here's an example:\n\n```\nimport { Router, NavigationStart } from '@angular/router';\nimport { filter } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable1Component implements OnInit {\n\n  navStart: Observable<NavigationStart>;\n\n  constructor(private router: Router) {\n    // Create a new Observable that publishes only the NavigationStart event\n    this.navStart = router.events.pipe(\n      filter(evt => evt instanceof NavigationStart)\n    ) as Observable<NavigationStart>;\n  }\n\n  ngOnInit() {\n    this.navStart.subscribe(evt => console.log('Navigation Started!'));\n  }\n}\n```\n\nThe **ActivatedRoute** is an injected router service that makes use of observables to get information about a route path and parameters. For example, ActivatedRoute.url contains an observable that reports the route path or paths. Here's an example:\n\n```\nimport { ActivatedRoute } from '@angular/router';\n\n@Component({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable2Component implements OnInit {\n  constructor(private activatedRoute: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.activatedRoute.url\n      .subscribe(url => console.log('The URL changed to: ' + url));\n  }\n}\n```\n\n### Reactive forms\n\n**Reactive forms have properties that use observables to monitor form control values**. The **FormControl** properties **valueChanges** and **statusChanges** contain observables that raise **change events**. Subscribing to an observable form-control property **is a way of triggering application logic within the component class**. For example:\n```\nimport { FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'my-component',\n  template: 'MyComponent Template'\n})\nexport class MyComponent implements OnInit {\n  nameChangeLog: string[] = [];\n  heroForm: FormGroup;\n\n  ngOnInit() {\n    this.logNameChange();\n  }\n  logNameChange() {\n    const nameControl = this.heroForm.get('name');\n    nameControl.valueChanges.forEach(\n      (value: string) => this.nameChangeLog.push(value)\n    );\n  }\n}\n```\n\n\n","references":"- [Angular.io Observables](https://angular.io/guide/observables-in-angular)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-observables","weblink":"https://codersnack.com/angular-observables","featured_image_preview":{"id":123,"name":"angular-icon.png","hash":"7cb94f9a2140470686ef7b74af452dbd","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb94f9a2140470686ef7b74af452dbd.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T16:02:37.408Z","updated_at":"2021-04-11T16:02:37.408Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Observables","created_at":"2021-04-11T16:33:33.694Z","updated_at":"2021-04-11T16:33:33.697Z"},{"id":91,"codersnack":{"id":92,"header":"Angular - Forms Overview","created_at":"2021-04-11T16:33:05.489Z","updated_at":"2021-04-11T17:03:51.107Z","explanation":"Angular provides **two different approaches** to handling user input through forms: **reactive and template-driven**. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.\n\nThis guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.\n\n\n### Choosing an approach\n\nReactive forms and template-driven forms **process and manage form data differently**. Each approach offers different advantages.\n\n**Reactive forms provide direct, explicit access to the underlying forms object model**. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.\n\n**Template-driven forms rely on directives in the template to create and manipulate the underlying object model**. They are useful for adding a simple form to an app, such as an email list signup form. They're easy to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit.\n\n### Key differences\nThe table below summarizes the key differences between reactive and template-driven forms.\n\n- Setup of form model: REACTIVE: Explicit, created in component class\tTEMPLATE-DRIVEN: Implicit, created by directives\n- Data model:\t REACTIVE: Structured and immutable\tTEMPLATE-DRIVEN: Unstructured and mutable\n- Predictability: REACTIVE: \tSynchronous\tTEMPLATE-DRIVEN:  Asynchronous\n- Form validations: REACTIVE:  Functions\tTEMPLATE-DRIVEN:  Directives\n\n### Scalability\nIf forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical.\n\nReactive forms are more scalable than template-driven forms. They provide direct access to the underlying form API, and synchronous access to the form data model, making creating large-scale forms easier. Reactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation.\n\nTemplate-driven forms focus on simple scenarios and are not as reusable. They abstract away the underlying form API, and provide only asynchronous access to the form data model. The abstraction of template-driven forms also affects testing. Tests are deeply reliant on manual change detection execution to run properly, and require more setup.\n\n### Setting up the form model\nBoth reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.\n\n#### Common form foundation classes\nBoth reactive and template-driven forms are built on the following base classes.\n\n- **FormControl** tracks the value and validation status of an individual form control.\n\n- **FormGroup** tracks the same values and status for a collection of form controls.\n\n- **FormArray** tracks the same values and status for an array of form controls.\n\n- **ControlValueAccessor** creates a **bridge between Angular FormControl instances and native DOM elements**.\n\n#### Setup in reactive forms\nWith reactive forms, you define the form model directly in the component class. The ```[formControl]``` directive links the explicitly created **FormControl** instance to a specific form element in the view, using an internal value accessor.\n\nThe following component implements an input field for a single control, using reactive forms. In this example, the form model is the FormControl instance.\n\n```\n\rimport { Component } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}\n```\n\nFigure 1 shows how, in reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the ```[formControl]``` directive on the input element.\n\nFigure 1. Direct access to forms model in a reactive form.\n![angular reative forms form model](https://codersnack.com/assets/images/angular-reactive-forms-form-model.png)\n\n#### Setup in template-driven forms\nIn template-driven forms, the form model is implicit, rather than explicit. The directive **NgModel** creates and manages a **FormControl** instance for a given form element.\n\nThe following component implements the same input field for a single control, using template-driven forms.\n\n```\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n```\n![angular template driven forms form model](https://codersnack.com/assets/images/angular-template-driven-forms-form-model.png)\n\n\n","references":"- [Angular.io Forms Overview](https://angular.io/guide/forms-overview)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-forms-overview","weblink":"https://codersnack.com/angular-forms-overview","featured_image_preview":{"id":124,"name":"angular-icon.png","hash":"fb4b660af51e467585f8f489b6dc1778","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/fb4b660af51e467585f8f489b6dc1778.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T16:33:05.501Z","updated_at":"2021-04-11T16:33:05.501Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Forms overview","created_at":"2021-04-11T16:34:05.963Z","updated_at":"2021-04-11T16:34:05.966Z"},{"id":92,"codersnack":{"id":93,"header":"Angular - Forms Overview II","created_at":"2021-04-11T17:42:45.795Z","updated_at":"2021-04-11T17:42:45.795Z","explanation":"### Data flow in reactive forms\nIn reactive forms each form element in the view is directly linked to the form model (a FormControl instance). **Updates from the view to the model and from the model to the view are synchronous** and do not depend on how the UI is rendered.\n\nThe **view-to-model diagram** shows **how data flows when an input field's value is changed** from the view through the following steps.\n\n- The **user types a value** into the input element, in this case the favorite color Blue.\n- The **form input element emits an \"input\" event** with the latest value.\n- The **control value accessor listening for events** on the form input element immediately relays the new value to the **FormControl** instance.\n- The **FormControl instance emits the new value through the valueChanges observable**.\n- Any **subscribers to the valueChanges observable receive the new value**.\n\n![angular dataflow reactive forms view to model](https://codersnack.com/assets/images/angular-dataflow-reactive-forms-vtm.png)\n\nThe **model-to-view diagram** shows how a programmatic change to the model is propagated to the view through the following steps.\n\n- The user calls the ```favoriteColorControl.setValue()``` method, which updates the **FormControl** value.\n- The **FormControl** instance **emits the new value through the valueChanges observable**.\n- Any **subscribers** to the **valueChanges** observable receive the new value.\n- The **control value accessor on the form input element updates the element with the new value**.\n\n![angular dataflow reactive forms model to view](https://codersnack.com/assets/images/angular-dataflow-reactive-forms-mtv.png)\n\n### Data flow in template-driven forms\nIn template-driven forms, **each form element is linked to a directive that manages the form model internally**.\n\nThe **view-to-model** diagram shows how data flows when an input field's value is changed from the view through the following steps.\n\n- The **user types** Blue into the input element.\n- The **input element emits an \"input\" event** with the value Blue.\n- The **control value accessor** attached to the input triggers the ```setValue()``` method on the **FormControl** instance.\n- The **FormControl** instance **emits** the new value through the **valueChanges** observable.\n- Any **subscribers** to the **valueChanges** observable receive the new value.\n- The **control value accessor** also calls the ```NgModel.viewToModelUpdate()``` method which emits an **ngModelChange event**.\n- Because the **component template uses two-way data binding** for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the **ngModelChange** event (Blue).\n\n![angular dataflow template driven forms - view to model](https://codersnack.com/assets/images/angular-dataflow-td-forms-vtm.png)\n\nThe **model-to-view diagram** shows how data flows from model to view when the favoriteColor changes from Blue to Red, through the following steps\n\n- The favoriteColor **value is updated in the component**.\n- Change detection begins.\n- During change detection, the **ngOnChanges** lifecycle hook is called on the **NgModel** directive instance because the value of one of its inputs has changed.\n- The **ngOnChanges()** method queues an **async task** to set the value for the internal **FormControl** instance.\n- Change detection completes.\n- On the **next tick**, the task to set the **FormControl instance value is executed**.\n- The **FormControl** instance **emits the latest value through the valueChanges observable**.\n- Any **subscribers** to the **valueChanges** observable receive the new value.\n- The **control value accessor updates the form input element in the view** with the latest favoriteColor value.\n\n![angular dataflow template driven forms - model to view](https://codersnack.com/assets/images/angular-dataflow-td-forms-mtv.png)\n\n### Mutability of the data model\n\nThe change-tracking method plays a role in the **efficiency of your application**.\n\n**Reactive forms keep the data model pure by providing it as an immutable data structure**. Each time a change is triggered on the data model, the **FormControl** instance **returns a new data model** rather than updating the existing data model. This gives you the **ability to track unique changes** to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data.\n\n**Template-driven forms rely on mutability with two-way data binding** to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, **change detection is less efficient** at determining when updates are required.\n\nThe difference is demonstrated in the previous examples that use the favorite-color input element.\n\n- With reactive forms, the FormControl instance always returns a new value when the control's value is updated.\n\n- With template-driven forms, the favorite color property is always modified to its new value.\n\n### Form validation\n\nValidation is an integral part of managing any set of forms. Whether you're checking for required fields or querying an external API for an existing username, **Angular provides a set of built-in validators as well as the ability to create custom validators**.\n\n- Reactive forms define custom validators as functions that receive a control to validate.\n- Template-driven forms are tied to template directives, and must provide custom validator directives that wrap validation functions.\nFor more information, see Form Validation.\n\n### Testing\n\nTesting plays a large part in complex applications. A simpler testing strategy is useful when validating that your forms function correctly. Reactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms.\n\n#### Testing reactive forms\n**Reactive forms provide a relatively easy testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI**. In these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle.\n\nThe following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form.\n\nThe first example performs the following steps to verify the **view-to-model data flow**.\n\nQuery the view for the form input element, and create a custom \"input\" event for the test.\nSet the new value for the input to Red, and dispatch the \"input\" event on the form input element.\nAssert that the component's favoriteColorControl value matches the value from the input.\n\n```\nit('should update the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});\n```\n\nThe next example performs the following steps to verify the **model-to-view data flow.**\n\nUse the favoriteColorControl, a FormControl instance, to set the new value.\nQuery the view for the form input element.\nAssert that the new value set on the control matches the value in the input.\n\n```\nit('should update the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});\n```\n#### Testing template-driven forms\n\n**Writing tests with template-driven forms requires a detailed knowledge of the change detection process** and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.\n\nThe following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form.\n\nThe following test verifies the data flow from view to model.\n\n```\n\rit('should update the favorite color in the component', fakeAsync(() => {\n     const input = fixture.nativeElement.querySelector('input');\n     const event = createNewEvent('input');\n\n     input.value = 'Red';\n     input.dispatchEvent(event);\n\n     fixture.detectChanges();\n\n     expect(component.favoriteColor).toEqual('Red');\n   }));\n```\nHere are the steps performed in the view to model test.\n\n- Query the view for the form input element, and create a custom \"input\" event for the test.\n- Set the new value for the input to Red, and dispatch the \"input\" event on the form input element.\n- **Run change detection through the test fixture**.\n- Assert that the component favoriteColor property value matches the value from the input.\n\nThe following test verifies the data flow from model to view.\n\n```\nit('should update the favorite color on the input field', fakeAsync(() => {\n     component.favoriteColor = 'Blue';\n\n     fixture.detectChanges();\n\n     tick();\n\n     const input = fixture.nativeElement.querySelector('input');\n\n     expect(input.value).toBe('Blue');\n   }));\n```\n\nHere are the steps performed in the model to view test.\n\n- Use the component instance to set the value of the favoriteColor property.\n- Run change detection through the test fixture.\n- Use the **tick() method to simulate the passage of time within the fakeAsync() task.**\n- Query the view for the form input element.\n- Assert that the input value matches the value of the favoriteColor property in the component instance.\n","references":"- [Angular.io Forms Overview](https://angular.io/guide/forms-overview)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-forms-overview-2","weblink":"https://codersnack.com/angular-forms-overview-2","featured_image_preview":{"id":125,"name":"angular-icon.png","hash":"2ba0c1b38be44e0db8dad4040990481d","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/2ba0c1b38be44e0db8dad4040990481d.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T17:42:45.804Z","updated_at":"2021-04-11T17:42:45.804Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Forms Overview II","created_at":"2021-04-11T17:43:07.674Z","updated_at":"2021-04-11T17:43:07.690Z"},{"id":93,"codersnack":{"id":94,"header":"Angular - Reactive Forms","created_at":"2021-04-11T21:22:33.826Z","updated_at":"2021-04-11T21:25:32.590Z","explanation":"Reactive forms provide a model-driven approach to handling form inputs whose values change over time. This guide shows you how to create and update a basic form control, progress to using multiple controls in a group, validate form values, and create dynamic forms where you can add or remove controls at run time.\n\n### Overview of reactive forms\n\n**Reactive forms use an explicit and immutable approach to managing the state of a form** at a given point in time. Each change to the form state returns a new state, which maintains the integrity of the model between changes. **Reactive forms are built around observable streams**, where form inputs and values are provided as streams of input values, which can be accessed synchronously.\n\n**Reactive forms also provide a straightforward path to testing** because you are assured that your data is consistent and predictable when requested. Any consumers of the streams have access to manipulate that data safely.\n\nReactive forms differ from template-driven forms in distinct ways. Reactive forms provide more predictability with synchronous access to the data model, immutability with observable operators, and change tracking through observable streams.\n\nTemplate-driven forms allow direct access to modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously.\n\n### Adding a basic form control\n\nThere are three steps to using form controls.\n\n- **Register the reactive forms module** in your app. This module declares the reactive-form directives that you need to use reactive forms.\n- **Generate** a new **FormControl** instance and save it in the component.\n- **Register** the **FormControl** in the template.\n\nYou can then display the form by adding the component to the template.\n\nThe following examples show how to add a single form control. In the example, the user enters their name into an input field, captures that input value, and displays the current value of the form control element.\n\n**Register the reactive forms module**\n\nTo use reactive form controls, **import ReactiveFormsModul**e from the **@angular/forms** package and add it to your **NgModule's** imports array.\n\n**app.module.ts**\n```\nimport { ReactiveFormsModule } from '@angular/forms';\n\n@NgModule({\n  imports: [\n    // other imports ...\n    ReactiveFormsModule\n  ],\n})\nexport class AppModule { }\n```\n\n**Generate a new FormControl**\n\nUse the CLI command ng generate to generate a component in your project to host the control.\n\n```\nng generate component NameEditor\n```\nTo register a single form control, **import** the **FormControl** class and **create a new instance of FormControl** to save as a class property.\n\n**src/app/name-editor/name-editor.component.ts**\n\n```\nimport { Component } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.css']\n})\nexport class NameEditorComponent {\n  name = new FormControl('');\n}\n```\n\n**Use the constructor of FormControl to set its initial value**, which in this case is an empty string. By creating these controls in your component class, you get immediate access to listen for, update, and validate the state of the form input.\n\n**Register the control in the template**\n\nAfter you create the control in the component class, **you must associate it with a form control element in the template**. Update the template with the form control using the **formControl binding** provided by **FormControlDirective**, which is also included in the **ReactiveFormsModule**.\n\n**src/app/name-editor/name-editor.component.html**\n\n```\n<label>\n  Name:\n  <input type=\"text\" [formControl]=\"name\">\n</label>\n```\n\nUsing the template binding syntax, **the form control is now registered** to the name input element in the template. **The form control and DOM element communicate with each other**: the view reflects changes in the model, and the model reflects changes in the view.\n\n**Display the component**\n\nThe form control assigned to name is displayed when the component is added to a template.\n\n**src/app/app.component.html (name editor)**\n\n```\n<app-name-editor></app-name-editor>\n```\n\n### Displaying a form control value\n\nYou can display the value in the following ways.\n\nThrough the **valueChanges observable** where you can listen for changes in the form's value in the template using **AsyncPipe** or in the component class using the **subscribe() method**.\n\nWith the value property, which gives you a snapshot of the current value.\n\nThe following example shows you how to display the current value using interpolation in the template.\n\nsrc/app/name-editor/name-editor.component.html (control value)\n\n```\n<p>\n  Value: {{ name.value }}\n</p>\n```\nThe displayed value changes as you update the form control element.\n\nReactive forms provide access to information about a given control through properties and methods provided with each instance. These properties and methods of the underlying **AbstractControl** class are used to control form state and determine when to display messages when handling input validation.\n\nRead about other FormControl properties and methods in the API Reference.\n\n### Replacing a form control value\n\nReactive forms have methods to change a control's value programmatically, which gives you the flexibility to update the value without user interaction. A form control instance provides a ```setValue()```  method that updates the value of the form control and validates the structure of the value provided against the control's structure. For example, when retrieving form data from a backend API or service, use the **setValue()** method to update the control to its new value, replacing the old value entirely.\n\nThe following example adds a method to the component class to update the value of the control to Nancy using the setValue() method.\n\n**src/app/name-editor/name-editor.component.ts (update value)**\n```\nupdateName() {\n  this.name.setValue('Nancy');\n}\n```\nUpdate the template with a button to simulate a name update. When you click the Update Name button, the value entered in the form control element is reflected as its current value.\nsrc/app/name-editor/name-editor.component.html (update value)\n\n```\n<p>\n  <button (click)=\"updateName()\">Update Name</button>\n</p>\n```\n**The form model is the source of truth for the control**, so when you click the button, the value of the input is changed within the component class, overriding its current value.\n\n>Note: In this example, you're using a single control. When using the setValue() method with a form group or form array instance, the value needs to match the structure of the group or array.\n\n\n\n\n\n","references":"- [Angular.io Reactive Forms](https://angular.io/guide/reactive-forms)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-reactive-forms","weblink":"https://codersnack.com/angular-reactive-forms","featured_image_preview":{"id":126,"name":"angular-icon.png","hash":"ba12f1cfa79042b3b21f01c911d505c8","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/ba12f1cfa79042b3b21f01c911d505c8.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T21:22:33.835Z","updated_at":"2021-04-11T21:22:33.835Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Reactive Forms","created_at":"2021-04-11T21:23:06.810Z","updated_at":"2021-04-11T21:23:06.813Z"},{"id":94,"codersnack":{"id":95,"header":"Angular - Reactive Forms - Grouping Form Controls","created_at":"2021-04-11T21:55:02.908Z","updated_at":"2021-04-11T21:55:02.908Z","explanation":"Forms typically contain several related controls. **Reactive forms provide two ways of grouping multiple related controls into a single input form.**\n\n**A form group defines a form with a fixed set of controls that you can manage together**. Form group basics are discussed in this section. You can also nest form groups to create more complex forms.\n\n**A form array defines a dynamic form, where you can add and remove controls at run time**. You can also nest form arrays to create more complex forms. For more about this option, see Creating dynamic forms below.\n\nJust as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single group.\n\nGenerate a ProfileEditor component and import the **FormGroup** and **FormControl** classes from the **@angular/forms package**.\n```\nng generate component ProfileEditor\n```\nTo add a form group to this component, take the following steps.\n\n- Create a FormGroup instance.\n- Associate the FormGroup model and view.\n- Save the form data.\n- Create a FormGroup instance\n\n**Create a property in the component** class named *profileForm* and set the property to a new form group instance. To initialize the form group, provide the constructor with an object of named keys mapped to their control.\n\nFor the profile form, add two form control instances with the names *firstName* and *lastName*.\n\n**src/app/profile-editor/profile-editor.component.ts (form group)**\n```\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css']\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n}\n```\nThe individual form controls are now collected within a group. A **FormGroup** instance provides its model value as an object reduced from the values of each control in the group. A form group instance has the same properties (such as value and untouched) and methods (such as setValue()) as a form control instance.\n\n**Associate the FormGroup model and view**\n\nA form group tracks the status and changes for each of its controls, so if one of the controls changes, the parent control also emits a new status or value change. The model for the group is maintained from its members. After you define the model, you must update the template to reflect the model in the view.\n\n***src/app/profile-editor/profile-editor.component.html (template form group)***\n```\n<form [formGroup]=\"profileForm\">\n  \n  <label>\n    First Name:\n    <input type=\"text\" formControlName=\"firstName\">\n  </label>\n\n  <label>\n    Last Name:\n    <input type=\"text\" formControlName=\"lastName\">\n  </label>\n\n</form>\n```\n\nNote that just as a form group contains a group of controls, the **profileForm FormGroup** is bound to the form element with the FormGroup directive, creating a communication layer between the model and the form containing the inputs. The **formControlName** input provided by the **FormControlName** directive binds each individual input to the form control defined in FormGroup. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value.\n\n**Save form data**\n\nThe ProfileEditor component accepts input from the user, but in a real scenario you want to capture the form value and make available for further processing outside the component. The **FormGroup directive listens for the submit event emitted by the form element and emits an ngSubmit event** that you can bind to a callback function.\n\nAdd an **ngSubmit** event listener to the form tag with the ```onSubmit()``` callback method.\n\n**src/app/profile-editor/profile-editor.component.html (submit event)**\n```\n<form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">\n```\n\nThe **onSubmit()** method in the ProfileEditor component captures the current value of profileForm. Use **EventEmitter** to keep the form encapsulated and to provide the form value outside the component. The following example uses console.warn to log a message to the browser console.\n\n**src/app/profile-editor/profile-editor.component.ts (submit method)**\n```\nonSubmit() {\n  // TODO: Use EventEmitter with form value\n  console.warn(this.profileForm.value);\n}\n```\n\nThe submit event is emitted by the form tag using the native DOM event. You trigger the event by clicking a button with submit type. This allows the user to **press the Enter key to submit** the completed form.\n\nUse a button element to add a button to the bottom of the form to trigger the form submission.\n\nsrc/app/profile-editor/profile-editor.component.html (submit button)\n\n```\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button>\n```\n> Note: The button in the snippet above also has a disabled binding attached to it to disable the button when profileForm is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the Validating form input section.\n\n**Display the component**\n\nTo display the ProfileEditor component that contains the form, add it to a component template.\n\n**src/app/app.component.html (profile editor)**\n```\n<app-profile-editor></app-profile-editor>\n```\nProfileEditor allows you to manage the form control instances for the firstName and lastName controls within the form group instance.\n\n### Creating nested form groups\nForm groups can accept both individual form control instances and other form group instances as children. This makes **composing complex form models easier to maintain and logically group together.**\n\nWhen building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance allows you to break large forms groups into smaller, more manageable ones.\n\nTo make more complex forms, use the following steps.\n\n- Create a nested group.\n- Group the nested form in the template.\n\nSome types of information naturally fall into the same group. A name and address are typical examples of such nested groups, and are used in the following examples.\n\n**Create a nested group**\n\nTo create a nested group in profileForm, add a nested address element to the form group instance.\n\n***src/app/profile-editor/profile-editor.component.ts (nested form group)***\n```\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css']\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl('')\n    })\n  });\n}\n```\n\nIn this example, address group combines the current firstName and lastName controls with the new street, city, state, and zip controls. Even though the address element in the form group is a child of the overall profileForm element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model.\n\n**Group the nested form in the template**\n\nAfter you update the model in the component class, update the template to connect the form group instance and its input elements.\n\nAdd the address form group containing the street, city, state, and zip fields to the ProfileEditor template.\n\n***src/app/profile-editor/profile-editor.component.html (template nested form group)***\n```\n<div formGroupName=\"address\">\n  <h3>Address</h3>\n\n  <label>\n    Street:\n    <input type=\"text\" formControlName=\"street\">\n  </label>\n\n  <label>\n    City:\n    <input type=\"text\" formControlName=\"city\">\n  </label>\n  \n  <label>\n    State:\n    <input type=\"text\" formControlName=\"state\">\n  </label>\n\n  <label>\n    Zip Code:\n    <input type=\"text\" formControlName=\"zip\">\n  </label>\n</div>\n```\n> **Tip** Display the value for the form group instance in the component template using the value property and JsonPipe.\n\n### Updating parts of the data model\nWhen updating the value for a form group instance that contains multiple controls, you may only want to update parts of the model. This section covers how to update specific parts of a form control data model.\n\nThere are two ways to update the model value:\n\n- **Use the setValue() method to set a new value for an individual control**. The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control.\n\n- **Use the patchValue() method to replace any properties defined in the object that have changed in the form model**.\n\n> The strict checks of the setValue() method help catch nesting errors in complex forms, while patchValue() fails silently on those errors.\n\nIn ProfileEditorComponent, use the updateProfile method with the example below to update the first name and street address for the user.\nsrc/app/profile-editor/profile-editor.component.ts (patch value)\n```\nupdateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street'\n    }\n  });\n}\n```\nSimulate an update by adding a button to the template to update the user profile on demand.\n```\n<p>\n  <button (click)=\"updateProfile()\">Update Profile</button>\n</p>\n```\nWhen a user clicks the button, the profileForm model is updated with new values for firstName and street. Notice that street is provided in an object inside the address property. This is necessary because the patchValue() method applies the update against the model structure. PatchValue() only updates properties that the form model defines.","references":"- [Angular.io Reactive Forms](https://angular.io/guide/reactive-forms)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-reactive-forms-grouping-controls","weblink":"https://codersnack.com/angular-reactive-forms-grouping-controls","featured_image_preview":{"id":127,"name":"angular-icon.png","hash":"560e73b933e04fef84cf50263965f20e","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/560e73b933e04fef84cf50263965f20e.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T21:55:02.917Z","updated_at":"2021-04-11T21:55:02.917Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Reactive Forms - Grouping Form controls","created_at":"2021-04-11T21:55:36.735Z","updated_at":"2021-04-11T21:55:36.739Z"},{"id":95,"codersnack":{"id":96,"header":"Angular - Dynamic Component Loader","created_at":"2021-04-17T12:10:58.891Z","updated_at":"2021-04-17T12:34:05.006Z","explanation":"Component templates are not always fixed. An application may need to load new components at runtime.\n\nThis cookbook shows you how to use ***ComponentFactoryResolver*** **to add components dynamically**.\n\n\n## Dynamic component loading\nThe following example shows how to build a dynamic ad banner.\n\nThe hero agency is planning an ad campaign with several different ads cycling through the banner. New ad components are added frequently by several different teams. This makes it impractical to use a template with a static component structure.\n\nInstead, **you need a way to load a new component without a fixed reference to the component** in the ad banner's template.\n\nAngular comes with its own API for loading components dynamically.\n\n## The anchor directive\n**Before you can add components you have to define an anchor point** to tell Angular **where to insert components**.\n\nThe ad banner uses a helper directive called ```AdDirective``` to mark valid insertion points in the template.\n***src/app/ad.directive.ts***\n```\nimport { Directive, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[adHost]',\n})\nexport class AdDirective {\n  constructor(public viewContainerRef: ViewContainerRef) { }\n}\n```\n```AdDirective``` injects **ViewContainerRef** to gain **access to the view container of the element that will host the dynamically added component**.\n\nIn the ```@Directive``` **decorator**, notice the selector name, *adHost*; that's what you use to apply the directive to the element. The next section shows you how.\n\n## Loading components\nMost of the ad banner implementation is in **ad-banner.component.ts**. To keep things simple in this example, the HTML is in the ```@Component``` decorator's template property as a template string.\n\nThe ```<ng-template>``` **element is where you apply the directive** you just made. To apply the AdDirective, recall the selector from **ad.directive.ts**, ```[adHost]```. Apply that to ```<ng-template>``` without the square brackets. Now Angular knows where to dynamically load components.\n\n***src/app/ad-banner.component.ts (template)***\n```\ntemplate: `\n            <div class=\"ad-banner-example\">\n              <h3>Advertisements</h3>\n              <ng-template adHost></ng-template>\n            </div>\n          `\n```\n\nThe ```<ng-template>``` element is a good choice for dynamic components because **it doesn't render any additional output**.\n\n## Resolving components\nTake a closer look at the methods in **ad-banner.component.ts**.\n\n**AdBannerComponent** takes an array of **AdItem** objects as input, which ultimately comes from **AdService**. **AdItem** **objects specify the type of component to load** and any data to bind to the component. **AdService** returns the actual ads making up the ad campaign.\n\nPassing an array of components to **AdBannerComponent** allows for a dynamic list of ads without static elements in the template.\n\nWith its **getAds()** method, **AdBannerComponent** cycles through the array of AdItems and loads a new component every 3 seconds by calling loadComponent().\n\n***src/app/ad-banner.component.ts (excerpt)***\n```\nexport class AdBannerComponent implements OnInit, OnDestroy {\n  @Input() ads: AdItem[];\n  currentAdIndex = -1;\n  @ViewChild(AdDirective, {static: true}) adHost: AdDirective;\n  interval: any;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) { }\n\n  ngOnInit() {\n    this.loadComponent();\n    this.getAds();\n  }\n\n  ngOnDestroy() {\n    clearInterval(this.interval);\n  }\n\n  loadComponent() {\n    this.currentAdIndex = (this.currentAdIndex + 1) % this.ads.length;\n    const adItem = this.ads[this.currentAdIndex];\n\n    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(adItem.component);\n\n    const viewContainerRef = this.adHost.viewContainerRef;\n    viewContainerRef.clear();\n\n    const componentRef = viewContainerRef.createComponent<AdComponent>(componentFactory);\n    componentRef.instance.data = adItem.data;\n  }\n\n  getAds() {\n    this.interval = setInterval(() => {\n      this.loadComponent();\n    }, 3000);\n  }\n}\n```\n\nThe **loadComponent()** method is doing a lot of the heavy lifting here. Take it step by step. First, it picks an ad.\n\nHow loadComponent() chooses an ad\n\nThe loadComponent() method chooses an ad using some math.\n\nFirst, it sets the *currentAdIndex* by taking whatever it currently is plus one, dividing that by the length of the AdItem array, and using the remainder as the new currentAdIndex value. Then, it uses that value to select an adItem from the array.\n\nAfter *loadComponent()* selects an ad, it uses **ComponentFactoryResolver** to resolve a **ComponentFactory** for each specific component. **The ComponentFactory then creates an instance of each component**.\n\nNext, you're targeting the **viewContainerRef** that exists on this specific instance of the component. How do you know it's this specific instance? Because *it's referring to **adHost*** and ***adHost*** is the directive you set up earlier to tell Angular *where to insert dynamic components*.\n\nAs you may recall, AdDirective injects ViewContainerRef into its constructor. This is how the directive accesses the element that you want to use to host the dynamic component.\n\nTo add the component to the template, you call **createComponent()** on *ViewContainerRef*.\n\nThe **createComponent()** method returns a reference to the loaded component. Use that reference to interact with the component by assigning to its properties or calling its methods.\n\n## The AdComponent interface\nIn the ad banner, all components implement a common ```AdComponent``` **interface** to standardize the API for passing data to the components.\n\nHere are two sample components and the AdComponent interface for reference:\n***ad.component.ts***\n```\nexport interface AdComponent {\n  data: any;\n}\n```\n***hero-job-ad.component.ts***\n```\nimport { Component, Input } from '@angular/core';\n\nimport { AdComponent } from './ad.component';\n\n@Component({\n  template: `\n    <div class=\"job-ad\">\n      <h4>{{data.headline}}</h4>\n\n      {{data.body}}\n    </div>\n  `\n})\nexport class HeroJobAdComponent implements AdComponent {\n  @Input() data: any;\n\n}\n```\n\n***hero-profile.component.ts***\n```\nimport { Component, Input } from '@angular/core';\n\nimport { AdComponent } from './ad.component';\n\n@Component({\n  template: `\n    <div class=\"hero-profile\">\n      <h3>Featured Hero Profile</h3>\n      <h4>{{data.name}}</h4>\n\n      <p>{{data.bio}}</p>\n\n      <strong>Hire this hero today!</strong>\n    </div>\n  `\n})\nexport class HeroProfileComponent implements AdComponent {\n  @Input() data: any;\n}\n```\n\n***app.component.ts***\n```\nimport { Component, OnInit } from '@angular/core';\n\nimport { AdService } from './ad.service';\nimport { AdItem } from './ad-item';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <div>\n      <app-ad-banner [ads]=\"ads\"></app-ad-banner>\n    </div>\n  `\n})\nexport class AppComponent implements OnInit {\n  ads: AdItem[];\n\n  constructor(private adService: AdService) {}\n\n  ngOnInit() {\n    this.ads = this.adService.getAds();\n  }\n}\n```\n\n\n***ad-item.ts***\n```\nimport { Type } from '@angular/core';\n\nexport class AdItem {\n  constructor(public component: Type<any>, public data: any) {}\n}\n```\n\n\n***ad.service.ts***\n\n```\nimport { Injectable } from '@angular/core';\n\nimport { HeroJobAdComponent } from './hero-job-ad.component';\nimport { HeroProfileComponent } from './hero-profile.component';\nimport { AdItem } from './ad-item';\n\n@Injectable()\nexport class AdService {\n  getAds() {\n    return [\n      new AdItem(HeroProfileComponent, {name: 'Bombasto', bio: 'Brave as they come'}),\n\n      new AdItem(HeroProfileComponent, {name: 'Dr IQ', bio: 'Smart as they come'}),\n\n      new AdItem(HeroJobAdComponent,   {headline: 'Hiring for several positions',\n                                        body: 'Submit your resume today!'}),\n\n      new AdItem(HeroJobAdComponent,   {headline: 'Openings in all departments',\n                                        body: 'Apply today'}),\n    ];\n  }\n}\n```\n  \n\n## Final ad banner\nThe final ad banner looks like this:\n![angular dynamic ad banner](https://codersnack.com/assets/images/angular-dynamic-ad-banner.gif)\n\n\n\n\n\n","references":"- [Angular.io Dynamic Component Loader](https://angular.io/guide/dynamic-component-loader)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-dynamic-component-loader","weblink":"https://codersnack.com/angular-dynamic-component-loader","featured_image_preview":{"id":128,"name":"angular-icon.png","hash":"3e4fc0519b454208800a6fb1c9054ee9","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/3e4fc0519b454208800a6fb1c9054ee9.png","provider":"local","provider_metadata":null,"created_at":"2021-04-17T12:10:58.907Z","updated_at":"2021-04-17T12:10:58.907Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Dynamic Component Loader","created_at":"2021-04-17T12:11:34.359Z","updated_at":"2021-04-17T12:11:34.362Z"},{"id":106,"codersnack":{"id":108,"header":"Angular - Upgrading from AngularJS to Angular - 1","created_at":"2021-11-08T21:46:15.611Z","updated_at":"2021-11-10T11:42:14.248Z","explanation":"**Angular** is the name for the Angular of today and tomorrow.\n\n**AngularJS** is the name for **all 1.x versions of Angular**.\n\nAngularJS applications are great. Always consider the business case before moving to Angular. An important part of that case is the time and effort to get there. This guide describes the **built-in tools for efficiently migrating AngularJS projects over to the Angular platform**, a piece at a time.\n\nSome applications will be easier to upgrade than others, and there are many ways to make it easier for yourself. **It is possible to prepare and align AngularJS applications with Angular even before beginning the upgrade process**. **These preparation steps are all about making the code more decoupled, more maintainable, and better aligned with modern development tools**. That means in addition to making the upgrade easier, **you will also improve the existing AngularJS applications**.\n\n**One of the keys to a successful upgrade is to do it incrementally, by running the two frameworks side by side in the same application, and porting AngularJS components to Angular one by one**. This makes it possible to upgrade even large and complex applications without disrupting other business, because the work can be done collaboratively and spread over a period of time. **The upgrade module in Angular has been designed to make incremental upgrading seamless**.\n\n## Preparation\n\nThere are many ways to structure AngularJS applications. When you begin to upgrade these applications to Angular, some will turn out to be much more easy to work with than others. **There are a few key techniques and patterns that you can apply to future proof applications even before you begin the migration**.\n\n\n### Follow the AngularJS Style Guide\n\n**The [*AngularJS* Style Guide](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md) collects patterns and practices that have been proven to result in cleaner and more maintainable AngularJS applications**. It contains a wealth of information about how to write and organize AngularJS code —and equally importantly— how not to write and organize AngularJS code.\n\nAngular is a reimagined version of the best parts of AngularJS. In that sense, its goals are the same as the Style Guide for AngularJS: To preserve the good parts of AngularJS, and to avoid the bad parts. There is a lot more to Angular than that of course, but this does mean that following **the style guide helps make your AngularJS application more closely aligned with Angular.**\n\nThere are a few **rules in particular that will make it much easier to do an incremental upgrade** using the Angular **upgrade/static module**:\n\n- **The Rule of 1 states that there should be [one component per file](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility)**. This not only makes components easy to navigate and find, but will also allow us to migrate them between languages and frameworks one at a time. In this example application, each controller, component, service, and filter is in its own source file.\n\n- The [**Folders-by-Feature Structure**](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure) and [**Modularity**](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity) rules define similar principles on a higher level of abstraction: Different parts of the application should reside in different directories and NgModules.\n\n**When an application is laid out feature per feature in this way, it can also be migrated one feature at a time**. For applications that don't already look like this, applying the rules in the AngularJS style guide is a **highly recommended preparation step**. And this is not just for the sake of the upgrade - it is just solid advice in general!\n\n\n### Using a Module Loader\n\nWhen you break application code down into one component per file, you often end up with **a project structure with a large number of relatively small files**. This is a much neater way to organize things than a small number of large files, but it doesn't work that well **if you have to load all those files to the HTML page with `<script>`  tags. Especially when you also have to maintain those tags in the correct order**. That is why it is a good idea to start **using a module loader**.\n\n**Using a module loader such as SystemJS, Webpack, or Browserify allows us to use the built-in module systems of TypeScript or ES2015.**  You can use the import and export features that explicitly specify what code can and will be shared between different parts of the application. For **ES5 applications you can use CommonJS style require and module.exports features**. In both cases, the module loader will then take care of loading all the code the application needs in the correct order.\n\n**When moving applications into production, module loaders also make it easier to package them all up into production** bundles with batteries included.\n\n\n### Migrating to TypeScript\n\nIf part of the Angular upgrade plan is to also take TypeScript into use, it makes sense to bring in the TypeScript compiler even before the upgrade itself begins. This means there is one less thing to learn and think about during the actual upgrade. It also means you can start using TypeScript features in your AngularJS code.\n\nSince TypeScript is a superset of ECMAScript 2015, which in turn is a superset of ECMAScript 5, **\"switching\" to TypeScript doesn't necessarily require anything more than installing the TypeScript compiler and renaming files from *.js to *.ts.** But just doing that is not hugely useful or exciting, of course. Additional steps like the following can give us much more bang for the buck:\n\n- **For applications that use a module loader**, TypeScript imports and exports (which are really ECMAScript 2015 imports and exports) can be used to **organize code into modules**.\n- **Type annotations can be gradually added to existing functions and variables** to pin down their types and get benefits like build-time error checking, great autocompletion support and inline documentation.\n- **JavaScript features new to ES2015**, like arrow functions, lets and consts, default function parameters, and destructuring assignments can also be gradually added to make the **code more expressive**.\n- **Services and controllers can be turned into classes**. That way they'll be a step closer to becoming Angular service and component classes, which will make life easier after the upgrade.\n\n### Using Component Directives\n\nIn Angular, components are the main primitive from which user interfaces are built. You define the different portions of the UI as components and compose them into a full user experience.\n\nYou can also do this in AngularJS, using component directives. These are directives that define their own templates, controllers, and input/output bindings - the same things that Angular components define. **Applications built with component directives are much easier to migrate to Angular than applications built with lower-level features like ng-controller, ng-include, and scope inheritance**.\n\n**To be Angular compatible, an AngularJS component directive should configure these attributes:**\n\n- **restrict**: 'E' Components are usually used as elements.\n\n- **scope**: {} - an isolate scope. In Angular, components are always isolated from their surroundings, and you should do this in AngularJS too.\n\n- **bindToController**: {}. Component inputs and outputs should be bound to the controller instead of using the $scope.\n\n- controller and **controllerAs**. Components have their own controllers.\n\n- **template** or templateUrl. Components have their own templates.\n\n**Component directives** may also use the following attributes:\n\n- **transclude: true/{}**, if the component needs to transclude content from elsewhere.\n- **require**, if the component needs to communicate with the controller of some parent component.\n\nComponent directives should **not use the following attributes**:\n\n- **compile**. This will not be supported in Angular.\n\n- **replace**: true. Angular never replaces a component element with the component template. This attribute is also **deprecated** in AngularJS.\n\n- **priority and terminal**. While AngularJS components may use these, they are not used in Angular and it is better not to write code that relies on them.\n\nAn AngularJS component directive that is fully aligned with the Angular architecture may look something like this:\n\n*hero-detail.directive.ts*\n```\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&'\n    },\n    template: `\n      <h2>{{$ctrl.hero.name}} details!</h2>\n      <div><label>id: </label>{{$ctrl.hero.id}}</div>\n      <button ng-click=\"$ctrl.onDelete()\">Delete</button>\n    `,\n    controller: function HeroDetailController() {\n      this.onDelete = () => {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n```\n\n**AngularJS 1.5 introduces the component API that makes it easier to define component directives like these**. It is a good idea to use this API for component directives for several reasons:\n\n- It requires less boilerplate code.\n- It enforces the use of component best practices like controllerAs.\n- It has good default values for directive attributes like scope and restrict.\n\n\nThe component directive example from above looks like this when expressed **using the component API**:\n\n*hero-detail.component.ts*\n```\nexport const heroDetail = {\n  bindings: {\n    hero: '<',\n    deleted: '&'\n  },\n  template: `\n    <h2>{{$ctrl.hero.name}} details!</h2>\n    <div><label>id: </label>{{$ctrl.hero.id}}</div>\n    <button ng-click=\"$ctrl.onDelete()\">Delete</button>\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n```\n\n**Controller lifecycle hook methods *$onInit(), $onDestroy()*, and *$onChanges()* are another convenient feature that AngularJS 1.5 introduces**. They all have nearly exact **equivalents in Angular**, so organizing component lifecycle logic around them will ease the eventual Angular upgrade proces\n","references":"- [Angular.io - Upgrading from AngularJS to Angular](https://angular.io/guide/upgrade)","featured_image_url":"https://codersnack.com/assets/images/angularjs-to-angular.png","slug":"angular-upgrade-from-angularjs-1","weblink":"https://codersnack.com/angular-upgrade-from-angularjs-1","featured_image_preview":{"id":144,"name":"angularjs-to-angular.png","hash":"dcd255b915594f0fa93f9915990db9a3","sha256":"0vRZ8EYek5TOP2r6uyyyC9GItfekgnyf-MA5Suxl7aI","ext":".png","mime":"image/png","size":25.4,"url":"/uploads/dcd255b915594f0fa93f9915990db9a3.png","provider":"local","provider_metadata":null,"created_at":"2021-11-08T21:46:15.624Z","updated_at":"2021-11-08T21:46:15.624Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - upgrade angularjs to angular - 1","created_at":"2021-11-08T21:46:57.030Z","updated_at":"2021-11-10T11:43:12.379Z"},{"id":108,"codersnack":{"id":109,"header":"Angular - Upgrading from AngularJS to Angular - 2","created_at":"2021-11-08T22:47:43.693Z","updated_at":"2021-11-10T11:41:58.626Z","explanation":"\n## Upgrading with *ngUpgrade*\n\n**The ngUpgrade library in Angular is a very useful tool for upgrading** anything but the smallest of applications. With it **you can mix and match AngularJS and Angular components in the same application and have them interoperate seamlessly**. That means **you don't have to do the upgrade work all at once**, since there is a natural coexistence between the two frameworks during the transition period.\n\n> The end of life of AngularJS is December 31st, 2021. With this event, ngUpgrade is now in a feature complete state. We will continue publishing security and bug fixes for ngUpgrade at least until December 31st, 2022.\n\n\n### How ngUpgrade Works\n\n**One of the primary tools provided by ngUpgrade is called the *UpgradeModule***. This is a module that contains utilities for **bootstrapping and managing hybrid applications** that support both Angular and AngularJS code.\n\nWhen you use ngUpgrade, what you're really doing is **running both AngularJS and Angular at the same time**. All Angular code is running in the Angular framework, and AngularJS code in the AngularJS framework. Both of these are the actual, fully featured versions of the frameworks. **There is no emulation going on, so you can expect to have all the features and natural behavior of both frameworks**.\n\nWhat happens **on top of this is that components and services managed by one framework can interoperate with those from the other framework**. This happens in *three main areas: Dependency injection, the DOM, and change detection*.\n\n\n#### Dependency Injection\n\nDependency injection is front and center in both AngularJS and Angular, but there are some **key differences between the two frameworks** in how it actually works.\n\n![angularjs-to-angular-di-compare](https://codersnack.com/assets/images/angularjs-to-angular-di-compare.png)\n\nEven accounting for these differences you can still have dependency injection interoperability. ***upgrade/static* resolves the differences** and makes everything work seamlessly:\n\n- **You can make AngularJS services available for injection to Angular code by upgrading them**. The same singleton instance of each service is shared between the frameworks. In Angular these services will always be in the root injector and available to all components.\n\n- **You can also make Angular services available for injection to AngularJS code by downgrading them**. Only services from the Angular root injector can be downgraded. Again, the same singleton instances are shared between the frameworks. When you register a downgraded service, you must explicitly specify a string token that you want to use in AngularJS.\n\n![The two injectors in a hybrid application](https://codersnack.com/assets/images/angularjs-to-angular-injectors.png)\n\n\n### Components and the DOM\n\n**In the DOM of a hybrid ngUpgrade application are components and directives from both AngularJS and Angular**. These components communicate with each other by using the input and output bindings of their respective frameworks, which *ngUpgrade bridges together*. They may also *communicate through shared injected dependencies*, as described above.\n\n**The key thing to understand about a hybrid application is that every element in the DOM is owned by exactly one of the two frameworks**. The other framework ignores it. If an element is owned by AngularJS, Angular treats it as if it didn't exist, and vice versa.\n\n**So normally a hybrid application begins life as an AngularJS application, and it is AngularJS that processes the root template, for example, the index.html. Angular then steps into the picture when an Angular component is used somewhere in an AngularJS template**. The template of that component will then be managed by Angular, and it may contain any number of Angular components and directives.\n\nBeyond that, you may interleave the two frameworks. You always **cross the boundary between the two frameworks by one of two ways**:\n\n- By **using a component from the other framework**: An AngularJS template using an Angular component, or an Angular template using an AngularJS component.\n\n- By **transcluding or projecting content from the other framework**. ngUpgrade bridges the related concepts of AngularJS transclusion and Angular content projection together.\n\n\n![DOM element ownership in a hybrid application](https://codersnack.com/assets/images/angularjs-to-angular-dom.png)\n\nWhenever you use a component that belongs to the other framework, a switch between framework boundaries occurs. However, that **switch only happens to the elements in the template of that component**. \n\nConsider a situation where you use an Angular component from AngularJS like this:\n\n```\n<a-component></a-component>\n```\n\nThe DOM element ```<a-component>```  will remain to be an **AngularJS managed element**, because it is defined in an AngularJS template. That also means you can apply additional AngularJS directives to it, but not Angular directives. It is only in the template of the ```<a-component>``` where Angular steps in. This same rule also applies when you use AngularJS component directives from Angular.\n\n### Change Detection\n\nThe **scope.$apply()** is how **AngularJS detects changes and updates data bindings**. After every event that occurs, scope.$apply() gets called. This is done either **automatically** by the framework, or **manually by you**.\n\n**In Angular things are different**. While change detection still occurs after every event, no one needs to call scope.$apply() for that to happen. This is because **all Angular code runs inside something called the Angular zone**. Angular always knows when the code finishes, so it also knows when it should kick off change detection. The code itself doesn't have to call scope.$apply() or anything like it.\n\nIn the case of hybrid applications, the ***UpgradeModule* bridges the AngularJS and Angular approaches**. Here is what happens:\n\n- **Everything that happens in the application runs inside the Angular zone. This is true whether the event originated in AngularJS or Angular code**. The zone triggers Angular change detection after every event.\n\n- The **UpgradeModule will invoke** the AngularJS **$rootScope.$apply()** after every turn of the Angular zone. This also triggers AngularJS change detection after every event.\n\n\n![Change detection in a hybrid application](https://codersnack.com/assets/images/angularjs-to-angular-change_detection.png)\n\n\nIn practice, you do not need to call $apply(), regardless of whether it is in AngularJS or Angular. The UpgradeModule does it for us.**You can still call $apply() so there is no need to remove such calls from existing code**. Those calls just trigger additional AngularJS change detection checks in a hybrid application.\n\n**When you downgrade an Angular component and then use it from AngularJS, the inputs of the component will be watched using AngularJS change detection**. When those inputs change, the corresponding properties in the component are set. You can also hook into the changes by implementing the OnChanges interface in the component, just like you could if it hadn't been downgraded.\n\nCorrespondingly, **when you upgrade an AngularJS component and use it from Angular, all the bindings defined for scope (or bindToController) of the component directive will be hooked into Angular change detection**. They will be treated as regular Angular inputs. Their values will be written to the scope (or controller) of the upgraded component when they change.\n\n### Using UpgradeModule with Angular NgModules\n\nBoth AngularJS and Angular have their own concept of modules to help organize an application into cohesive blocks of functionality.\n\nTheir details are quite different in architecture and implementation. **In AngularJS, you add Angular assets to the angular.module property. In Angular, you create one or more classes adorned with an NgModule decorator that describes Angular assets in metadata**. The differences blossom from there.\n\nIn a hybrid application you run both versions of Angular at the same time. That means that you need at least one module each from both AngularJS and Angular. You will import UpgradeModule inside the NgModule, and then use it for bootstrapping the AngularJS module.\n\nFor more information, see NgModules.\n\n### Bootstrapping hybrid applications\n\nTo bootstrap a hybrid application, you must bootstrap each of the Angular and AngularJS parts of the application. **You must bootstrap the Angular bits first and then ask the UpgradeModule to bootstrap the AngularJS bits next**.\n\nIn an AngularJS application you have a root AngularJS module, which will also be used to bootstrap the AngularJS application.\n\n*app.module.ts*\n\n```\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n```\n\n**Pure AngularJS applications can be automatically bootstrapped by using an *ng-app* directive somewhere on the HTML page. But for hybrid applications, you manually bootstrap using the *UpgradeModule***. Therefore, it is a **good preliminary step to switch AngularJS applications to use the manual JavaScript *angular.bootstrap* method even before switching them to hybrid mode.**\n\nSay you have an ng-app driven bootstrap such as this one:\n\n```html\n\n<!DOCTYPE HTML>\n<html lang=\"en\">\n  <head>\n    <base href=\"/\">\n    <script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\"></script>\n    <script src=\"app/ajs-ng-app/app.module.js\"></script>\n  </head>\n\n  <body ng-app=\"heroApp\" ng-strict-di>\n    <div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\">\n      {{ mainCtrl.message }}\n    </div>\n  </body>\n</html>\n\n```\n\n\n**You can remove the ng-app and ng-strict-di directives from the HTML and instead switch to calling angular.bootstrap from JavaScript**, which will result in the same thing:\n\n*app.module.ts*\n\n```\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n```\n**To begin converting your AngularJS application to a hybrid, you need to load the Angular framework**. You can see how this can be done with SystemJS by following the instructions in Setup for Upgrading to AngularJS for selectively copying code from the QuickStart github repository.\n\nYou also need to **install the @angular/upgrade package** using\n\n```\nnpm install @angular/upgrade --save\n```\n\n and **add a mapping for the @angular/upgrade/static package**:\n\n*systemjs.config.js (map)*\n\n```\n'@angular/upgrade/static': 'npm:@angular/upgrade/fesm2015/static.mjs',\n```\n\nNext, **create an app.module.ts** file and add the following NgModule class:\n\n*app.module.ts*\n\n```\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { UpgradeModule } from '@angular/upgrade/static';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n```\n\nThis bare minimum NgModule imports BrowserModule, the module every Angular browser-based application must have. It also imports UpgradeModule from @angular/upgrade/static, which exports providers that will be used for upgrading and downgrading services and components.\n\nIn the constructor of the AppModule, use dependency injection to **get a hold of the UpgradeModule instance, and use it to bootstrap the AngularJS application in the AppModule.ngDoBootstrap method**. The upgrade.bootstrap method takes the exact same arguments as angular.bootstrap:\n\n> NOTE: You do not add a bootstrap declaration to the @NgModule decorator, since **AngularJS will own the root template of the application**.\n\nNow you can **bootstrap AppModule using the *platformBrowserDynamic.bootstrapModule* method.**\n\n*app.module.ts*\n\n```\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n```\n\n\nCongratulations! You're running a hybrid application! The existing AngularJS code works as before and you're ready to start adding Angular code.\n\n\n","references":"- [Angular.io - Upgrading from AngularJS to Angular](https://angular.io/guide/upgrade)","featured_image_url":"https://codersnack.com/assets/images/angularjs-to-angular.png","slug":"angular-upgrade-from-angularjs-2","weblink":"https://codersnack.com/angular-upgrade-from-angularjs-2","featured_image_preview":{"id":145,"name":"angularjs-to-angular.png","hash":"ca72e250efcf40489a4661a5f9d1f8a1","sha256":"0vRZ8EYek5TOP2r6uyyyC9GItfekgnyf-MA5Suxl7aI","ext":".png","mime":"image/png","size":25.4,"url":"/uploads/ca72e250efcf40489a4661a5f9d1f8a1.png","provider":"local","provider_metadata":null,"created_at":"2021-11-08T22:47:43.704Z","updated_at":"2021-11-08T22:47:43.704Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Upgrade from angularjs to angular - 2","created_at":"2021-11-08T23:29:51.335Z","updated_at":"2021-11-10T11:43:20.237Z"},{"id":109,"codersnack":{"id":111,"header":"Angular - Upgrading from AngularJS to Angular - 3","created_at":"2021-11-10T11:32:28.867Z","updated_at":"2021-11-10T11:41:48.968Z","explanation":"## Using Angular Components from AngularJS Code\n\n![angularjs-to-angular-ajs-to-a](https://codersnack.com/assets/images/angularjs-to-angular-ajs-to-a.png)\n\nOnce you're running a hybrid app, you can start the gradual process of upgrading code. One of the more common patterns for doing that is to **use an Angular component in an AngularJS context.** This could be a completely new component or one that was previously AngularJS but has been rewritten for Angular.\n\nSay you have an Angular component that shows information about a hero:\n\n*hero-detail.component.ts*\n```\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    <h2>Windstorm details!</h2>\n    <div><label>id: </label>1</div>\n  `\n})\nexport class HeroDetailComponent { }\n```\n**If you want to use this component from AngularJS, you need to downgrade it using the *downgradeComponent()* method**. The **result is an AngularJS directive**, which you can then register in the AngularJS module:\n\n*app.module.ts*\n```\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { downgradeComponent } from '@angular/upgrade/static';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    downgradeComponent({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n```\n\nBy default, **Angular change detection** will **also run on the component for every *AngularJS $digest cycle***. **If you want to only have change detection run whenthe inputs change, you can set *propagateDigest to false* when calling downgradeComponent().**\n\nBecause **HeroDetailComponent** is an Angular component, you **must also add it to the declarations in the AppModule**.\n\nAnd because **this component is being used from the AngularJS module, and is an entry point into the Angular application, you must add it to the entryComponents for the NgModule.**\n\n*app.module.ts*\n```\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  declarations: [\n    HeroDetailComponent\n  ],\n  entryComponents: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n```\nAll Angular components, directives and pipes must be declared in an NgModule.\n\nThe net result is an **AngularJS directive called heroDetail**, that you can use like any other directive in AngularJS templates.\n\n```\n<hero-detail></hero-detail>\n```\n> NOTE: This AngularJS is an element directive (restrict: 'E') called heroDetail. An AngularJS element directive is matched based on its name. The selector metadata of the downgraded Angular component is ignored.\n\nMost components are not quite this simple, of course. **Many of them have inputs and outputs that connect them to the outside world.** An Angular hero detail component with inputs and outputs might look like this:\n\n*hero-detail.component.ts*\n```\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    <h2>{{hero.name}} details!</h2>\n    <div><label>id: </label>{{hero.id}}</div>\n    <button (click)=\"onDelete()\">Delete</button>\n  `\n})\nexport class HeroDetailComponent {\n  @Input() hero!: Hero;\n  @Output() deleted = new EventEmitter<Hero>();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n```\n\n**These inputs and outputs can be supplied from the AngularJS template, and the downgradeComponent() method takes care of wiring them up**:\n\n```\n<div ng-controller=\"MainController as mainCtrl\">\n  <hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\">\n  </hero-detail>\n</div>\n```\n\n**Even though you are in an AngularJS template, you are using Angular attribute syntax to bind the inputs and outputs**. This is a requirement for downgraded components. The expressions themselves are still regular AngularJS expressions.\n\n**- USE KEBAB-CASE FOR DOWNGRADED COMPONENT ATTRIBUTES -**\nThere is one notable exception to the rule of using Angular attribute syntax for downgraded components. It has to do with input or output names that consist of multiple words. In Angular, you would bind these attributes using camelCase:\n```\n[myHero]=\"hero\"\n(heroDeleted)=\"handleHeroDeleted($event)\"\n```\n\nBut when using them from AngularJS templates, you must use kebab-case:\n```\n[my-hero]=\"hero\"\n(hero-deleted)=\"handleHeroDeleted($event)\"\n\n```\n**-- --**\n\n**The *$event* variable can be used in outputs to gain access to the object that was emitted**. In this case it will be the Hero object, because that is what was passed to this.deleted.emit().\n\nSince this is an AngularJS template, **you can still use other AngularJS directives on the element, even though it has Angular binding attributes on it**. For example, you can easily make multiple copies of the component using ng-repeat:\n\n```\n<div ng-controller=\"MainController as mainCtrl\">\n  <hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\">\n  </hero-detail>\n</div>\n```\n\n\n## Using AngularJS Component Directives from Angular Code\n\n![angularjs-to-angular-a-to-ajs](https://codersnack.com/assets/images/angularjs-to-angular-a-to-ajs.png)\n\nSo, **you can write an Angular component and then use it from AngularJS code**. This is **useful when you start to migrate from lower-level components and work your way up**. \n\nBut **in some cases it is more convenient to do things in the opposite order: To start with higher-level components and work your way down**. This too can be done **using the *upgrade/static***. **You can upgrade AngularJS component directives and then use them from Angular.**\n\n**Not all kinds of AngularJS directives can be upgraded**. The directive really has to be a component directive, with the characteristics described in the preparation guide above. **The safest bet for ensuring compatibility is using the component API introduced in AngularJS 1.5**.\n\nAn example of an upgradeable component is one that just has a template and a controller:\n\n*hero-detail.component.ts*\n```\nexport const heroDetail = {\n  template: `\n    <h2>Windstorm details!</h2>\n    <div><label>id: </label>1</div>\n  `,\n  controller: function HeroDetailController() {\n  }\n};\n```\n\nYou can upgrade this component to Angular using the UpgradeComponent class. By creating a new Angular directive that extends UpgradeComponent and doing a super call inside its constructor, you have a fully upgraded AngularJS component to be used inside Angular. All that is left is to add it to the declarations array of AppModule.\n\n*hero-detail.component.ts*\n```\nimport { Directive, ElementRef, Injector, SimpleChanges } from '@angular/core';\nimport { UpgradeComponent } from '@angular/upgrade/static';\n\n@Directive({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends UpgradeComponent {\n  constructor(elementRef: ElementRef, injector: Injector) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n```\n*app.module.ts*\n```\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  declarations: [\n    HeroDetailDirective,\n  /* . . . */\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n```\n\n**Upgraded components are Angular directives, instead of components**, because Angular is unaware that AngularJS will create elements under it. As far as Angular knows, the upgraded component is just a directive, a tag; and Angular doesn't have to concern itself with its children.\n\n**An upgraded component may also have inputs and outputs, as defined by the *scope/controller bindings* of the original AngularJS component directive**. When you use the component from an Angular template, provide the inputs and outputs using Angular template syntax, observing the following rules:\n\n![angularjs-to-angular-bindingss](https://codersnack.com/assets/images/angularjs-to-angular-bindings)\n\nFor example, imagine a hero detail AngularJS component directive with one input and one output:\n\n*hero-detail.component.ts*\n```\nexport const heroDetail = {\n  bindings: {\n    hero: '<',\n    deleted: '&'\n  },\n  template: `\n    <h2>{{$ctrl.hero.name}} details!</h2>\n    <div><label>id: </label>{{$ctrl.hero.id}}</div>\n    <button ng-click=\"$ctrl.onDelete()\">Delete</button>\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n```\n\n**You can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive**, and then provide the input and output using Angular template syntax:\n\n*hero-detail.component.ts*\n```\nimport { Directive, ElementRef, Injector, Input, Output, EventEmitter } from '@angular/core';\nimport { UpgradeComponent } from '@angular/upgrade/static';\nimport { Hero } from '../hero';\n\n@Directive({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends UpgradeComponent {\n  @Input() hero: Hero;\n  @Output() deleted: EventEmitter<Hero>;\n\n  constructor(elementRef: ElementRef, injector: Injector) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n```\n*container.component.ts*\n```\nimport { Component } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'my-container',\n  template: `\n    <h1>Tour of Heroes</h1>\n    <hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\">\n    </hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n```\n\n## Projecting AngularJS Content into Angular Components\n\n![Projecting AngularJS content into Angular](https://codersnack.com/assets/images/angularjs-to-angular-ajs-to-a-with-projection.png)\n\n**When you are using a downgraded Angular component from an AngularJS template, the need may arise to transclude some content into it**. This is also possible. While there is **no such thing as transclusion in Angular, there is a very similar concept called content projection**. *upgrade/static is able to make these* two features interoperate.\n\nAngular components that support content projection make use of an **```<ng-content>```** tag within them. Here is an example of such a component:\n\n*hero-detail.component.ts*\n```\nimport { Component, Input } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    <h2>{{hero.name}}</h2>\n    <div>\n      <ng-content></ng-content>\n    </div>\n  `\n})\nexport class HeroDetailComponent {\n  @Input() hero!: Hero;\n}\n```\nWhen using the component from AngularJS, you can supply contents for it. Just like they would be transcluded in AngularJS, they get projected to the location of the <ng-content> tag in Angular:\n\n```\n<div ng-controller=\"MainController as mainCtrl\">\n  <hero-detail [hero]=\"mainCtrl.hero\">\n    <!-- Everything here will get projected -->\n    <p>{{mainCtrl.hero.description}}</p>\n  </hero-detail>\n</div>\n```\n> When AngularJS content gets projected inside an Angular component, it still remains in \"AngularJS land\" and is managed by the AngularJS framework.\n\n\n### Transcluding Angular Content into AngularJS Component Directives\n\n\n![angularjs-to-angular-a-to-ajs-with-transclusion](https://codersnack.com/assets/images/angularjs-to-angular-a-to-ajs-with-transclusion.png)\n\nJust as you can project AngularJS content into Angular components, you can transclude Angular content into AngularJS components, whenever you are using upgraded versions from them.\n\n**When an AngularJS component directive supports transclusion, it may use the *ng-transclude directive* in its template to mark the transclusion point:**\n\n*hero-detail.component.ts*\n```\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    <h2>{{$ctrl.hero.name}}</h2>\n    <div>\n      <ng-transclude></ng-transclude>\n    </div>\n  `,\n  transclude: true\n};\n```\n\nIf you upgrade this component and use it from Angular, you can populate the component tag with contents that will then get transcluded:\n\n*container.component.ts*\n```\nimport { Component } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'my-container',\n  template: `\n    <hero-detail [hero]=\"hero\">\n      <!-- Everything here will get transcluded -->\n      <p>{{hero.description}}</p>\n    </hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n```\n\n\n### Making AngularJS Dependencies Injectable to Angular\n\nWhen running a hybrid app, you may encounter **situations where you need to inject some AngularJS dependencies into your Angular code**. Maybe you have some business logic still in AngularJS services. **Maybe you want access to built-in services of AngularJS like *$location* or *$timeout*.**\n\nIn these situations, **it is possible to upgrade an AngularJS provider to Angular**. This makes it possible to then inject it somewhere in Angular code. For example, you might have a service called HeroesService in AngularJS:\n\n*heroes.service.ts*\n```\nimport { Hero } from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n```\n**You can upgrade the service using a *Angular factory provider* that requests the service from the *AngularJS $injector***.\n\nMany developers prefer to **declare the factory provider in a separate *ajs-upgraded-providers.ts* file** so that they are all together, making it easier to reference them, create new ones and delete them once the upgrade is over.\n\nIt is also **recommended to export the heroesServiceFactory function so that Ahead-of-Time compilation can pick it up**.\n\n\n> NOTE: The 'heroes' string inside the factory refers to the AngularJS HeroesService. It is common in AngularJS applications to choose a service name for the token, for example \"heroes\", and append the \"Service\" suffix to create the class name.\n\n*ajs-upgraded-providers.ts*\n```\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n```\nYou can then provide the service to Angular by adding it to the @NgModule:\n\n*app.module.ts*\n```\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n```\n\nThen use the service inside your component by injecting it in the component constructor using its class as a type annotation:\n\n*hero-detail.component.ts*\n```\nimport { Component } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    <h2>{{hero.id}}: {{hero.name}}</h2>\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n```\nIn this example **you upgraded a service class**. **You can use a TypeScript type annotation when you inject it**. While it doesn't affect how the dependency is handled, it enables the **benefits of static type checking**. This is not required though, and any AngularJS service, factory, or provider can be upgraded.\n\n\n### Making Angular Dependencies Injectable to AngularJS\n\nIn addition to upgrading AngularJS dependencies, you can also **downgrade Angular dependencies, so that you can use them from AngularJS**. This can be useful when you start migrating services to Angular or creating new services in Angular while retaining components written in AngularJS.\n\nFor example, you might have an **Angular service called Heroes**:\n\n*heroes.ts*\n```\nimport { Injectable } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Injectable()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n```\nAgain, as with Angular components, **register the provider with the NgModule by adding it to the providers list of the module**.\n\n*app.module.ts*\n```\nimport { Heroes } from './heroes';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n```\n\nNow **wrap the Angular Heroes in an AngularJS factory function using *downgradeInjectable()* and plug the factory into an AngularJS module**. The name of the AngularJS dependency is up to you:\n\n*app.module.ts*\n```\nimport { Heroes } from './heroes';\n/* . . . */\nimport { downgradeInjectable } from '@angular/upgrade/static';\n\nangular.module('heroApp', [])\n  .factory('heroes', downgradeInjectable(Heroes))\n  .component('heroDetail', heroDetailComponent);\n```\n\nAfter this, the service is injectable anywhere in AngularJS code:\n\n*hero-detail.component.ts*\n```\nexport const heroDetailComponent = {\n  template: `\n    <h2>{{$ctrl.hero.id}}: {{$ctrl.hero.name}}</h2>\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n```\n\n","references":"- [Angular.io - Upgrading from AngularJS to Angular](https://angular.io/guide/upgrade)","featured_image_url":"https://codersnack.com/assets/images/angularjs-to-angular.png","slug":"angular-upgrade-from-angularjs-3","weblink":"https://codersnack.com/angular-upgrade-from-angularjs-3","featured_image_preview":{"id":146,"name":"angularjs-to-angular.png","hash":"8dc9a4653a7e48c3b56a755fb4f308ca","sha256":"0vRZ8EYek5TOP2r6uyyyC9GItfekgnyf-MA5Suxl7aI","ext":".png","mime":"image/png","size":25.4,"url":"/uploads/8dc9a4653a7e48c3b56a755fb4f308ca.png","provider":"local","provider_metadata":null,"created_at":"2021-11-10T11:32:28.884Z","updated_at":"2021-11-10T11:32:28.884Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angularjs - Upgrade from angularjs - 3","created_at":"2021-11-10T11:33:06.620Z","updated_at":"2021-11-10T11:43:30.714Z"},{"id":110,"codersnack":{"id":112,"header":"Angular Elements Overview","created_at":"2021-11-24T12:34:15.449Z","updated_at":"2021-11-24T12:41:58.116Z","explanation":"Angular elements are **Angular components packaged as custom elements (also called Web Components)**, a *web standard* for defining new HTML elements in a framework-agnostic way.\n\nCustom elements are a Web Platform feature currently supported by Chrome, Edge (Chromium-based), Firefox, Opera, and Safari, and available in other browsers through polyfills (see Browser Support). **A custom element extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code.**  **The browser maintains a *CustomElementRegistry* of defined custom elements**, which **maps an instantiable JavaScript class to an HTML tag**.\n\nThe **@angular/elements package** exports a ***createCustomElement()*** API that provides a **bridge from Angular's component interface and change detection functionality to the built-in DOM API**.\n\nTransforming a component to a custom element makes all of the required Angular infrastructure available to the browser. Creating a custom element is simple and straightforward, and **automatically connects your component-defined view with change detection and data binding, mapping Angular functionality to the corresponding built-in HTML equivalents.**\n\nWe are working on **custom elements that can be used by web apps built on other frameworks**. **A minimal, self-contained version of the Angular framework is injected as a service to support the component's change-detection and data-binding functionality**. For more about the direction of development, check out this [video presentation](https://www.youtube.com/watch?v=Z1gLFPLVJjY&t=4s).\n\n\n### Using custom elements\n\n**Custom elements bootstrap themselves** - they start automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, **it looks and behaves like any other HTML element**, and does not require any special knowledge of Angular terms or usage conventions.\n\n- **Easy dynamic content in an Angular application**: \nTransforming a component to a custom element provides a straightforward path to creating dynamic HTML content in your Angular application. HTML content that you add directly to the DOM in an Angular application is normally displayed without Angular processing, unless you define a dynamic component, adding your own code to connect the HTML tag to your application data, and participate in change detection. With a custom element, all of that wiring is taken care of automatically.\n\n\n- **Content-rich applications**:\nIf you have a content-rich application, such as the Angular app that presents this documentation, **custom elements let you give your content providers sophisticated Angular functionality without requiring knowledge of Angular**. For example, an Angular guide like this one is added directly to the DOM by the Angular navigation tools, but can include special elements like  ```<code-snippet>```  that perform complex operations. All you need to tell your content provider is the syntax of your custom element. They don't need to know anything about Angular, or anything about your component's data structures or implementation.\n\n### How it works\n\n**Use the *createCustomElement()* function to convert a component into a class** that can be registered with the browser as a custom element. After you register your configured class with the browser's custom-element registry, use the new element just like a built-in HTML element in content that you add directly into the DOM:\n\n```\n<my-popup message=\"Use Angular!\"></my-popup>\n```\n\nWhen your custom element is placed on a page, the browser creates an instance of the registered class and adds it to the DOM. The content is provided by the component's template, which uses **Angular template syntax**, and is rendered using the component and DOM data. **Input properties in the component correspond to input attributes for the element.**\n\n\n![angular-elements-custom-elements](https://codersnack.com/assets/images/angular-elements-custom-elements.png)\n\n### Transforming components to custom elements\n\n**Angular provides the *createCustomElement()* function for converting an Angular component**, together with its dependencies, to a custom element. The function **collects the component's observable properties, along with the Angular functionality the browser needs to create and destroy instances, and to detect and respond to changes**.\n\nThe conversion process implements the **NgElementConstructor interface**, and **creates a constructor class that is configured to produce a self-bootstrapping instance of your component.**\n\nUse the **built-in customElements.define()** function to **register the configured constructor and its associated custom-element tag with the browser's *CustomElementRegistry***\n. **When the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance**.\n\n![angular-elements-createElement](https://codersnack.com/assets/images/angular-elements-createElement.png)\n*Transform a component to a custom element*\n\n> **Avoid using the @Component selector as the custom-element tag name.** This can lead to unexpected behavior, due to Angular creating two component instances for a single DOM element: One regular Angular component and a second one using the custom element.\n\n\n### Mapping\n\nA custom element hosts an Angular component, providing a bridge between the data and logic defined in the component and standard DOM APIs. Component properties and logic maps directly into HTML attributes and the browser's event system.\n\n**The creation API parses the component looking for input properties, and defines corresponding attributes for the custom element**. It transforms the property names to make them compatible with custom elements, which do not recognize case distinctions. **The resulting attribute names use dash-separated lowercase**. For example, for a component with @Input('myInputProp') inputProp, the corresponding custom element defines an attribute my-input-prop.\n\n**Component outputs are dispatched as HTML Custom Events**, with the name of the custom event matching the output name. For example, for a component with @Output() valueChanged = new EventEmitter(), the corresponding custom element dispatches events with the name \"valueChanged\", and the emitted data is stored on the event’s detail property. If you provide an alias, that value is used; for example, @Output('myClick') clicks = new EventEmitter<string>(); results in dispatch events with the name \"myClick\".\n\nFor more information, see Web Component documentation for Creating custom events.\n\n### Browser support for custom elements\n\nThe recently-developed custom elements Web Platform feature is currently supported natively in a number of browsers.\n```\nBrowser\tCustom Element Support\nChrome\tSupported natively.\nEdge (Chromium-based)\tSupported natively.\nFirefox\tSupported natively.\nOpera\tSupported natively.\nSafari\tSupported natively.\n```\nTo **add the @angular/elements package** to your workspace, run the following command:\n\n```\nnpm install @angular/elements --save\n``` \n\n### Example: A Popup Service\n\nPreviously, **when you wanted to add a component to an application at runtime**, you had to define a dynamic component, and then you would have to load it, attach it to an element in the DOM, and wire up all of the dependencies, change detection, and event handling, as described in [Dynamic Component Loader](https://angular.io/guide/dynamic-component-loader).\n\nUsing an Angular custom element makes the process much simpler and more transparent, by providing all of the infrastructure and framework automatically—all you have to do is define the kind of event handling you want. (You do still have to exclude the component from compilation, if you are not going to use it in your application.)\n\n**The following Popup Service example application defines a component that you can either load dynamically or convert to a custom element.**\n\n- **popup.component.ts** defines a simple pop-up element that displays an input message, with some animation and styling.\n- **popup.service.ts** creates an injectable service that provides two different ways to invoke the PopupComponent; as a dynamic component, or as a custom element. Notice how much more setup is required for the dynamic-loading method.\n- **app.module.ts** adds the PopupComponent in the module's declarations list.\n- **app.component.ts** defines the application's root component, which uses the PopupService to add the pop-up to the DOM at run time. **When the application runs, the root component's constructor converts PopupComponent to a custom element**.\n\nFor comparison, the demo shows both methods. **One button adds the popup using the dynamic-loading method, and the other uses the custom element.** The result is the same; only the preparation is different.\n\n*popup.component.ts*\n```\nimport { Component, EventEmitter, HostBinding, Input, Output } from '@angular/core';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\n\n@Component({\n  selector: 'my-popup',\n  template: `\n    <span>Popup: {{message}}</span>\n    <button (click)=\"closed.next()\">&#x2716;</button>\n  `,\n  animations: [\n    trigger('state', [\n      state('opened', style({transform: 'translateY(0%)'})),\n      state('void, closed', style({transform: 'translateY(100%)', opacity: 0})),\n      transition('* => *', animate('100ms ease-in')),\n    ])\n  ],\n  styles: [`\n    :host {\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      background: #009cff;\n      height: 48px;\n      padding: 16px;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      border-top: 1px solid black;\n      font-size: 24px;\n    }\n\n    button {\n      border-radius: 50%;\n    }\n  `]\n})\nexport class PopupComponent {\n  @HostBinding('@state')\n  state: 'opened' | 'closed' = 'closed';\n\n  @Input()\n  get message(): string { return this._message; }\n  set message(message: string) {\n    this._message = message;\n    this.state = 'opened';\n  }\n  private _message = '';\n\n  @Output()\n  closed = new EventEmitter<void>();\n}\n```\n*popup.service.ts*\n```\nimport { ApplicationRef, ComponentFactoryResolver, Injectable, Injector } from '@angular/core';\nimport { NgElement, WithProperties } from '@angular/elements';\nimport { PopupComponent } from './popup.component';\n\n\n@Injectable()\nexport class PopupService {\n  constructor(private injector: Injector,\n              private applicationRef: ApplicationRef,\n              private componentFactoryResolver: ComponentFactoryResolver) {}\n\n  // Previous dynamic-loading method required you to set up infrastructure\n  // before adding the popup to the DOM.\n  showAsComponent(message: string) {\n    // Create element\n    const popup = document.createElement('popup-component');\n\n    // Create the component and wire it up with the element\n    const factory = this.componentFactoryResolver.resolveComponentFactory(PopupComponent);\n    const popupComponentRef = factory.create(this.injector, [], popup);\n\n    // Attach to the view so that the change detector knows to run\n    this.applicationRef.attachView(popupComponentRef.hostView);\n\n    // Listen to the close event\n    popupComponentRef.instance.closed.subscribe(() => {\n      document.body.removeChild(popup);\n      this.applicationRef.detachView(popupComponentRef.hostView);\n    });\n\n    // Set the message\n    popupComponentRef.instance.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popup);\n  }\n\n  // This uses the new custom-element method to add the popup to the DOM.\n  showAsElement(message: string) {\n    // Create element\n    const popupEl: NgElement & WithProperties<PopupComponent> = document.createElement('popup-element') as any;\n\n    // Listen to the close event\n    popupEl.addEventListener('closed', () => document.body.removeChild(popupEl));\n\n    // Set the message\n    popupEl.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popupEl);\n  }\n}\n```\n\n*app.module.ts*\n```\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n\nimport { AppComponent } from './app.component';\nimport { PopupComponent } from './popup.component';\nimport { PopupService } from './popup.service';\n\n@NgModule({\n  imports: [BrowserModule, BrowserAnimationsModule],\n  providers: [PopupService],\n  declarations: [AppComponent, PopupComponent],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {\n}\n```\n*app.component.ts*\n```\nimport { Component, Injector } from '@angular/core';\nimport { createCustomElement } from '@angular/elements';\nimport { PopupService } from './popup.service';\nimport { PopupComponent } from './popup.component';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <input #input value=\"Message\">\n    <button (click)=\"popup.showAsComponent(input.value)\">Show as component</button>\n    <button (click)=\"popup.showAsElement(input.value)\">Show as element</button>\n  `,\n})\nexport class AppComponent {\n  constructor(injector: Injector, public popup: PopupService) {\n    // Convert `PopupComponent` to a custom element.\n    const PopupElement = createCustomElement(PopupComponent, {injector});\n    // Register the custom element with the browser.\n    customElements.define('popup-element', PopupElement);\n  }\n}\n```\n\n\n### Typings for custom elements\n\n\n**Generic DOM APIs, such as document.createElement() or document.querySelector(), return an element type that is appropriate for the specified arguments**. For example, calling document.createElement('a') returns an HTMLAnchorElement, which TypeScript knows has an href property. Similarly, document.createElement('div') returns an HTMLDivElement, which TypeScript knows has no href property.\n\n**When called with unknown elements, such as a custom element name (popup-element in our example), the methods return a generic type, such as HTMLElement**, because TypeScript can't infer the correct type of the returned element.\n\n**Custom elements created with Angular extend *NgElement* (which in turn extends HTMLElement)**. Additionally, these custom elements will have a property for each input of the corresponding component. For example, our popup-element has a message property of type string.\n\nThere are a few options if you want to get correct types for your custom elements. Assume you create a my-dialog custom element based on the following component:\n\n```\n@Component(...)\nclass MyDialog {\n  @Input() content: string;\n}\n``` \nThe most straightforward way **to get accurate typings is to cast the return value of the relevant DOM methods to the correct type**. For that, **use the *NgElement* and *WithProperties* types** (both exported from @angular/elements):\n\n```\nconst aDialog = document.createElement('my-dialog') as NgElement & WithProperties<{content: string}>;\naDialog.content = 'Hello, world!';\naDialog.content = 123;  // <-- ERROR: TypeScript knows this should be a string.\naDialog.body = 'News';  // <-- ERROR: TypeScript knows there is no `body` property on `aDialog`.\n```\n\nThis is a good way to quickly get TypeScript features, such as type checking and autocomplete support, for your custom element. But **it can get cumbersome if you need it in several places, because you have to cast the return type on every occurrence**.\n\n**An alternative way, that only requires defining each custom element's type once, is augmenting the *HTMLElementTagNameMap***, which TypeScript uses to infer the type of a returned element based on its tag name (for DOM methods such as document.createElement(), document.querySelector(), etc.):\n\n```\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'my-dialog': NgElement & WithProperties<{content: string}>;\n    'my-other-element': NgElement & WithProperties<{foo: 'bar'}>;\n    ...\n  }\n}\n```\n\nNow, TypeScript can infer the correct type the same way it does for built-in elements:\n\n```\ndocument.createElement('div')               //--> HTMLDivElement (built-in element)\ndocument.querySelector('foo')               //--> Element        (unknown element)\ndocument.createElement('my-dialog')         //--> NgElement & WithProperties<{content: string}> (custom element)\ndocument.querySelector('my-other-element')  //--> NgElement & WithProperties<{foo: 'bar'}>      (custom element)\n```\n\n","references":"- [Angular.io - Angular Elements](https://angular.io/guide/elements)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-elements-overview","weblink":"https://codersnack.com/angular-elements-overview","featured_image_preview":{"id":147,"name":"angular-icon.png","hash":"a85027fe74b74588bf91c7d75849cdd1","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/a85027fe74b74588bf91c7d75849cdd1.png","provider":"local","provider_metadata":null,"created_at":"2021-11-24T12:34:15.468Z","updated_at":"2021-11-24T12:34:15.468Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Angular Elements Overview","created_at":"2021-11-24T12:34:40.846Z","updated_at":"2021-11-24T12:34:40.851Z"}]