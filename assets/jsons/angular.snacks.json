[{"id":81,"codersnack":{"id":82,"header":"What is Angular?","created_at":"2020-06-15T09:44:23.825Z","updated_at":"2020-06-16T21:21:09.533Z","explanation":"**Angular is a platform and framework for building single-page client applications using HTML and TypeScript**. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps.\n\nThe architecture of an Angular application relies on certain fundamental concepts. The basic building blocks are **NgModules**, which provide **a compilation context for components**. NgModules collect related code into functional sets; **an Angular app is defined by a set of NgModules**. An app always has at least a root module that enables bootstrapping, and typically has many more feature modules.\n\n**Components define views**, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.\n\n**Components use services**, which provide specific functionality not directly related to views. Service providers can be injected into components as dependencies, making your code modular, reusable, and efficient.\n\n**Both components and services are simply classes, with decorators** that mark their type and provide metadata that tells Angular how to use them.\n\nThe metadata for a component class associates it with a template that defines a view. A template combines ordinary HTML with Angular directives and binding markup that allow Angular to modify the HTML before rendering it for display.\n\n> The metadata for a service class provides the information Angular needs to make it available to components through **dependency injection (DI)**.\n\nAn app's components typically define many views, arranged hierarchically. Angular provides the **Router service** to help you define navigation paths among views. The router provides sophisticated in-browser navigational capabilities.\n\n\n## Modules\n\n*Angular NgModules differ from and complement JavaScript (ES2015) modules*. **An NgModule declares a compilation context for a set of components that is dedicated to an application domain**, a workflow, or a closely related set of capabilities. An NgModule can associate its components with related code, such as services, to form functional units.\n\n**Every Angular app has a root module, conventionally named AppModule**, which provides the bootstrap mechanism that launches the application. An app typically contains many functional modules.\n\n**Like JavaScript modules, NgModules can import functionality from other NgModules**, and allow their own functionality to be exported and used by other NgModules. For example, to use the router service in your app, you import the Router NgModule.\n\n> Organizing your code into distinct functional modules helps in managing development of complex applications, and in designing for reusability. In addition, this technique lets you take advantage of lazy-loading, that is, loading modules on demand, to minimize the amount of code that needs to be loaded at startup.\n\n\n## Components\n\n**Every Angular application has at least one component, the root component that connects a component hierarchy with the page document object model (DOM)**. Each component defines a class that contains application data and logic, and is associated with an HTML template that defines a view to be displayed in a target environment.\n\nThe **@Component() decorator** identifies the class immediately below it as a component, and provides the template and related component-specific metadata.\n\n**Decorators are functions that modify JavaScript classes**. Angular defines a number of decorators that attach specific kinds of metadata to classes, so that the system knows what those classes mean and how they should work.\n\n\n\n## Templates, directives, and data binding\n\n**A template combines HTML with Angular markup that can modify HTML elements before they are displayed**. *Template directives provide program logic, and binding markup connects your application data and the DOM*. There are two types of data binding:\n\n- **Event binding** lets your app respond to user input in the target environment by updating your application data.\n- **Property binding** lets you interpolate values that are computed from your application data into the HTML.\n\nBefore a view is displayed, Angular evaluates the directives and resolves the binding syntax in the template to modify the HTML elements and the DOM, according to your program data and logic. Angular supports **two-way data binding**, meaning that changes in the DOM, such as user choices, are also reflected in your program data.\n\nYour templates can use **pipes to improve the user experience by transforming values for display**. For example, use pipes to display dates and currency values that are appropriate for a user's locale. Angular provides predefined pipes for common transformations, and you can also define your own pipes.\n\n\n## Services and dependency injection\n\n**For data or logic that isn't associated with a specific view, and that you want to share across components, you create a service class**. A service class definition is immediately preceded by the **@Injectable() decorator.** The decorator provides the metadata that allows other providers to be injected as dependencies into your class.\n\nDependency injection (DI) lets you keep your component classes lean and efficient. They don't fetch data from the server, validate user input, or log directly to the console; they delegate such tasks to services.\n\n## Routing\n\nThe Angular Router NgModule provides a service that lets you define a navigation path among the different application states and view hierarchies in your app. It is modeled on the familiar browser navigation conventions:\n\n- **Enter a URL in the address bar** and the browser navigates to a corresponding page.\n\n- **Click links** on the page and the browser navigates to a new page.\n\n- **Click the browser's back** and forward buttons and the browser navigates backward and forward through the history of pages you've seen.\n\n**The router maps URL-like paths to views instead of pages**. When a user performs an action, such as clicking a link, that would load a new page in the browser, the router intercepts the browser's behavior, and shows or hides view hierarchies.\n\nIf the router determines that the current application state requires particular functionality, and the module that defines it hasn't been loaded, the **router can lazy-load the module on demand.**\n\nThe router interprets a link URL according to your app's view navigation rules and data state. You can navigate to new views when the user clicks a button or selects from a drop box, or in response to some other stimulus from any source. **The router logs activity in the browser's history, so the back and forward buttons work as well**.\n\nTo define navigation rules, you associate navigation paths with your components. A path uses a URL-like syntax that integrates your program data, in much the same way that template syntax integrates your views with your program data. You can then apply program logic to choose which views to show or to hide, in response to user input and your own access rules.\n\n\n![angular overview](https://codersnack.com/assets/images/angular-overview2.png)\n\n\n- A decorator on a component class adds the metadata, including a pointer to the associated template.\n- Directives and binding markup in a component's template modify views based on program data and logic.\n- The dependency injector provides services to a component, such as the router service that lets you define navigation among views.\n","references":"- [Angular.io Architecture](https://angular.io/guide/architecture)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-what-is","weblink":"https://codersnack.com/angular-what-is","featured_image_preview":{"id":112,"name":"angular-icon.png","hash":"dfe02d1bea914ebd87a76c38b95ea20d","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/dfe02d1bea914ebd87a76c38b95ea20d.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T09:44:23.836Z","updated_at":"2020-06-15T09:44:23.836Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular What is","created_at":"2020-06-15T09:44:44.777Z","updated_at":"2020-06-15T09:44:44.780Z"},{"id":82,"codersnack":{"id":83,"header":"Angular Data Biding and Pipes and Directives","created_at":"2020-06-15T17:04:11.159Z","updated_at":"2020-06-16T21:03:05.124Z","explanation":"## Data binding\n\n**Without a framework, you would be responsible for pushing data values into the HTML controls** and turning user responses into actions and value updates. Writing such push and pull logic by hand is tedious, error-prone, and a nightmare to read, as any experienced front-end JavaScript programmer can attest.\n\n**Angular supports two-way data binding**, a mechanism for coordinating the parts of a template with the parts of a component. Add binding markup to the template HTML to tell Angular how to connect both sides.\n\nThe following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both.\n\n![angular databinding](https://codersnack.com/assets/images/angular-databinding.png)\n\nThis example from the HeroListComponent template uses three of these forms.\n\n*src/app/hero-list.component.html (binding)*\n```\n<li>{{hero.name}}</li>\n<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>\n<li (click)=\"selectHero(hero)\"></li>\n```\n\nThe ``` {{hero.name}} ``` interpolation displays the component's *hero.name* property value within the ``` <li> ``` element.\n\nThe ```[hero]``` property binding passes the value of *selectedHero* from the parent *HeroListComponent* to the *hero* property of the child *HeroDetailComponent*.\n\nThe ```(click)``` event binding calls the component's *selectHero* method when the user clicks a hero's name.\n\n**Two-way data binding (used mainly in template-driven forms) combines property and event binding in a single notation**. Here's an example from the *HeroDetailComponent* template that uses two-way data binding with the *ngModel directive*.\n\n*src/app/hero-detail.component.html (ngModel)*\n```\n<input [(ngModel)]=\"hero.name\">\n```\nIn two-way binding, a data property value flows to the input box from the component as with property binding. The user's changes also flow back to the component, resetting the property to the latest value, as with event binding.\n\n> Angular processes all data bindings once for each JavaScript event cycle, from the root of the application component tree through all child components.\n\n\nData binding plays an important role in communication between a template and its component, and is also important for communication between parent and child components.\n\n## Pipes\n\n**Angular pipes let you declare display-value transformations in your template HTML**. A class with the **@Pipe decorator** defines a function that transforms input values to output values for display in a view.\n\n**Angular defines various pipes**, such as the date pipe and currency pipe; for a complete list, see the Pipes API list. You can also define new pipes.\n\nTo specify a value transformation in an HTML template, use the **pipe operator (|)**.\n```\n{{interpolated_value | pipe_name}}\n```\n\n**You can chain pipes**, sending the output of one pipe function to be transformed by another pipe function. **A pipe can also take arguments** that control how it performs its transformation. For example, you can pass the desired format to the date pipe.\n\n\n\n## Directives\n\nAngular templates are dynamic. **When Angular renders them, it transforms the DOM according to the instructions given by directives**. **A directive is a class with a @Directive() decorator**.\n\n> A component is technically a directive. However, components are so distinctive and central to Angular applications that Angular defines the **@Component()** decorator, which extends the **@Directive()** decorator with template-oriented features.\n\n**In addition to components, there are two other kinds of directives: structural and attribute**. Angular defines a number of directives of both kinds, and you can define your own using the **@Directive()** decorator.\n\nJust as for components, the metadata for a directive associates the decorated class with a selector element that you use to insert it into HTML. In templates, directives typically appear within an element tag as attributes, either by name or as the target of an assignment or a binding.\n\n### Structural directives\n\n**Structural directives alter layout by adding, removing, and replacing elements in the DOM**. The example template uses two built-in structural directives to add application logic to how the view is rendered.\n\n*src/app/hero-list.component.html (structural)*\n```\n<li *ngFor=\"let hero of heroes\"></li>\n<app-hero-detail *ngIf=\"selectedHero\"></app-hero-detail>\n```\n\n``` *ngFor ``` is an **iterative**:  it tells Angular to stamp out one ``` <li> ``` per hero in the heroes list.\n``` *ngIf ``` is a **conditional**: it includes the *HeroDetail* component only if a selected hero exists.\n\n### Attribute directives\n\n**Attribute directives alter the appearance or behavior of an existing element**. In templates they look like regular HTML attributes, hence the name.\n\nThe **ngModel** directive, which implements two-way data binding, is an example of an attribute directive. ngModel modifies the behavior of an existing element (typically ```<input>```) by setting its display value property and responding to change events.\n\n*src/app/hero-detail.component.html (ngModel)*\n```\n<input [(ngModel)]=\"hero.name\">\n```\n**Angular has more pre-defined directives** that either alter the layout structure (for example, ngSwitch) or modify aspects of DOM elements and components (for example, ngStyle and ngClass).\n\n","references":"- [Angular.io Architecture Components](https://angular.io/guide/architecture-components)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-data-binding-pipes-directives","weblink":"https://codersnack.com/angular-data-binding-pipes-directives","featured_image_preview":{"id":113,"name":"angular-icon.png","hash":"95a0b7ed921145449b6a97243a0ed410","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/95a0b7ed921145449b6a97243a0ed410.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T17:04:11.173Z","updated_at":"2020-06-15T17:04:11.173Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Data Binding & Pipes & Directives","created_at":"2020-06-15T17:04:59.993Z","updated_at":"2020-06-15T17:04:59.999Z"},{"id":90,"codersnack":{"id":91,"header":"Angular - Observables","created_at":"2021-04-11T16:02:37.392Z","updated_at":"2021-04-11T17:47:36.215Z","explanation":"\nAngular makes use of **observables as an interface to handle a variety of common asynchronous operations**. For example:\n\t•\tYou can define **custom events** that send observable output data from a child to a parent component.\n\t•\tThe HTTP module uses observables to **handle AJAX requests and responses**.\n\t•\tThe **Router and Forms modules use observables** to listen for and respond to user-input events.\n\n### Transmitting data between components\n\nAngular provides an **EventEmitter** class that is used when publishing values from a component through the ```@Output()``` decorator. EventEmitter extends RxJS\nSubject, adding an **emit()** method so it can send arbitrary values. When you call **emit()**, it passes the emitted value to the **next()** method of any **subscribed observer**.\nA good example of usage can be found in the EventEmitter documentation. Here is the example component that listens for open and close events:\n```\n<app-zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></app-zippy>\n```\n\nHere is the component definition:\n\n**ZippyComponent**\n```\n@Component({\n  selector: 'app-zippy',\n  template: `\n    <div class=\"zippy\">\n      <div (click)=\"toggle()\">Toggle</div>\n      <div [hidden]=\"!visible\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  `,\n})\nexport class ZippyComponent {\n  visible = true;\n  @Output() open = new EventEmitter<any>();\n  @Output() close = new EventEmitter<any>();\n\n  toggle() {\n    this.visible = !this.visible;\n    if (this.visible) {\n      this.open.emit(null);\n    } else {\n      this.close.emit(null);\n    }\n  }\n}\n```\n\n### HTTP\n\n\n**Angular’s HttpClient returns observables from HTTP method calls**. For instance, ```http.get(‘/api’)``` returns an observable. This provides **several advantages over promise-based HTTP APIs**:\n\n- Observables **do not mutate the server response** (as can occur through chained .then() calls on promises). Instead, you can use a series of **operators to transform values** as needed.\n- HTTP requests are **cancellable** through the unsubscribe() method.\n- Requests can be configured to **get progress event updates**.\n- **Failed requests can be retried easily**.\n\n### Async pipe\n\n**The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted**. When a new value is emitted, the pipe marks the component to be checked for changes.\n\nThe following example binds the time observable to the component's view. The observable continuously updates the view with the current time.\n\n```\n@Component({\n  selector: 'async-observable-pipe',\n  template: `<div><code>observable|async</code>:\n       Time: {{ time | async }}</div>`\n})\nexport class AsyncObservablePipeComponent {\n  time = new Observable<string>(observer => {\n    setInterval(() => observer.next(new Date().toString()), 1000);\n  });\n}\n```\n\n### Router\n\n**Router.events** provides **events as observables**. You can use the ```filter()``` operator from **RxJS** to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process. Here's an example:\n\n```\nimport { Router, NavigationStart } from '@angular/router';\nimport { filter } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable1Component implements OnInit {\n\n  navStart: Observable<NavigationStart>;\n\n  constructor(private router: Router) {\n    // Create a new Observable that publishes only the NavigationStart event\n    this.navStart = router.events.pipe(\n      filter(evt => evt instanceof NavigationStart)\n    ) as Observable<NavigationStart>;\n  }\n\n  ngOnInit() {\n    this.navStart.subscribe(evt => console.log('Navigation Started!'));\n  }\n}\n```\n\nThe **ActivatedRoute** is an injected router service that makes use of observables to get information about a route path and parameters. For example, ActivatedRoute.url contains an observable that reports the route path or paths. Here's an example:\n\n```\nimport { ActivatedRoute } from '@angular/router';\n\n@Component({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable2Component implements OnInit {\n  constructor(private activatedRoute: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.activatedRoute.url\n      .subscribe(url => console.log('The URL changed to: ' + url));\n  }\n}\n```\n\n### Reactive forms\n\n**Reactive forms have properties that use observables to monitor form control values**. The **FormControl** properties **valueChanges** and **statusChanges** contain observables that raise **change events**. Subscribing to an observable form-control property **is a way of triggering application logic within the component class**. For example:\n```\nimport { FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'my-component',\n  template: 'MyComponent Template'\n})\nexport class MyComponent implements OnInit {\n  nameChangeLog: string[] = [];\n  heroForm: FormGroup;\n\n  ngOnInit() {\n    this.logNameChange();\n  }\n  logNameChange() {\n    const nameControl = this.heroForm.get('name');\n    nameControl.valueChanges.forEach(\n      (value: string) => this.nameChangeLog.push(value)\n    );\n  }\n}\n```\n\n\n","references":"- [Angular.io Observables](https://angular.io/guide/observables-in-angular)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-observables","weblink":"https://codersnack.com/angular-observables","featured_image_preview":{"id":123,"name":"angular-icon.png","hash":"7cb94f9a2140470686ef7b74af452dbd","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb94f9a2140470686ef7b74af452dbd.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T16:02:37.408Z","updated_at":"2021-04-11T16:02:37.408Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Observables","created_at":"2021-04-11T16:33:33.694Z","updated_at":"2021-04-11T16:33:33.697Z"},{"id":91,"codersnack":{"id":92,"header":"Angular - Forms Overview","created_at":"2021-04-11T16:33:05.489Z","updated_at":"2021-04-11T17:03:51.107Z","explanation":"Angular provides **two different approaches** to handling user input through forms: **reactive and template-driven**. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.\n\nThis guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.\n\n\n### Choosing an approach\n\nReactive forms and template-driven forms **process and manage form data differently**. Each approach offers different advantages.\n\n**Reactive forms provide direct, explicit access to the underlying forms object model**. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.\n\n**Template-driven forms rely on directives in the template to create and manipulate the underlying object model**. They are useful for adding a simple form to an app, such as an email list signup form. They're easy to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit.\n\n### Key differences\nThe table below summarizes the key differences between reactive and template-driven forms.\n\n- Setup of form model: REACTIVE: Explicit, created in component class\tTEMPLATE-DRIVEN: Implicit, created by directives\n- Data model:\t REACTIVE: Structured and immutable\tTEMPLATE-DRIVEN: Unstructured and mutable\n- Predictability: REACTIVE: \tSynchronous\tTEMPLATE-DRIVEN:  Asynchronous\n- Form validations: REACTIVE:  Functions\tTEMPLATE-DRIVEN:  Directives\n\n### Scalability\nIf forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical.\n\nReactive forms are more scalable than template-driven forms. They provide direct access to the underlying form API, and synchronous access to the form data model, making creating large-scale forms easier. Reactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation.\n\nTemplate-driven forms focus on simple scenarios and are not as reusable. They abstract away the underlying form API, and provide only asynchronous access to the form data model. The abstraction of template-driven forms also affects testing. Tests are deeply reliant on manual change detection execution to run properly, and require more setup.\n\n### Setting up the form model\nBoth reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.\n\n#### Common form foundation classes\nBoth reactive and template-driven forms are built on the following base classes.\n\n- **FormControl** tracks the value and validation status of an individual form control.\n\n- **FormGroup** tracks the same values and status for a collection of form controls.\n\n- **FormArray** tracks the same values and status for an array of form controls.\n\n- **ControlValueAccessor** creates a **bridge between Angular FormControl instances and native DOM elements**.\n\n#### Setup in reactive forms\nWith reactive forms, you define the form model directly in the component class. The ```[formControl]``` directive links the explicitly created **FormControl** instance to a specific form element in the view, using an internal value accessor.\n\nThe following component implements an input field for a single control, using reactive forms. In this example, the form model is the FormControl instance.\n\n```\n\rimport { Component } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}\n```\n\nFigure 1 shows how, in reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the ```[formControl]``` directive on the input element.\n\nFigure 1. Direct access to forms model in a reactive form.\n![angular reative forms form model](https://codersnack.com/assets/images/angular-reactive-forms-form-model.png)\n\n#### Setup in template-driven forms\nIn template-driven forms, the form model is implicit, rather than explicit. The directive **NgModel** creates and manages a **FormControl** instance for a given form element.\n\nThe following component implements the same input field for a single control, using template-driven forms.\n\n```\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n```\n![angular template driven forms form model](https://codersnack.com/assets/images/angular-template-driven-forms-form-model.png)\n\n\n","references":"- [Angular.io Forms Overview](https://angular.io/guide/forms-overview)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-forms-overview","weblink":"https://codersnack.com/angular-forms-overview","featured_image_preview":{"id":124,"name":"angular-icon.png","hash":"fb4b660af51e467585f8f489b6dc1778","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/fb4b660af51e467585f8f489b6dc1778.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T16:33:05.501Z","updated_at":"2021-04-11T16:33:05.501Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular - Forms overview","created_at":"2021-04-11T16:34:05.963Z","updated_at":"2021-04-11T16:34:05.966Z"},{"id":92,"codersnack":{"id":93,"header":"Angular - Forms Overview II","created_at":"2021-04-11T17:42:45.795Z","updated_at":"2021-04-11T17:42:45.795Z","explanation":"### Data flow in reactive forms\nIn reactive forms each form element in the view is directly linked to the form model (a FormControl instance). **Updates from the view to the model and from the model to the view are synchronous** and do not depend on how the UI is rendered.\n\nThe **view-to-model diagram** shows **how data flows when an input field's value is changed** from the view through the following steps.\n\n- The **user types a value** into the input element, in this case the favorite color Blue.\n- The **form input element emits an \"input\" event** with the latest value.\n- The **control value accessor listening for events** on the form input element immediately relays the new value to the **FormControl** instance.\n- The **FormControl instance emits the new value through the valueChanges observable**.\n- Any **subscribers to the valueChanges observable receive the new value**.\n\n![angular dataflow reactive forms view to model](https://codersnack.com/assets/images/angular-dataflow-reactive-forms-vtm.png)\n\nThe **model-to-view diagram** shows how a programmatic change to the model is propagated to the view through the following steps.\n\n- The user calls the ```favoriteColorControl.setValue()``` method, which updates the **FormControl** value.\n- The **FormControl** instance **emits the new value through the valueChanges observable**.\n- Any **subscribers** to the **valueChanges** observable receive the new value.\n- The **control value accessor on the form input element updates the element with the new value**.\n\n![angular dataflow reactive forms model to view](https://codersnack.com/assets/images/angular-dataflow-reactive-forms-mtv.png)\n\n### Data flow in template-driven forms\nIn template-driven forms, **each form element is linked to a directive that manages the form model internally**.\n\nThe **view-to-model** diagram shows how data flows when an input field's value is changed from the view through the following steps.\n\n- The **user types** Blue into the input element.\n- The **input element emits an \"input\" event** with the value Blue.\n- The **control value accessor** attached to the input triggers the ```setValue()``` method on the **FormControl** instance.\n- The **FormControl** instance **emits** the new value through the **valueChanges** observable.\n- Any **subscribers** to the **valueChanges** observable receive the new value.\n- The **control value accessor** also calls the ```NgModel.viewToModelUpdate()``` method which emits an **ngModelChange event**.\n- Because the **component template uses two-way data binding** for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the **ngModelChange** event (Blue).\n\n![angular dataflow template driven forms - view to model](https://codersnack.com/assets/images/angular-dataflow-td-forms-vtm.png)\n\nThe **model-to-view diagram** shows how data flows from model to view when the favoriteColor changes from Blue to Red, through the following steps\n\n- The favoriteColor **value is updated in the component**.\n- Change detection begins.\n- During change detection, the **ngOnChanges** lifecycle hook is called on the **NgModel** directive instance because the value of one of its inputs has changed.\n- The **ngOnChanges()** method queues an **async task** to set the value for the internal **FormControl** instance.\n- Change detection completes.\n- On the **next tick**, the task to set the **FormControl instance value is executed**.\n- The **FormControl** instance **emits the latest value through the valueChanges observable**.\n- Any **subscribers** to the **valueChanges** observable receive the new value.\n- The **control value accessor updates the form input element in the view** with the latest favoriteColor value.\n\n![angular dataflow template driven forms - model to view](https://codersnack.com/assets/images/angular-dataflow-td-forms-mtv.png)\n\n### Mutability of the data model\n\nThe change-tracking method plays a role in the **efficiency of your application**.\n\n**Reactive forms keep the data model pure by providing it as an immutable data structure**. Each time a change is triggered on the data model, the **FormControl** instance **returns a new data model** rather than updating the existing data model. This gives you the **ability to track unique changes** to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data.\n\n**Template-driven forms rely on mutability with two-way data binding** to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, **change detection is less efficient** at determining when updates are required.\n\nThe difference is demonstrated in the previous examples that use the favorite-color input element.\n\n- With reactive forms, the FormControl instance always returns a new value when the control's value is updated.\n\n- With template-driven forms, the favorite color property is always modified to its new value.\n\n### Form validation\n\nValidation is an integral part of managing any set of forms. Whether you're checking for required fields or querying an external API for an existing username, **Angular provides a set of built-in validators as well as the ability to create custom validators**.\n\n- Reactive forms define custom validators as functions that receive a control to validate.\n- Template-driven forms are tied to template directives, and must provide custom validator directives that wrap validation functions.\nFor more information, see Form Validation.\n\n### Testing\n\nTesting plays a large part in complex applications. A simpler testing strategy is useful when validating that your forms function correctly. Reactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms.\n\n#### Testing reactive forms\n**Reactive forms provide a relatively easy testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI**. In these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle.\n\nThe following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form.\n\nThe first example performs the following steps to verify the **view-to-model data flow**.\n\nQuery the view for the form input element, and create a custom \"input\" event for the test.\nSet the new value for the input to Red, and dispatch the \"input\" event on the form input element.\nAssert that the component's favoriteColorControl value matches the value from the input.\n\n```\nit('should update the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});\n```\n\nThe next example performs the following steps to verify the **model-to-view data flow.**\n\nUse the favoriteColorControl, a FormControl instance, to set the new value.\nQuery the view for the form input element.\nAssert that the new value set on the control matches the value in the input.\n\n```\nit('should update the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});\n```\n#### Testing template-driven forms\n\n**Writing tests with template-driven forms requires a detailed knowledge of the change detection process** and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.\n\nThe following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form.\n\nThe following test verifies the data flow from view to model.\n\n```\n\rit('should update the favorite color in the component', fakeAsync(() => {\n     const input = fixture.nativeElement.querySelector('input');\n     const event = createNewEvent('input');\n\n     input.value = 'Red';\n     input.dispatchEvent(event);\n\n     fixture.detectChanges();\n\n     expect(component.favoriteColor).toEqual('Red');\n   }));\n```\nHere are the steps performed in the view to model test.\n\n- Query the view for the form input element, and create a custom \"input\" event for the test.\n- Set the new value for the input to Red, and dispatch the \"input\" event on the form input element.\n- **Run change detection through the test fixture**.\n- Assert that the component favoriteColor property value matches the value from the input.\n\nThe following test verifies the data flow from model to view.\n\n```\nit('should update the favorite color on the input field', fakeAsync(() => {\n     component.favoriteColor = 'Blue';\n\n     fixture.detectChanges();\n\n     tick();\n\n     const input = fixture.nativeElement.querySelector('input');\n\n     expect(input.value).toBe('Blue');\n   }));\n```\n\nHere are the steps performed in the model to view test.\n\n- Use the component instance to set the value of the favoriteColor property.\n- Run change detection through the test fixture.\n- Use the **tick() method to simulate the passage of time within the fakeAsync() task.**\n- Query the view for the form input element.\n- Assert that the input value matches the value of the favoriteColor property in the component instance.\n","references":"- [Angular.io Forms Overview](https://angular.io/guide/forms-overview)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-forms-overview-2","weblink":"https://codersnack.com/angular-forms-overview-2","featured_image_preview":{"id":125,"name":"angular-icon.png","hash":"2ba0c1b38be44e0db8dad4040990481d","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/2ba0c1b38be44e0db8dad4040990481d.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T17:42:45.804Z","updated_at":"2021-04-11T17:42:45.804Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Forms Overview II","created_at":"2021-04-11T17:43:07.674Z","updated_at":"2021-04-11T17:43:07.690Z"},{"id":93,"codersnack":{"id":94,"header":"Angular - Reactive Forms","created_at":"2021-04-11T21:22:33.826Z","updated_at":"2021-04-11T21:25:32.590Z","explanation":"Reactive forms provide a model-driven approach to handling form inputs whose values change over time. This guide shows you how to create and update a basic form control, progress to using multiple controls in a group, validate form values, and create dynamic forms where you can add or remove controls at run time.\n\n### Overview of reactive forms\n\n**Reactive forms use an explicit and immutable approach to managing the state of a form** at a given point in time. Each change to the form state returns a new state, which maintains the integrity of the model between changes. **Reactive forms are built around observable streams**, where form inputs and values are provided as streams of input values, which can be accessed synchronously.\n\n**Reactive forms also provide a straightforward path to testing** because you are assured that your data is consistent and predictable when requested. Any consumers of the streams have access to manipulate that data safely.\n\nReactive forms differ from template-driven forms in distinct ways. Reactive forms provide more predictability with synchronous access to the data model, immutability with observable operators, and change tracking through observable streams.\n\nTemplate-driven forms allow direct access to modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously.\n\n### Adding a basic form control\n\nThere are three steps to using form controls.\n\n- **Register the reactive forms module** in your app. This module declares the reactive-form directives that you need to use reactive forms.\n- **Generate** a new **FormControl** instance and save it in the component.\n- **Register** the **FormControl** in the template.\n\nYou can then display the form by adding the component to the template.\n\nThe following examples show how to add a single form control. In the example, the user enters their name into an input field, captures that input value, and displays the current value of the form control element.\n\n**Register the reactive forms module**\n\nTo use reactive form controls, **import ReactiveFormsModul**e from the **@angular/forms** package and add it to your **NgModule's** imports array.\n\n**app.module.ts**\n```\nimport { ReactiveFormsModule } from '@angular/forms';\n\n@NgModule({\n  imports: [\n    // other imports ...\n    ReactiveFormsModule\n  ],\n})\nexport class AppModule { }\n```\n\n**Generate a new FormControl**\n\nUse the CLI command ng generate to generate a component in your project to host the control.\n\n```\nng generate component NameEditor\n```\nTo register a single form control, **import** the **FormControl** class and **create a new instance of FormControl** to save as a class property.\n\n**src/app/name-editor/name-editor.component.ts**\n\n```\nimport { Component } from '@angular/core';\nimport { FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.css']\n})\nexport class NameEditorComponent {\n  name = new FormControl('');\n}\n```\n\n**Use the constructor of FormControl to set its initial value**, which in this case is an empty string. By creating these controls in your component class, you get immediate access to listen for, update, and validate the state of the form input.\n\n**Register the control in the template**\n\nAfter you create the control in the component class, **you must associate it with a form control element in the template**. Update the template with the form control using the **formControl binding** provided by **FormControlDirective**, which is also included in the **ReactiveFormsModule**.\n\n**src/app/name-editor/name-editor.component.html**\n\n```\n<label>\n  Name:\n  <input type=\"text\" [formControl]=\"name\">\n</label>\n```\n\nUsing the template binding syntax, **the form control is now registered** to the name input element in the template. **The form control and DOM element communicate with each other**: the view reflects changes in the model, and the model reflects changes in the view.\n\n**Display the component**\n\nThe form control assigned to name is displayed when the component is added to a template.\n\n**src/app/app.component.html (name editor)**\n\n```\n<app-name-editor></app-name-editor>\n```\n\n### Displaying a form control value\n\nYou can display the value in the following ways.\n\nThrough the **valueChanges observable** where you can listen for changes in the form's value in the template using **AsyncPipe** or in the component class using the **subscribe() method**.\n\nWith the value property, which gives you a snapshot of the current value.\n\nThe following example shows you how to display the current value using interpolation in the template.\n\nsrc/app/name-editor/name-editor.component.html (control value)\n\n```\n<p>\n  Value: {{ name.value }}\n</p>\n```\nThe displayed value changes as you update the form control element.\n\nReactive forms provide access to information about a given control through properties and methods provided with each instance. These properties and methods of the underlying **AbstractControl** class are used to control form state and determine when to display messages when handling input validation.\n\nRead about other FormControl properties and methods in the API Reference.\n\n### Replacing a form control value\n\nReactive forms have methods to change a control's value programmatically, which gives you the flexibility to update the value without user interaction. A form control instance provides a ```setValue()```  method that updates the value of the form control and validates the structure of the value provided against the control's structure. For example, when retrieving form data from a backend API or service, use the **setValue()** method to update the control to its new value, replacing the old value entirely.\n\nThe following example adds a method to the component class to update the value of the control to Nancy using the setValue() method.\n\n**src/app/name-editor/name-editor.component.ts (update value)**\n```\nupdateName() {\n  this.name.setValue('Nancy');\n}\n```\nUpdate the template with a button to simulate a name update. When you click the Update Name button, the value entered in the form control element is reflected as its current value.\nsrc/app/name-editor/name-editor.component.html (update value)\n\n```\n<p>\n  <button (click)=\"updateName()\">Update Name</button>\n</p>\n```\n**The form model is the source of truth for the control**, so when you click the button, the value of the input is changed within the component class, overriding its current value.\n\n>Note: In this example, you're using a single control. When using the setValue() method with a form group or form array instance, the value needs to match the structure of the group or array.\n\n\n\n\n\n","references":"- [Angular.io Reactive Forms](https://angular.io/guide/reactive-forms)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-reactive-forms","weblink":"https://codersnack.com/angular-reactive-forms","featured_image_preview":{"id":126,"name":"angular-icon.png","hash":"ba12f1cfa79042b3b21f01c911d505c8","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/ba12f1cfa79042b3b21f01c911d505c8.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T21:22:33.835Z","updated_at":"2021-04-11T21:22:33.835Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Reactive Forms","created_at":"2021-04-11T21:23:06.810Z","updated_at":"2021-04-11T21:23:06.813Z"},{"id":94,"codersnack":{"id":95,"header":"Angular - Reactive Forms - Grouping Form Controls","created_at":"2021-04-11T21:55:02.908Z","updated_at":"2021-04-11T21:55:02.908Z","explanation":"Forms typically contain several related controls. **Reactive forms provide two ways of grouping multiple related controls into a single input form.**\n\n**A form group defines a form with a fixed set of controls that you can manage together**. Form group basics are discussed in this section. You can also nest form groups to create more complex forms.\n\n**A form array defines a dynamic form, where you can add and remove controls at run time**. You can also nest form arrays to create more complex forms. For more about this option, see Creating dynamic forms below.\n\nJust as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single group.\n\nGenerate a ProfileEditor component and import the **FormGroup** and **FormControl** classes from the **@angular/forms package**.\n```\nng generate component ProfileEditor\n```\nTo add a form group to this component, take the following steps.\n\n- Create a FormGroup instance.\n- Associate the FormGroup model and view.\n- Save the form data.\n- Create a FormGroup instance\n\n**Create a property in the component** class named *profileForm* and set the property to a new form group instance. To initialize the form group, provide the constructor with an object of named keys mapped to their control.\n\nFor the profile form, add two form control instances with the names *firstName* and *lastName*.\n\n**src/app/profile-editor/profile-editor.component.ts (form group)**\n```\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css']\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n}\n```\nThe individual form controls are now collected within a group. A **FormGroup** instance provides its model value as an object reduced from the values of each control in the group. A form group instance has the same properties (such as value and untouched) and methods (such as setValue()) as a form control instance.\n\n**Associate the FormGroup model and view**\n\nA form group tracks the status and changes for each of its controls, so if one of the controls changes, the parent control also emits a new status or value change. The model for the group is maintained from its members. After you define the model, you must update the template to reflect the model in the view.\n\n***src/app/profile-editor/profile-editor.component.html (template form group)***\n```\n<form [formGroup]=\"profileForm\">\n  \n  <label>\n    First Name:\n    <input type=\"text\" formControlName=\"firstName\">\n  </label>\n\n  <label>\n    Last Name:\n    <input type=\"text\" formControlName=\"lastName\">\n  </label>\n\n</form>\n```\n\nNote that just as a form group contains a group of controls, the **profileForm FormGroup** is bound to the form element with the FormGroup directive, creating a communication layer between the model and the form containing the inputs. The **formControlName** input provided by the **FormControlName** directive binds each individual input to the form control defined in FormGroup. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value.\n\n**Save form data**\n\nThe ProfileEditor component accepts input from the user, but in a real scenario you want to capture the form value and make available for further processing outside the component. The **FormGroup directive listens for the submit event emitted by the form element and emits an ngSubmit event** that you can bind to a callback function.\n\nAdd an **ngSubmit** event listener to the form tag with the ```onSubmit()``` callback method.\n\n**src/app/profile-editor/profile-editor.component.html (submit event)**\n```\n<form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">\n```\n\nThe **onSubmit()** method in the ProfileEditor component captures the current value of profileForm. Use **EventEmitter** to keep the form encapsulated and to provide the form value outside the component. The following example uses console.warn to log a message to the browser console.\n\n**src/app/profile-editor/profile-editor.component.ts (submit method)**\n```\nonSubmit() {\n  // TODO: Use EventEmitter with form value\n  console.warn(this.profileForm.value);\n}\n```\n\nThe submit event is emitted by the form tag using the native DOM event. You trigger the event by clicking a button with submit type. This allows the user to **press the Enter key to submit** the completed form.\n\nUse a button element to add a button to the bottom of the form to trigger the form submission.\n\nsrc/app/profile-editor/profile-editor.component.html (submit button)\n\n```\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button>\n```\n> Note: The button in the snippet above also has a disabled binding attached to it to disable the button when profileForm is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the Validating form input section.\n\n**Display the component**\n\nTo display the ProfileEditor component that contains the form, add it to a component template.\n\n**src/app/app.component.html (profile editor)**\n```\n<app-profile-editor></app-profile-editor>\n```\nProfileEditor allows you to manage the form control instances for the firstName and lastName controls within the form group instance.\n\n### Creating nested form groups\nForm groups can accept both individual form control instances and other form group instances as children. This makes **composing complex form models easier to maintain and logically group together.**\n\nWhen building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance allows you to break large forms groups into smaller, more manageable ones.\n\nTo make more complex forms, use the following steps.\n\n- Create a nested group.\n- Group the nested form in the template.\n\nSome types of information naturally fall into the same group. A name and address are typical examples of such nested groups, and are used in the following examples.\n\n**Create a nested group**\n\nTo create a nested group in profileForm, add a nested address element to the form group instance.\n\n***src/app/profile-editor/profile-editor.component.ts (nested form group)***\n```\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css']\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl('')\n    })\n  });\n}\n```\n\nIn this example, address group combines the current firstName and lastName controls with the new street, city, state, and zip controls. Even though the address element in the form group is a child of the overall profileForm element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model.\n\n**Group the nested form in the template**\n\nAfter you update the model in the component class, update the template to connect the form group instance and its input elements.\n\nAdd the address form group containing the street, city, state, and zip fields to the ProfileEditor template.\n\n***src/app/profile-editor/profile-editor.component.html (template nested form group)***\n```\n<div formGroupName=\"address\">\n  <h3>Address</h3>\n\n  <label>\n    Street:\n    <input type=\"text\" formControlName=\"street\">\n  </label>\n\n  <label>\n    City:\n    <input type=\"text\" formControlName=\"city\">\n  </label>\n  \n  <label>\n    State:\n    <input type=\"text\" formControlName=\"state\">\n  </label>\n\n  <label>\n    Zip Code:\n    <input type=\"text\" formControlName=\"zip\">\n  </label>\n</div>\n```\n> **Tip** Display the value for the form group instance in the component template using the value property and JsonPipe.\n\n### Updating parts of the data model\nWhen updating the value for a form group instance that contains multiple controls, you may only want to update parts of the model. This section covers how to update specific parts of a form control data model.\n\nThere are two ways to update the model value:\n\n- **Use the setValue() method to set a new value for an individual control**. The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control.\n\n- **Use the patchValue() method to replace any properties defined in the object that have changed in the form model**.\n\n> The strict checks of the setValue() method help catch nesting errors in complex forms, while patchValue() fails silently on those errors.\n\nIn ProfileEditorComponent, use the updateProfile method with the example below to update the first name and street address for the user.\nsrc/app/profile-editor/profile-editor.component.ts (patch value)\n```\nupdateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street'\n    }\n  });\n}\n```\nSimulate an update by adding a button to the template to update the user profile on demand.\n```\n<p>\n  <button (click)=\"updateProfile()\">Update Profile</button>\n</p>\n```\nWhen a user clicks the button, the profileForm model is updated with new values for firstName and street. Notice that street is provided in an object inside the address property. This is necessary because the patchValue() method applies the update against the model structure. PatchValue() only updates properties that the form model defines.","references":"- [Angular.io Reactive Forms](https://angular.io/guide/reactive-forms)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-reactive-forms-grouping-controls","weblink":"https://codersnack.com/angular-reactive-forms-grouping-controls","featured_image_preview":{"id":127,"name":"angular-icon.png","hash":"560e73b933e04fef84cf50263965f20e","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/560e73b933e04fef84cf50263965f20e.png","provider":"local","provider_metadata":null,"created_at":"2021-04-11T21:55:02.917Z","updated_at":"2021-04-11T21:55:02.917Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Reactive Forms - Grouping Form controls","created_at":"2021-04-11T21:55:36.735Z","updated_at":"2021-04-11T21:55:36.739Z"},{"id":95,"codersnack":{"id":96,"header":"Angular - Dynamic Component Loader","created_at":"2021-04-17T12:10:58.891Z","updated_at":"2021-04-17T12:16:19.570Z","explanation":"Component templates are not always fixed. An application may need to load new components at runtime.\n\nThis cookbook shows you how to use ***ComponentFactoryResolver*** **to add components dynamically**.\n\n\n## Dynamic component loading\nThe following example shows how to build a dynamic ad banner.\n\nThe hero agency is planning an ad campaign with several different ads cycling through the banner. New ad components are added frequently by several different teams. This makes it impractical to use a template with a static component structure.\n\nInstead, **you need a way to load a new component without a fixed reference to the component** in the ad banner's template.\n\nAngular comes with its own API for loading components dynamically.\n\n## The anchor directive\n**Before you can add components you have to define an anchor point** to tell Angular **where to insert components**.\n\nThe ad banner uses a helper directive called ```AdDirective``` to mark valid insertion points in the template.\n***src/app/ad.directive.ts***\n```\nimport { Directive, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[adHost]',\n})\nexport class AdDirective {\n  constructor(public viewContainerRef: ViewContainerRef) { }\n}\n```\n```AdDirective``` injects **ViewContainerRef** to gain **access to the view container of the element that will host the dynamically added component**.\n\nIn the ```@Directive``` **decorator**, notice the selector name, *adHost*; that's what you use to apply the directive to the element. The next section shows you how.\n\n## Loading components\nMost of the ad banner implementation is in **ad-banner.component.ts**. To keep things simple in this example, the HTML is in the ```@Component``` decorator's template property as a template string.\n\nThe ```<ng-template>``` **element is where you apply the directive** you just made. To apply the AdDirective, recall the selector from **ad.directive.ts**, ```[adHost]```. Apply that to ```<ng-template>``` without the square brackets. Now Angular knows where to dynamically load components.\n\n***src/app/ad-banner.component.ts (template)***\n```\ntemplate: `\n            <div class=\"ad-banner-example\">\n              <h3>Advertisements</h3>\n              <ng-template adHost></ng-template>\n            </div>\n          `\n```\n\nThe ```<ng-template>``` element is a good choice for dynamic components because **it doesn't render any additional output**.\n\n## Resolving components\nTake a closer look at the methods in **ad-banner.component.ts**.\n\n**AdBannerComponent** takes an array of **AdItem** objects as input, which ultimately comes from **AdService**. **AdItem** **objects specify the type of component to load** and any data to bind to the component. **AdService** returns the actual ads making up the ad campaign.\n\nPassing an array of components to **AdBannerComponent** allows for a dynamic list of ads without static elements in the template.\n\nWith its **getAds()** method, **AdBannerComponent** cycles through the array of AdItems and loads a new component every 3 seconds by calling loadComponent().\n\n***src/app/ad-banner.component.ts (excerpt)***\n```\nexport class AdBannerComponent implements OnInit, OnDestroy {\n  @Input() ads: AdItem[];\n  currentAdIndex = -1;\n  @ViewChild(AdDirective, {static: true}) adHost: AdDirective;\n  interval: any;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) { }\n\n  ngOnInit() {\n    this.loadComponent();\n    this.getAds();\n  }\n\n  ngOnDestroy() {\n    clearInterval(this.interval);\n  }\n\n  loadComponent() {\n    this.currentAdIndex = (this.currentAdIndex + 1) % this.ads.length;\n    const adItem = this.ads[this.currentAdIndex];\n\n    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(adItem.component);\n\n    const viewContainerRef = this.adHost.viewContainerRef;\n    viewContainerRef.clear();\n\n    const componentRef = viewContainerRef.createComponent<AdComponent>(componentFactory);\n    componentRef.instance.data = adItem.data;\n  }\n\n  getAds() {\n    this.interval = setInterval(() => {\n      this.loadComponent();\n    }, 3000);\n  }\n}\n```\n\nThe **loadComponent()** method is doing a lot of the heavy lifting here. Take it step by step. First, it picks an ad.\n\nHow loadComponent() chooses an ad\n\nThe loadComponent() method chooses an ad using some math.\n\nFirst, it sets the *currentAdIndex* by taking whatever it currently is plus one, dividing that by the length of the AdItem array, and using the remainder as the new currentAdIndex value. Then, it uses that value to select an adItem from the array.\n\nAfter *loadComponent()* selects an ad, it uses **ComponentFactoryResolver** to resolve a **ComponentFactory** for each specific component. **The ComponentFactory then creates an instance of each component**.\n\nNext, you're targeting the **viewContainerRef** that exists on this specific instance of the component. How do you know it's this specific instance? Because *it's referring to **adHost*** and ***adHost*** is the directive you set up earlier to tell Angular *where to insert dynamic components*.\n\nAs you may recall, AdDirective injects ViewContainerRef into its constructor. This is how the directive accesses the element that you want to use to host the dynamic component.\n\nTo add the component to the template, you call **createComponent()** on *ViewContainerRef*.\n\nThe **createComponent()** method returns a reference to the loaded component. Use that reference to interact with the component by assigning to its properties or calling its methods.\n\n## The AdComponent interface\nIn the ad banner, all components implement a common ```AdComponent``` **interface** to standardize the API for passing data to the components.\n\nHere are two sample components and the AdComponent interface for reference:\n***ad.component.ts***\n```\nexport interface AdComponent {\n  data: any;\n}\n```\n***hero-job-ad.component.ts***\n```\nimport { Component, Input } from '@angular/core';\n\nimport { AdComponent } from './ad.component';\n\n@Component({\n  template: `\n    <div class=\"job-ad\">\n      <h4>{{data.headline}}</h4>\n\n      {{data.body}}\n    </div>\n  `\n})\nexport class HeroJobAdComponent implements AdComponent {\n  @Input() data: any;\n\n}\n```\n\n***hero-profile.component.ts***\n```\nimport { Component, Input } from '@angular/core';\n\nimport { AdComponent } from './ad.component';\n\n@Component({\n  template: `\n    <div class=\"hero-profile\">\n      <h3>Featured Hero Profile</h3>\n      <h4>{{data.name}}</h4>\n\n      <p>{{data.bio}}</p>\n\n      <strong>Hire this hero today!</strong>\n    </div>\n  `\n})\nexport class HeroProfileComponent implements AdComponent {\n  @Input() data: any;\n}\n```\n\n## Final ad banner\nThe final ad banner looks like this:\n![angular dynamic ad banner](https://codersnack.com/assets/images/angular-dynamic-ad-banner.gif)\n\n\n\n\n\n","references":"- [Angular.io Dynamic Component Loader](https://angular.io/guide/dynamic-component-loader)","featured_image_url":"https://codersnack.com/assets/images/angular-icon.png","slug":"angular-dynamic-component-loader","weblink":"https://codersnack.com/angular-dynamic-component-loader","featured_image_preview":{"id":128,"name":"angular-icon.png","hash":"3e4fc0519b454208800a6fb1c9054ee9","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/3e4fc0519b454208800a6fb1c9054ee9.png","provider":"local","provider_metadata":null,"created_at":"2021-04-17T12:10:58.907Z","updated_at":"2021-04-17T12:10:58.907Z"}},"codersnacks_category":{"id":16,"header":"Angular","description":"Application design framework and development platform for creating efficient and sophisticated single-page apps","snacks_by_cat_json_filename":"angular.snacks.json","key":"angular","image_url":"https://codersnack.com/assets/images/angular-icon.png","created_at":"2020-06-15T08:09:22.351Z","updated_at":"2020-06-15T08:09:22.351Z","image_preview":{"id":111,"name":"angular-icon.png","hash":"7cb9eb2c37354f5ea37f8f452b356334","sha256":"_DvNcAGLvwawG30sKKs5W3JWa2XL-yAlRvyJ4m9NKDc","ext":".png","mime":"image/png","size":4.27,"url":"/uploads/7cb9eb2c37354f5ea37f8f452b356334.png","provider":"local","provider_metadata":null,"created_at":"2020-06-15T08:09:22.360Z","updated_at":"2020-06-15T08:09:22.360Z"}},"title":"Angular Dynamic Component Loader","created_at":"2021-04-17T12:11:34.359Z","updated_at":"2021-04-17T12:11:34.362Z"}]