[{"id":169,"codersnack":{"id":165,"header":"Web Standards - Cookies History & How It works","created_at":"2022-04-06T12:16:58.849Z","updated_at":"2022-04-06T12:18:12.692Z","explanation":"\n##  A brief history of cookies\n\n**HTTP**, or the Hypertext Transfer Protocol, is a **stateless protocol.** According to Wikipedia, its a stateless protocol because it \"does not require the HTTP server to retain information or status about each user for the duration of multiple requests.\" You can still see this today with simple websites – you type in the URL to the browser, the browser makes a request to a server somewhere, and the **server returns the files to render the page and the connection is closed**.\n\nNow **imagine that you need to sign in to a website to see certain content, like with LinkedIn**. The process is largely the same as the one above, but you're presented with a form to enter in your email address and password.\n\nYou enter that information in and your browser sends it to the server. The server checks your login information, and if everything looks good, it sends the data needed to render the page back to your browser.\n\n**But if LinkedIn was truly stateless, once you navigate to a different page, the server would not remember that you just signed in**. It would ask you to **enter in your email address and password again**, check them, then send over the data to render the new page.\n\nThat would be super frustrating, wouldn't it? A lot of developers thought so, too, and found different ways to create stateful sessions on the web.\n\n\n##   The invention of the HTTP cookie\n\n**Lou Montoulli**, a developer at Netscape in the early 90s, had a problem – he was **developing an online store** for another company, MCI, which would store the items in each customer's cart on its servers. This meant that people had to create an account first, it was slow, and it took up a lot of storage.\n\nMCI requested for all of this **data to be stored on each customer's own computer instead**. Also, they wanted everything to **work without customers having to sign in first**.\n\nTo solve this, Lou turned to an idea that was already pretty well known among programmers: the **magic cookie**.\n\nA magic cookie, or just cookie, is a **bit of data that's passed between two computer programs**. They're \"magic\" because the data in the cookie is often a **random key or token**, and is really just meant for the software using it.\n\nLou took the magic cookie concept and applied it to the online store, and later to browsers as a whole.\n\nNow that you know about their history, let's take a quick look at how cookies are used to create **stateful sessions on the web**.\n\n\n##  How cookies work\n\nOne way to think of cookies is that they're a bit **like the wristbands you get when you visit an amusement park.**\n\nFor example, when you sign in to a website, it's like the process of entering an amusement park. First you pay for a ticket, then when you enter the park, the staff checks your ticket and gives you a wristband.\n\nThis is like **how you sign in**:\n- the server **checks** your username and password.\n- **creates** and **stores** a session\n- generates a **unique session id**\n- and **sends back a cookie** with the session id.\n\n> **Note** that the session id is not your password, but is something completely separate and generated on the fly. Proper password handling and authentication is outside the scope of this article, but you can find some in depth guides here.\n\nWhile you're in the amusement park, you can go on any ride by showing your wristband.\n\nSimilarly, **when you make requests to the website you're signed in to, your browser sends your cookie with your session id back to the server**. The server checks for your session using your session id, then returns data for your request.\n\nFinally, once you leave the amusement park, your wristband no longer works – you can't use it to get back into the park or go on more rides.\n\nThis is like **signing out of a website**:\n- Your **browser sends your sign out request to the server** with your cookie, \n- the **server removes your session**\n- and **lets your browser know to remove your session id cookie**.\n\nIf you want to get back into the amusement park, you'd have to buy another ticket and get another wristband. In other words, if you want to continue using the website, you'd have to sign back in.\n\n\n![fireship cookies](https://codersnack.com/assets/images/fireship-cookies.png)\n","references":"- [Everything You Need to Know About Cookies for Web Development - Kris Koishigawa](https://www.freecodecamp.org/news/everything-you-need-to-know-about-cookies-for-web-development/)","featured_image_url":"https://codersnack.com/assets/images/web-standards-logo.png","slug":"web-standards-cookies-history-how-it-works","weblink":"https://codersnack.com/web-standards-cookies-history-how-it-works","featured_image_preview":{"id":206,"name":"web-standards-logo.png","hash":"295cfbb639d547b7a5d81b8879fec5ce","sha256":"h6yD0wBq4kdFylxQGYdTnkT9jouDkB8jx23AYEhxW30","ext":".png","mime":"image/png","size":7.04,"url":"/uploads/295cfbb639d547b7a5d81b8879fec5ce.png","provider":"local","provider_metadata":null,"created_at":"2022-04-06T12:16:58.859Z","updated_at":"2022-04-06T12:16:58.859Z"}},"codersnacks_category":{"id":25,"header":"Web Standards","description":"All about web standards","snacks_by_cat_json_filename":"web-standards.snacks.json","key":"web-standards","image_url":"https://codersnack.com/assets/images/web-standards-logo.png","created_at":"2022-04-06T11:46:29.528Z","updated_at":"2022-04-06T12:28:37.991Z","image_preview":{"id":205,"name":"web-standards-logo.png","hash":"49a914d205d24f1487f0cf52c3b703b0","sha256":"h6yD0wBq4kdFylxQGYdTnkT9jouDkB8jx23AYEhxW30","ext":".png","mime":"image/png","size":7.04,"url":"/uploads/49a914d205d24f1487f0cf52c3b703b0.png","provider":"local","provider_metadata":null,"created_at":"2022-04-06T11:46:29.544Z","updated_at":"2022-04-06T11:46:29.544Z"}},"title":"Web standards - Cookies history and how it works","created_at":"2022-04-06T12:17:43.365Z","updated_at":"2022-04-06T12:17:43.368Z"},{"id":170,"codersnack":{"id":166,"header":"Web Standards - Cookies - Security Concerns","created_at":"2022-04-06T13:35:27.424Z","updated_at":"2022-04-06T13:44:49.786Z","explanation":"\n##  Security concerns with cookies\n\nIn general, cookies are very secure when implemented correctly. Browsers have a lot of built-in limitations that we covered earlier, partly due to the age of the technology, but also to improve security.\n\nStill, **there are a few ways that a bad actor can steal your cookie and use it to wreak havoc**.\n\nWe'll go over some common ways this can happen, and look at different ways to fix it.\n\nAlso, note that any code snippets will be in vanilla JavaScript. If you want to implement these fixes on the server, you'll need to look up the exact syntax for your language or framework.\n\n\n###   Man-in-the-middle attacks\n\nA man-in-the-middle (MitM) attack describes a broad category of attacks where an **attacker sits between a client and a server and intercepts the data going between the two**.\n\n![man-in-the-middle-attack-how-avoid](https://codersnack.com/assets/images/man-in-the-middle-attack-how-avoid.png)\n\nThis can be done in a **lot of ways**: by gaining access to or listening in on an **insecure website**, **mimicking** a public WiFi **router**, DNS **spoofing**, or through **malware** / adware like SuperFish.\n\nHere's a high-level overview of MitM attacks, and how websites can protect themselves and their users:  [Video](https://youtu.be/8OR2dDIaIDw?t=57)\n\nAs a developer, you can greatly reduce the chance of a MitM attack by ensuring that you **enable HTTPS on your server**, use an SSL certificate from a trusted certificate authority, and **ensure your code uses HTTPS instead of the insecure HTTP**.\n\nIn terms of **cookies**, you should add the ***Secure* attribute to your cookies so they can only be sent over a secure HTTPS connection**:\n```\ndocument.cookie = 'dark_mode=false; Secure';\n```\n\nJust remember that the Secure attribute **doesn't actually encrypt any data in your cookie** – it just ensures that the cookie can't be sent over an HTTP connection.\n\nHowever,**a bad actor could still possibly intercept and manipulate the cookie**. To prevent this from happening, you can also **use the *HttpOnly* parameter**:\n\n```\ndocument.cookie = 'dark_mode=false; Secure; HttpOnly';\n```\n\n**Cookies with *HttpOnly* can only be accessed by the server, and not by the browser's Document.cookie API**. This is perfect for things like a login session, where only the server really needs to know if you're signed into a site, and you don't need that information client side.\n\n\n###  XSS attacks\n\nAn **XSS (cross-site scripting) attack** describes a category of attacks **when a bad actor injects unintended, potentially dangerous code into a website**.\n\nThese attacks are very problematic because they could affect every person that visits the site.\n\n\n![cross-site-scripting](https://codersnack.com/assets/images/cross-site-scripting.svg)\n\n> For example, if a site has a comments section and someone is able to include malicious code as a comment, it's possible that every person who visits the site and reads that comment will be affected.\n\n**In terms of *cookies*, if a bad actor pulls off a successful XSS attack on a site, they could gain access to session cookies and access the site as another signed in user**. From there, they may be able to access the other user's settings, buy things as that user and have it shipped to another address, and so on.\n\nHere's a video that gives a high-level overview of the different types of XSS – Reflected, Stored, DOM-based, and Mutation:  [video](https://youtu.be/EoaDgUgS6QA)\n\nAs a developer, you'll want to **ensure that your server enforces the *Same Origin Policy***, and that **any input you receive from people is properly  sanitized**.\n\nAnd like with preventing MitM attacks, **you should set the *Secure* and *HttpOnly*** parameters with any cookies you use:\n```\ndocument.cookie = 'dark_mode=false; Secure; HttpOnly';\n```\n\n###   CSRF attacks\n\nA **CSRF (cross-site request forgery) attack** is **when a bad actor tricks a person into carrying out an unintended, potentially malicious action**.\n\n> For example, if you're signed into a site and click on a link in a comment, if that link is part of a CSRF attack, it may lead to you unintentionally changing your sign in details, or even deleting your account.\n\n![cross-site-request-forgery](https://codersnack.com/assets/images/cross-site-request-forgery.svg)\n\nWhile CSRF attacks are somewhat related to XSS attacks, specifically reflected XSS attacks where someone inserts malicious code into a site, each preys on a different type of trust.\n\nAccording to Wikipedia, while XSS \"exploits the trust a user has for a particular site, CSRF exploits the trust that a site has in a user's browser.\"\n\nHere's a video that explains the basics of CSRF, and gives some useful examples\n[video](https://youtu.be/eWEgUcHPle0)\n\nAs for **cookies**, one way to **prevent possible CSRF attacks is with the *SameSite* flag**:\n\n```\ndocument.cookie = 'dark_mode=false; Secure; HttpOnly; SameSite=Strict';\n```\n\nThere are a few values you can set for SameSite:\n\n- **Lax**: **Cookies are not sent for embedded content (images, iframes, etc.) but are sent when you click on a link or send a request to the origin the cookie is set for**. For example, if you're on testing.com and you click on a link to go to test.com/about, your browser will send your cookie for test.com with that request\n\n- **Strict**: **Cookies are only sent when you click on a link or send a request from the origin the cookie is set for**. For example, your test.com cookie will only be sent while you're in and around test.com, and not coming from other sites like testing.com\n\n- **None**: **Cookies will be sent with every request, regardless of context.** If you set SameSite to None, you must also add the Secure attribute. It's better to avoid this value if possible\n\n> Major browsers handle SameSite a bit differently. For example, if SameSite isn't set on a cookie, Google Chrome sets it to Lax by default.\n\n\n##  Tracking and privacy\n\n###  Third-party cookies\n\n**A cookie is associated with a particular domain and scheme (such as http or https), and may also be associated with subdomains if the *Set-Cookie Domain* attribute is set.** If the cookie domain and scheme match the current page, the cookie is considered to be from the same site as the page, and is referred to as a ***first-party cookie***.\n\n**If the domain and scheme are different, the cookie is not considered to be from the same site, and is referred to as a *third-party cookie***. While the server hosting a web page sets first-party cookies, the page may contain images or other components stored on servers in other domains (for example, ad banners) that may set third-party cookies. These are **mainly used for advertising and tracking across the web**. For example, the types of cookies used by Google.\n\n**A third-party server can create a profile of a user's browsing history and habits based on cookies sent to it by the same browser when accessing multiple sites**. \n\nFirefox, by default, blocks third-party cookies that are known to contain trackers. Third-party cookies (or just tracking cookies) may also be blocked by other browser settings or extensions. Cookie blocking can cause some third-party components (such as social media widgets) not to function as intended.\n\n> **Note**: Servers can (and should) set the cookie **SameSite** attribute to specify whether or not cookies may be sent to third party sites.\n\n\n###  Cookie-related regulations\n\nLegislation or regulations that cover the use of cookies include:\n\n- The General Data Privacy Regulation (GDPR) in the European Union\n- The ePrivacy Directive in the EU\n- The California Consumer Privacy Act\n\n**These regulations have global reach**. They apply to any site on the World Wide Web that users from these jurisdictions access (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among things).\n\nThese regulations include requirements such as:\n\n- Notifying users that your site uses cookies.\n- Allowing users to opt out of receiving some or all cookies.\n- Allowing users to use the bulk of your service without receiving cookies.\n\nThere may be other regulations that govern the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer \"**cookie banner**\" code that helps you comply with these regulations.\n\n","references":"- [Everything You Need to Know About Cookies for Web Development - Kris Koishigawa](https://www.freecodecamp.org/news/everything-you-need-to-know-about-cookies-for-web-development/)","featured_image_url":"https://codersnack.com/assets/images/web-standards-logo.png","slug":"web-standards-cookies-security-concerns","weblink":"https://codersnack.com/web-standards-cookies-security-concerns","featured_image_preview":{"id":207,"name":"web-standards-logo.png","hash":"9bf9809aebf94adb8506a848445f95af","sha256":"h6yD0wBq4kdFylxQGYdTnkT9jouDkB8jx23AYEhxW30","ext":".png","mime":"image/png","size":7.04,"url":"/uploads/9bf9809aebf94adb8506a848445f95af.png","provider":"local","provider_metadata":null,"created_at":"2022-04-06T13:35:27.438Z","updated_at":"2022-04-06T13:35:27.438Z"}},"codersnacks_category":{"id":25,"header":"Web Standards","description":"All about web standards","snacks_by_cat_json_filename":"web-standards.snacks.json","key":"web-standards","image_url":"https://codersnack.com/assets/images/web-standards-logo.png","created_at":"2022-04-06T11:46:29.528Z","updated_at":"2022-04-06T12:28:37.991Z","image_preview":{"id":205,"name":"web-standards-logo.png","hash":"49a914d205d24f1487f0cf52c3b703b0","sha256":"h6yD0wBq4kdFylxQGYdTnkT9jouDkB8jx23AYEhxW30","ext":".png","mime":"image/png","size":7.04,"url":"/uploads/49a914d205d24f1487f0cf52c3b703b0.png","provider":"local","provider_metadata":null,"created_at":"2022-04-06T11:46:29.544Z","updated_at":"2022-04-06T11:46:29.544Z"}},"title":"Web Standards - Cookies - Security","created_at":"2022-04-06T13:35:55.108Z","updated_at":"2022-04-06T13:35:55.112Z"},{"id":187,"codersnack":{"id":84,"header":"Using the Shadow DOM","created_at":"2020-06-23T12:09:16.576Z","updated_at":"2020-06-23T12:39:11.606Z","explanation":"An important aspect of web components is **encapsulation** , being able to keep the markup structure, style, and behavior hidden and separate from other code on the page so that different parts do not clash, and the code can be kept nice and clean. \n\nThe **Shadow DOM API** is a key part of this, providing a way to **attach a hidden separated DOM to an element**. This article covers the basics of using the Shadow DOM.\n\n\n## High-level view\n\nThis article assumes you are already familiar with the concept of the **DOM (Document Object Model)**, a tree-like structure of connected nodes that represents the different elements and strings of text appearing in a markup document (usually an HTML document in the case of web documents). As an example, consider the following HTML fragment:\n``` \n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Simple DOM example</title>\n  </head>\n  <body>\n      <section>\n        <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\">\n        <p>Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a></p>\n      </section>\n  </body>\n</html>\n``` \nThis fragment produces the following DOM structure:\n![dom screenshot](https://codersnack.com/assets/images/wc-dom-screenshot.png)\n\n\n**Shadow DOM allows hidden DOM trees to be attached to elements in the regular DOM tree** ; this shadow DOM tree starts with a shadow root, underneath which can be attached to any elements you want, in the same way as the normal DOM.\n\n![Shadow dom](https://codersnack.com/assets/images/wc-shadow-dom.png)\n\nThere are some **bits of shadow DOM terminology to be aware of**:\n\n- **Shadow host**: The regular DOM node that the shadow DOM is attached to.\n- **Shadow tree**: The DOM tree inside the shadow DOM.\n- **Shadow boundary**: the place where the shadow DOM ends, and the regular DOM begins.\n- **Shadow root**: The root node of the shadow tree.\n\n**You can affect the nodes in the shadow DOM in exactly the same way as non-shadow nodes** ; for example appending children or setting attributes, styling individual nodes using ```element.style.foo```, or adding style to the entire shadow DOM tree inside a ```<style>``` element. **The difference is that none of the code inside a shadow DOM can affect anything outside it, allowing for handy encapsulation**.\n\nNote that the shadow DOM is not a new thing by any means ; **browsers have used it for a long time to encapsulate the inner structure of an element**. Think for example of a ```<video>``` element, with the default browser controls exposed. All you see in the DOM is the ```<video>``` element, but it contains a series of buttons and other controls inside its shadow DOM. The shadow DOM spec has made it so that you are allowed to actually manipulate the shadow DOM of your own custom elements.\n\n## Basic usage\nYou can attach a shadow root to any element using the **Element.attachShadow()** method. This takes as its parameter an options object that contains one option ; *mode* ; with a value of open or closed:\n```\nlet shadow = elementRef.attachShadow({mode: 'open'});\nlet shadow = elementRef.attachShadow({mode: 'closed'});\n```\n***open* means that you can access the shadow DOM using JavaScript written in the main page context**, for example using the **Element.shadowRoot** property:\n\n```\nlet myShadowDom = myCustomElem.shadowRoot;\n```\n**If you attach a shadow root to a custom element with *mode: closed* set, you won't be able to access the shadow DOM from the outside** ; ``` myCustomElem.shadowRoot``` returns null. This is the case with built in elements that contain shadow DOMs, such as ```<video>```.\n\n> ***Note***: As this blog post shows, it is actually fairly easy to work around closed shadow DOMs, and the hassle to completely hide them is often more than it's worth.\n\nIf you are **attaching a shadow DOM to a custom element as part of its constructor** (by far the most useful application of the shadow DOM), you would use something like this:\n\n```\nlet shadow = this.attachShadow({mode: 'open'});\n```\nWhen you've attached a shadow DOM to an element, manipulating it is a matter of just using the same DOM APIs as you use for the regular DOM manipulation:\n\n```\nvar para = document.createElement('p');\nshadow.appendChild(para);\n// etc.\n```\n\n## Working through a simple example\n\nNow let's walk through a simple example to demonstrate the shadow DOM in action inside a custom element ; ```<popup-info-box>``` (see a live example also). This takes an image icon and a text string, and embeds the icon into the page. When the icon is focused, it displays the text in a pop up information box to provide further in-context information. To begin with, in our JavaScript file we define a class called *PopUpInfo*, which extends HTMLElement:\n\n```\nclass PopUpInfo extends HTMLElement {\n  constructor() {\n    // Always call super first in constructor\n    super();\n\n    // write element functionality in here\n\n    ...\n  }\n}\n```\n\nInside the class definition we define the element's **constructor**, which defines all the **functionality the element will have when an instance of it is instantiated**.\n\n### Creating the shadow root\n\nWe first attach a shadow root to the custom element:\n\n```\n// Create a shadow root\nvar shadow = this.attachShadow({mode: 'open'});\n```\n\n### Creating the shadow DOM structure\n\nNext, we use some DOM manipulation to create the element's internal shadow DOM structure:\n\n```\n// Create spans\nvar wrapper = document.createElement('span');\nwrapper.setAttribute('class','wrapper');\nvar icon = document.createElement('span');\nicon.setAttribute('class','icon');\nicon.setAttribute('tabindex', 0);\nvar info = document.createElement('span');\ninfo.setAttribute('class','info');\n\n// Take attribute content and put it inside the info span\nvar text = this.getAttribute('text');\ninfo.textContent = text;\n\n// Insert icon\nvar imgUrl;\nif(this.hasAttribute('img')) {\n  imgUrl = this.getAttribute('img');\n} else {\n  imgUrl = 'img/default.png';\n}\nvar img = document.createElement('img');\nimg.src = imgUrl;\nicon.appendChild(img);\n```\n\n### Styling the shadow DOM\n\nAfter that we create a ```<style>``` element and populate it with some CSS to style it:\n\n```\n// Create some CSS to apply to the shadow dom\nvar style = document.createElement('style');\n\nstyle.textContent = `\n.wrapper {\n  position: relative;\n}\n\n.info {\n  font-size: 0.8rem;\n  width: 200px;\n  display: inline-block;\n  border: 1px solid black;\n  padding: 10px;\n  background: white;\n  border-radius: 10px;\n  opacity: 0;\n  transition: 0.6s all;\n  position: absolute;\n  bottom: 20px;\n  left: 10px;\n  z-index: 3;\n}\n\nimg {\n  width: 1.2rem;\n}\n\n.icon:hover + .info, .icon:focus + .info {\n  opacity: 1;\n}`;\n```\n\n### Attaching the shadow DOM to the shadow root\n\nThe final step is to attach all the created elements to the shadow root:\n\n```\n// attach the created elements to the shadow dom\nshadow.appendChild(style);\nshadow.appendChild(wrapper);\nwrapper.appendChild(icon);\nwrapper.appendChild(info);\n```\n\n### Using our custom element\n\nOnce the class is defined, using the element is as simple as defining it, and putting it on the page, as explained in Using custom elements:\n\n```\n// Define the new element\ncustomElements.define('popup-info', PopUpInfo);\n```\n\n```\n<popup-info img=\"img/alt.png\" text=\"Your card validation code (CVC) is an extra \n                                    security feature — it is the last 3 or 4\n                                    numbers on the back of your card.\">\n```\n\n### Internal versus external styles\n\nIn the above example we apply style to the Shadow DOM using a ```<style>``` element, but it is perfectly possible to do it by referencing an external stylesheet from a ```<link>``` element instead.\n\nFor example, take a look at this code from our *popup-info-box-external-stylesheet* example (see the source code):\n\n```\n// Apply external styles to the shadow dom\nconst linkElem = document.createElement('link');\nlinkElem.setAttribute('rel', 'stylesheet');\nlinkElem.setAttribute('href', 'style.css');\n\n// Attach the created element to the shadow dom\nshadow.appendChild(linkElem);\n```\n\nNote that ```<link>``` elements **do not block paint of the shadow root, so there may be a flash of unstyled content** (FOUC) while the stylesheet loads.\n\n> Many modern browsers implement an optimization for ```<style>``` tags either cloned from a common node or that have identical text, to allow them to share a single backing stylesheet. With this optimization the performance of external and internal styles should be similar.","references":"- [MDN  - Using the Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM#:~:text=let%20shadow%20%3D%20elementRef.,for%20example%20using%20the%20Element.)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-shadow-dom","weblink":"https://codersnack.com/web-components-shadow-dom/","featured_image_preview":{"id":115,"name":"web-components.png","hash":"5ae94abde1204a748c846f218b77c985","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/5ae94abde1204a748c846f218b77c985.png","provider":"local","provider_metadata":null,"created_at":"2020-06-23T12:09:16.609Z","updated_at":"2020-06-23T12:09:16.609Z"}},"codersnacks_category":{"id":25,"header":"Web Standards","description":"All about web standards","snacks_by_cat_json_filename":"web-standards.snacks.json","key":"web-standards","image_url":"https://codersnack.com/assets/images/web-standards-logo.png","created_at":"2022-04-06T11:46:29.528Z","updated_at":"2022-04-06T12:28:37.991Z","image_preview":{"id":205,"name":"web-standards-logo.png","hash":"49a914d205d24f1487f0cf52c3b703b0","sha256":"h6yD0wBq4kdFylxQGYdTnkT9jouDkB8jx23AYEhxW30","ext":".png","mime":"image/png","size":7.04,"url":"/uploads/49a914d205d24f1487f0cf52c3b703b0.png","provider":"local","provider_metadata":null,"created_at":"2022-04-06T11:46:29.544Z","updated_at":"2022-04-06T11:46:29.544Z"}},"title":"Using the shadow DOM (web standards)","created_at":"2022-04-26T08:11:11.946Z","updated_at":"2022-04-26T08:11:11.951Z"},{"id":188,"codersnack":{"id":85,"header":"Web Components - Using Templates and Slots","created_at":"2020-06-23T14:13:26.825Z","updated_at":"2020-06-23T14:13:26.825Z","explanation":"This article explains how you can use the ```<template>``` and ```<slot>``` elements to create a flexible template that can then be used to populate the shadow DOM of a web component.\n\n## The truth about templates\n\n**When you have to reuse the same markup structures repeatedly on a web page, it makes sense to use some kind of a template rather than repeating the same structure over and over again**. This was possible before, but it is made a lot easier by the HTML ```<template>``` element (which is well-supported in modern browsers: https://www.w3schools.com/tags/tag_template.asp ). This element and its contents are not rendered in the DOM, but it can still be referenced using JavaScript.\n\nLet's look at a trivial quick example:\n\n```\n<template id=\"my-paragraph\">\n  <p>My paragraph</p>\n</template>\n```\nThis won't appear in your page until you grab a reference to it with JavaScript and then append it to the DOM, using something like the following:\n\n```\nlet template = document.getElementById('my-paragraph');\nlet templateContent = template.content;\ndocument.body.appendChild(templateContent);\n```\n\nAlthough trivial, you can already start to see how this could be useful.\n\n## Using templates with web components\n\nTemplates are useful on their own, but they work even better with web components. Let's define a web component that uses our template as the content of its shadow DOM. We'll call it ```<my-paragraph>```:\n\n```\ncustomElements.define('my-paragraph',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      let template = document.getElementById('my-paragraph');\n      let templateContent = template.content;\n\n      const shadowRoot = this.attachShadow({mode: 'open'})\n        .appendChild(templateContent.cloneNode(true));\n    }\n  }\n);\n```\n\nThe key point to note here is that **we append a clone of the template content to the shadow root**, created using the **Node.cloneNode()** method.\n\nAnd because we are appending its contents to a shadow DOM, **we can include some styling information inside the template** in a ```<style>``` element, which is then encapsulated inside the custom element. This wouldn't work if we just appended it to the standard DOM.\n\nSo for example:\n\n```\n<template id=\"my-paragraph\">\n  <style>\n    p {\n      color: white;\n      background-color: #666;\n      padding: 5px;\n    }\n  </style>\n  <p>My paragraph</p>\n</template>\n```\n\nNow we can use it by just adding it to our HTML document:\n```\n<my-paragraph></my-paragraph>\n```\n> ***Note***: Templates are well-supported in browsers; the Shadow DOM API is supported by default in Firefox (version 63 onwards), Chrome, Opera, Safari, and Edge (starting with version 79).\n\n## Adding flexibility with slots\n\nSo far so good, but the element isn't very flexible. We can only display one bit of text inside it, meaning that at the moment it is even less useful than a regular paragraph! We can make it possible to **display different text in each element instance** in a nice declarative way using the ```<slot>```  element. This has more limited support than ```<template>```,  available since Chrome 53, Opera 40, Safari 10, Firefox 59, and Edge 79.\n\n**Slots are identified by their name attribute**, and **allow you to define *placeholders* in your template that can be filled with any markup fragment** you want when the element is used in the markup.\n\nSo, if we want to add a slot into our trivial example, we could update our template's paragraph element like this:\n\n```\n<p><slot name=\"my-text\">My default text</slot></p>\n```\nIf the slot's content isn't defined when the element is included in the markup, or if the browser doesn't support slots, ```<my-paragraph>```  just contains the **fallback content** ```\"My default text\"```.\n\nTo define the slot's content, we include an HTML structure inside the ```<my-paragraph>``` element with a **slot attribute** whose *value* is equal to the name of the slot we want it to fill. As before, this can be anything you like, for example:\n\n```<my-paragraph>\n  <span slot=\"my-text\">Let's have some different text!</span>\n</my-paragraph>\n```\nor\n\n```\n<my-paragraph>\n  <ul slot=\"my-text\">\n    <li>Let's have some different text!</li>\n    <li>In a list!</li>\n  </ul>\n</my-paragraph>\n```\n> Note: Elements that can be inserted into slots are known as **Slotable**; when an element has been inserted in a slot, it is said to be slotted.\n\n> Note: An **unnamed** ```<slot>``` will be **filled with all of the custom element's top-level child nodes** that do not have the slot attribute. This includes text nodes.\n\nAnd that's it for our trivial example. If you want to play with it some more, you can find it on GitHub (see it running live also).\n\n## A more involved example\n\nTo finish off the article, let's look at something a little less trivial.\n\nThe following set of code snippets show how to use ```<slot>``` together with ```<template>``` and some JavaScript to:\n\n- create a ```<element-details>``` element with named slots in its shadow root\n- design the ```<element-details>``` element in such a way that, when used in documents, it is rendered from composing the element’s content together with content from its shadow root; that is, pieces of the element’s content are used to fill in named slots in its shadow root\n\nNote that it is technically possible to use ```<slot>``` element without a ```<template>``` element, e.g., within say a regular ```<div>``` element, and still take advantage of the place-holder features of  ```<slot>``` for Shadow DOM content, and doing so may indeed avoid the small trouble of needing to first access the template element's content property (and clone it). However, it is generally more practical to add slots within a ```<template>``` element, since you are unlikely to need to define a pattern based on an already-rendered element.\n\nIn addition, even if it is not already rendered, the purpose of the container as a template should be more semantically clear when using the ```<template>```. In addition, ```<template>``` can have items directly added to it, like ```<td>```, which would disappear when added to a ```<div>```.\n\n### Creating a template with some slots\n\nFirst of all, we use the ```<slot>``` element within a ```<template>``` element to create a new \"element-details-template\" document fragment containing some named slots:\n\n```\n<template id=\"element-details-template\">\n  <style>\n  details {font-family: \"Open Sans Light\",Helvetica,Arial}\n  .name {font-weight: bold; color: #217ac0; font-size: 120%}\n  h4 { margin: 10px 0 -8px 0; }\n  h4 span { background: #217ac0; padding: 2px 6px 2px 6px }\n  h4 span { border: 1px solid #cee9f9; border-radius: 4px }\n  h4 span { color: white }\n  .attributes { margin-left: 22px; font-size: 90% }\n  .attributes p { margin-left: 16px; font-style: italic }\n  </style>\n  <details>\n    <summary>\n      <span>\n        <code class=\"name\">&lt;<slot name=\"element-name\">NEED NAME</slot>&gt;</code>\n        <i class=\"desc\"><slot name=\"description\">NEED DESCRIPTION</slot></i>\n      </span>\n    </summary>\n    <div class=\"attributes\">\n      <h4><span>Attributes</span></h4>\n      <slot name=\"attributes\"><p>None</p></slot>\n    </div>\n  </details>\n  <hr>\n</template>\n```\nThat ```<template>``` element has several features:\n\nThe ```<template>``` has a ```<style>``` element with a **set of CSS styles that are scoped just to the document fragment** the  ```<template>``` creates.\nThe ```<template>``` uses ```<slot>``` and its *name* attribute to make three *named slots*:\n- ```<slot name=\"element-name\">```\n- ```<slot name=\"description\">```\n- ```<slot name=\"attributes\">```\n\nThe ```<template>``` wraps the named slots in a ```<details>``` element.\n\n### Creating a new ```<element-details>``` element from the ```<template>```\n\nNext, let’s create a new custom element named ```<element-details>``` and use **Element.attachShadow** to attach to it, as its shadow root, that document fragment we created with our ```<template>``` element above. This uses exactly the same pattern as we saw in our earlier trivial example.\n\n```\ncustomElements.define('element-details',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      var template = document\n        .getElementById('element-details-template')\n        .content;\n      const shadowRoot = this.attachShadow({mode: 'open'})\n        .appendChild(template.cloneNode(true));\n    }\n  }\n);\n```\n\n### Using the ```<element-details>``` custom element with named slots\n\nNow let’s take that ```<element-details>``` element and actually use it in our document:\n\n```\n<element-details>\n  <span slot=\"element-name\">slot</span>\n  <span slot=\"description\">A placeholder inside a web\n    component that users can fill with their own markup,\n    with the effect of composing different DOM trees\n    together.</span>\n  <dl slot=\"attributes\">\n    <dt>name</dt>\n    <dd>The name of the slot.</dd>\n  </dl>\n</element-details>\n```\n\n```\n<element-details>\n  <span slot=\"element-name\">template</span>\n  <span slot=\"description\">A mechanism for holding client-\n    side content that is not to be rendered when a page is\n    loaded but may subsequently be instantiated during\n    runtime using JavaScript.</span>\n</element-details> \n```\n\nAbout that snippet, notice these points:\n\n- The snippet has two instances of ```<element-details>``` elements which both use the *slot* attribute to reference the named slots \"element-name\" and \"description\" we put in the ```<element-details>``` shadow root .\n\n- Only the first of those two ```<element-details>``` elements references the \"attributes\" named slot. The second ```<element-details>``` element lacks any reference to the \"attributes\" named slot.\n\n- The first ```<element-details>``` element references the \"attributes\" named slot using a ```<dl>``` element with ```<dt>``` and ```<dd>``` children.\n\n### Adding a final bit of style\n\nAs a finishing touch, we'll add a tiny bit more CSS for the ```<dl>```, ```<dt>```, and ```<dd>``` elements in our doc:\n\n ```\n dl { margin-left: 6px; }\n  dt { font-weight: bold; color: #217ac0; font-size: 110% }\n  dt { font-family: Consolas, \"Liberation Mono\", Courier }\n  dd { margin-left: 16px }\n```\nResult\nFinally let’s put all the snippets together and see what the rendered result looks like.\n\t\nNotice the following points about this rendered result:\n\n- Even though the instances of the ```<element-details>``` element in the document do not directly use the ```<details>``` element, they get rendered using ```<details>``` because the shadow root causes them to get populated with that.\n- Within the rendered ```<details>``` output, the content in the ```<element-details>``` elements fills the named slots from the shadow root. In other words, the DOM tree from the ```<element-details>``` elements get composed together with the content of the shadow root.\n- For both ```<element-details>``` elements, an *Attributes* heading gets automatically added from the shadow root before the position of the \"attributes\" named slot.\n- Because the first ```<element-details>``` has a ```<dl>``` element which explicitly references the \"attributes\" named slot from its shadow root, the contents of that ```<dl>``` replace the \"attributes\" named slot from the shadow root.\n- Because the second ```<element-details>``` doesn’t explicitly reference the \"attributes\" named slot from its shadow root, its content for that named slot gets filled with the default content for it from the shadow root.","references":"- [MDN - Using Templates and Slots](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-templates-slots","weblink":"https://codersnack.com/web-components-templates-slots/","featured_image_preview":{"id":116,"name":"web-components.png","hash":"3b6d136b6dbf483185b25055e533b752","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/3b6d136b6dbf483185b25055e533b752.png","provider":"local","provider_metadata":null,"created_at":"2020-06-23T14:13:26.868Z","updated_at":"2020-06-23T14:13:26.868Z"}},"codersnacks_category":{"id":25,"header":"Web Standards","description":"All about web standards","snacks_by_cat_json_filename":"web-standards.snacks.json","key":"web-standards","image_url":"https://codersnack.com/assets/images/web-standards-logo.png","created_at":"2022-04-06T11:46:29.528Z","updated_at":"2022-04-06T12:28:37.991Z","image_preview":{"id":205,"name":"web-standards-logo.png","hash":"49a914d205d24f1487f0cf52c3b703b0","sha256":"h6yD0wBq4kdFylxQGYdTnkT9jouDkB8jx23AYEhxW30","ext":".png","mime":"image/png","size":7.04,"url":"/uploads/49a914d205d24f1487f0cf52c3b703b0.png","provider":"local","provider_metadata":null,"created_at":"2022-04-06T11:46:29.544Z","updated_at":"2022-04-06T11:46:29.544Z"}},"title":"Web components - using templates and slots (web standards label)","created_at":"2022-04-26T08:12:10.903Z","updated_at":"2022-04-26T08:12:10.908Z"}]