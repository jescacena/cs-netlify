[{"id":46,"codersnack":{"id":47,"header":"Typescript introduction","created_at":"2020-02-11T21:45:15.749Z","updated_at":"2020-02-11T21:55:42.521Z","explanation":"TypeScript is an open-source programming language developed and maintained by **Microsoft**. It is **a strict syntactical superset of JavaScript, and adds optional static typing to the language**.\n\nTypeScript is a strict superset of ECMAScript 2015, which is itself a superset of ECMAScript 5, commonly referred to as JavaScript. As such, **a JavaScript program is also a valid TypeScript program**, and a TypeScript program can seamlessly consume JavaScript. By default the compiler targets ECMAScript 5, the current prevailing standard, but is also able to generate constructs used in ECMAScript 3 or 2015.\n\nWith TypeScript, it is possible to use existing JavaScript code, incorporate popular JavaScript libraries, and call TypeScript-generated code from other JavaScript. Type declarations for these libraries are provided with the source code.\n\n#### Type annotations\n**TypeScript provides static typing through type annotations to enable type checking at compile time**. This is optional and **can be ignored** to use the regular dynamic typing of JavaScript.\n```\nfunction add(left: number, right: number): number {\n\treturn left + right;\n}\n```\nThe annotations for the primitive types are *number*, *boolean* and *string*. Weakly or dynamically-typed structures are of type *any*.\n\n**Type annotations can be exported to a separate declarations file** to make type information available for TypeScript scripts using types already compiled into JavaScript. Annotations can be declared for an existing JavaScript library, as has been done for Node.js and jQuery.\n\n**The TypeScript compiler makes use of type inference** to infer types when types are not given. For example, the add method in the code above would be inferred as returning a number even if no return type annotation had been provided. This is based on the static types of left and right being numbers, and the compiler's knowledge that the result of adding two numbers is always a number. However, explicitly declaring the return type allows the compiler to verify correctness.\n\nIf no type can be inferred because of lack of declarations, then it defaults to the dynamic any type. **A value of the *any* type supports the same operations as a value in JavaScript** and minimal static type checking is performed for operations on any values.\n\n#### Declaration files\nWhen a TypeScript script gets compiled there is an option to generate a declaration file (with the **extension .d.ts**) that functions as **an interface to the components in the compiled JavaScrip**t. In the process the compiler strips away all function and method bodies and preserves only the signatures of the types that are exported. The resulting declaration file **can then be used to describe the exported virtual TypeScript types of a JavaScript library or module when a third-party developer consumes it from TypeScript.**\n\nThe concept of declaration files is analogous to the concept of header file found in C/C++.\n\n```\ndeclare namespace arithmetics {\n    add(left: number, right: number): number;\n    subtract(left: number, right: number): number;\n    multiply(left: number, right: number): number;\n    divide(left: number, right: number): number;\n}\n```\nType declaration files can be written by hand for existing JavaScript libraries, as has been done for jQuery and Node.js.\n\nLarge collections of declaration files for popular JavaScript libraries are hosted on GitHub in DefinitelyTyped","references":"- [Wikipedia -Typescript](https://en.wikipedia.org/wiki/TypeScript)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-introduction","weblink":"https://codersnack.com/typescript-introduction/","featured_image_preview":{"id":59,"name":"typescript-icon.png","hash":"51965127b8234ae0805f416599e2fa28","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/51965127b8234ae0805f416599e2fa28.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:45:15.758Z","updated_at":"2020-02-11T21:45:15.758Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript introduction","created_at":"2020-02-11T21:45:44.933Z","updated_at":"2020-02-11T21:45:44.936Z"},{"id":47,"codersnack":{"id":48,"header":"Typescript Basic Types","created_at":"2020-02-12T17:35:24.449Z","updated_at":"2020-02-24T09:05:43.745Z","explanation":"For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we **support much the same types as you would expect in JavaScript,** with a convenient enumeration type thrown in to help things along.\n\n#### Boolean\nThe most basic datatype is the simple true/false value, which JavaScript and TypeScript call a *boolean* value.\n```\nlet isDone: boolean = false;\n```\n#### Number\n**As in JavaScript, all numbers in TypeScript are floating point values**. These floating point numbers get the type *number*. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.\n\n```\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n```\n#### String\n**Just like JavaScript, TypeScript also uses double quotes (\") or single quotes (') to surround string data**.\n```\nlet color: string = \"blue\";\ncolor = 'red';\n```\n\nYou can also use **template strings**, which can span multiple lines and have embedded expressions. These strings are **surrounded by the backtick/backquote character**, and **embedded expressions are of the form *${ expr }***.\n\n```\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ fullName }.\nI'll be ${ age + 1 } years old next month.`;\n```\nThis is equivalent to declaring sentence like so:\n```\nlet sentence: string = \"Hello, my name is \" + fullName + \".\\n\\n\" +\n    \"I'll be \" + (age + 1) + \" years old next month.\";\n```\n#### Array\nArray types can be written in one of two ways. In the first, you use the type of the elements followed by [] to denote an array of that element type:\n\n```\nlet list: number[] = [1, 2, 3];\n```\nThe second way uses a generic array type, *Array<elemType>*:\n\n```\nlet list: Array<number> = [1, 2, 3];\n```\n#### Tuple\nTuple types allow you to **express an array with a fixed number of elements whose types are known**, but need not be the same. For example, you may want to represent a value as a pair of a string and a number:\n\n```\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\"hello\", 10]; // OK\n// Initialize it incorrectly\nx = [10, \"hello\"]; // Error\n```\nWhen accessing an element with a known index, the correct type is retrieved:\n\n```\nconsole.log(x[0].substring(1)); // OK\nconsole.log(x[1].substring(1)); // Error, 'number' does not have 'substring'\n```\nAccessing an element outside the set of known indices fails with an error:\n\n```\nx[3] = \"world\"; // Error, Property '3' does not exist on type '[string, number]'.\nconsole.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'.\n```\n\n#### Enum\n**A helpful addition to the standard set of datatypes from JavaScript is the enum**. As in languages like C#, an **enum is a way of giving more friendly names to sets of numeric values**.\n\n```\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```\n**By default, enums begin numbering their members starting at 0**. You can change this by manually setting the value of one of its members. For example, we can start the previous example at 1 instead of 0:\n\n```\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\nOr, even manually set all the values in the enum:\n\n```\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n```\nA handy feature of enums is that **you can also go from a numeric value to the name of that value in the enum**. For example, if we had the value 2 but weren’t sure what that mapped to in the Color enum above, we could look up the corresponding name:\n\n```\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName); // Displays 'Green' as its value is 2 above\n```\n\n#### Any\nWe may **need to describe the type of variables that we do not know when we are writing an application**. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, **we want to opt-out of type checking and let the values pass through compile-time checks**. To do so, we label these with the any type:\n\n```\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n```\nThe any type is a **powerful way to work with existing JavaScript**, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect *Object* to play a similar role, as it does in other languages. However, variables of type **Object only allow you to assign any value to them. You can’t call arbitrary methods on them, even ones that actually exist**:\n\n```\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\n```\n\n> Note: Avoid using Object in favor of the non-primitive object type as described in our Do’s and Don’ts section.\n\nThe any type is **also handy if you know some part of the type, but perhaps not all of it**. For example, you may have an array but the array has a mix of different types:\n\n```\nlet list: any[] = [1, true, \"free\"];\n\nlist[1] = 100;\n```\n\n#### Void\n**void is a little like the opposite of any: the absence of having any type at all**. You may commonly see this as the return type of functions that do not return a value:\n\n```\nfunction warnUser(): void {\n    console.log(\"This is my warning message\");\n}\n```\n**Declaring variables of type void is not useful because you can only assign null** (only *if --strictNullChecks* is not specified, see next section) or undefined to them:\n\n```\nlet unusable: void = undefined;\nunusable = null; // OK if `--strictNullChecks` is not given\n```\n\n#### Null and Undefined\nIn TypeScript, **both *undefined* and *null* actually have their own types named undefined and null respectively**. Much like *void*, they’re not extremely useful on their own:\n\n```\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n**By default *null* and *undefined* are subtypes of all other types**. That means you can assign null and undefined to something like number.\n\nHowever, when using the **--strictNullChecks flag**, *null* and *undefined* are **only assignable to any and their respective types** (the one exception being that *undefined* is also assignable to *void*). This helps avoid many common errors. In cases where you want to pass in either a string or null or undefined, **you can use the union type string | null | undefined.**\n\n*Union types* are an advanced topic that we’ll cover in a later chapter.\n\n> As a note: we encourage the use of *--strictNullChecks* when possible, but for the purposes of this handbook, we will assume it is turned off.\n\n#### Never\n**The never type represents the type of values that never occur**. For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type never when narrowed by any type guards that can never be true.\n\n**The never type is a subtype of, and assignable to, every type**; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never.\n\nSome examples of functions returning never:\n\n```\n// Function returning never must have unreachable end point\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// Inferred return type is never\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// Function returning never must have unreachable end point\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```\n#### Object\n***object* is a type that represents the non-primitive type**, i.e. anything that is not *number*, *string*, *boolean*, *bigint*, *symbol*, *null*, or *undefined*.\n\nWith object type, APIs like *Object.create* can be better represented. For example:\n\n```\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n\n#### Type assertions\nSometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does. Usually this will happen when **you know the type of some entity could be more specific than its current type**.\n\n**Type assertions are a way to tell the compiler \"trust me, I know what I’m doing.\"** A type assertion is like a *type cast* in other languages, but **performs no special checking or restructuring of data.** It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.\n\nType assertions have two forms. One is the **\"angle-bracket\" syntax**:\n\n```\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (<string>someValue).length;\n```\nAnd the other is the **as-syntax**:\n\n```\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (someValue as string).length;\n```\n> The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only as-style assertions are allowed.\n","references":"- [Typescriptlang Handbook - Basic Types](https://www.typescriptlang.org/docs/handbook/basic-types.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-basic-types","weblink":"https://codersnack.com/typescript-basic-types/","featured_image_preview":{"id":60,"name":"typescript-icon.png","hash":"acf312cf71ff46218adcce6e2e1d7664","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/acf312cf71ff46218adcce6e2e1d7664.png","provider":"local","provider_metadata":null,"created_at":"2020-02-12T17:35:24.468Z","updated_at":"2020-02-12T17:35:24.468Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript basic types","created_at":"2020-02-12T17:35:47.654Z","updated_at":"2020-02-12T17:35:47.658Z"},{"id":48,"codersnack":{"id":49,"header":"Typescript Interfaces","created_at":"2020-02-12T20:47:11.498Z","updated_at":"2020-02-12T20:47:11.498Z","explanation":"\nOne of TypeScript's core principles is that type checking focuses on the shape that values have. This is sometimes called \"duck typing\" or \"structural subtyping\". In TypeScript, *interfaces* fill the role of naming these types, and are **a powerful way of defining contracts within your code as well as contracts with code outside of your project**.\n\n#### Our First Interface\nThe easiest way to see how interfaces work is to start with a simple example:\n\n```\nfunction printLabel(labeledObj: { label: string }) {\n    console.log(labeledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n\nThe type checker checks the call to *printLabel*. The *printLabel* function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that at least the ones required are present and match the types required. There are some cases where TypeScript isn't as lenient, which we'll cover in a bit.\n\nWe can write the same example again, this time **using an interface to describe the requirement** of having the label property that is a string:\n\n```\ninterface LabeledValue {\n    label: string;\n}\n\nfunction printLabel(labeledObj: LabeledValue) {\n    console.log(labeledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n\nThe interface *LabeledValue* is a name we can now use to describe the requirement in the previous example. It still represents having a single property called label that is of type string. Notice we didn't have to explicitly say that the object we pass to printLabel implements this interface like we might have to in other languages. Here, it's only the shape that matters. If the object we pass to the function meets the requirements listed, then it's allowed.\n\n> It’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.\n\n#### Optional Properties\n**Not all properties of an interface may be required**. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like \"option bags\" where you pass an object to a function that only has a couple of properties filled in.\n\nHere’s an example of this pattern:\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\n    let newSquare = {color: \"white\", area: 100};\n    if (config.color) {\n        newSquare.color = config.color;\n    }\n    if (config.width) {\n        newSquare.area = config.width * config.width;\n    }\n    return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n\nInterfaces with **optional properties** are written similar to other interfaces, with **each optional property denoted by a ? at the end** of the property name in the declaration.\n\nThe advantage of optional properties is that you can describe these possibly available properties while still also **preventing use of properties that are not part of the interface**. For example, had we mistyped the name of the color property in createSquare, we would get an error message letting us know:\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    let newSquare = {color: \"white\", area: 100};\n    if (config.clor) {\n        // Error: Property 'clor' does not exist on type 'SquareConfig'\n        newSquare.color = config.clor;\n    }\n    if (config.width) {\n        newSquare.area = config.width * config.width;\n    }\n    return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n\n#### Readonly properties\nSome properties should only be modifiable when an object is first created. You can specify this by **putting readonly before the name of the property:**\n\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\nYou can construct a *Point* by assigning an object literal. After the assignment, *x* and *y* can't be changed.\n\n```\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\n\nTypeScript comes with a *ReadonlyArray<T>* type that is the same as *Array<T>* with all mutating methods removed, so you can **make sure you don’t change your arrays after creation**:\n\n```\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n\nOn the last line of the snippet you can see that even assigning the entire *ReadonlyArray* back to a normal array is illegal. You can still override it with a type assertion, though:\n\n```\na = ro as number[];\n```\n\n#### readonly vs const\nThe easiest way to remember whether to use *readonly* or *const* is to ask whether you're using it on a variable or a property. **Variables use *const* whereas properties use *readonly***.\n","references":"- [Typescriptlang interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-interfaces","weblink":"https://codersnack.com/typescript-interfaces/","featured_image_preview":{"id":61,"name":"typescript-icon.png","hash":"288b73fd91a14c4fb1ce9deb2d8efc73","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/288b73fd91a14c4fb1ce9deb2d8efc73.png","provider":"local","provider_metadata":null,"created_at":"2020-02-12T20:47:11.505Z","updated_at":"2020-02-12T20:47:11.505Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript interfaces","created_at":"2020-02-12T20:47:37.776Z","updated_at":"2020-02-12T20:47:37.779Z"},{"id":49,"codersnack":{"id":50,"header":"Typescript Generics","created_at":"2020-02-12T22:00:24.934Z","updated_at":"2020-02-24T09:06:31.653Z","explanation":"A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. **Components that are capable of working on the data of today as well as the data of tomorrow** will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is **generics**, that is, being **able to create a component that can work over a variety of types rather than a single one**. This allows users to consume these components and use their own types.\n\n#### Hello World of Generics\nTo start off, let’s do the \"hello world\" of *generics*: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command.\n\n**Without generics**, we would either have to give the identity function a specific type:\n```\nfunction identity(arg: number): number {\n    return arg;\n}\n```\nOr, we could describe the identity function **using the any type**:\n\n```\nfunction identity(arg: any): any {\n    return arg;\n}\n```\nWhile using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, **we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.**\n\nInstead, we need **a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned**. Here, we will use a *type* variable, a special kind of variable that works on types rather than values.\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\nWe’ve now added a **type variable T** to the identity function. **This T allows us to capture the type the user provides** (e.g. number), **so that we can use that information later**. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the *identity* function is generic, as it works over a range of types. Unlike using *any*, it's also just as precise (ie, it doesn't lose any information) as the first *identity* function that used numbers for the argument and return type.\n\nOnce we’ve written the generic *identity* function, **we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:**\n\n```\nlet output = identity<string>(\"myString\");  // type of output will be 'string'\n```\n\nHere we explicitly set T to be string as one of the arguments to the function call, denoted using the <> around the arguments rather than ().\n\nThe second way is also perhaps the most common. Here **we use type argument inference** , that is, we want the compiler to set the value of T for us automatically based on the type of the argument we pass in:\n\n```\nlet output = identity(\"myString\");  // type of output will be 'string'\n```\nNotice that we didn't have to explicitly pass the type in the angle brackets (<>); the compiler just looked at the value \"myString\", and set T to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\n#### Working with Generic Type Variables\nWhen you begin to use generics, you’ll notice that when you create generic functions like identity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our identity function from earlier:\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\nWhat if we want to also log the length of the argument arg to the console with each call? We might be tempted to write this:\n\n```\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n```\nWhen we do, the compiler will give us an error that we're using the .length member of arg, but nowhere have we said that arg has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a number instead, which does not have a .length member.\n\nLet's say that we’ve actually intended this function to work on arrays of T rather than T directly. Since we're working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types:\n\n```\nfunction loggingIdentity<T>(arg: T[]): T[] {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\nYou can read the type of *loggingIdentity* as \"the generic function loggingIdentity takes a type parameter T, and an argument arg which is an array of Ts, and returns an array of Ts.\" If we passed in an array of numbers, we'd get an array of numbers back out, as T would bind to number. This allows us to use our generic type variable T as part of the types we're working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\n```\nfunction loggingIdentity<T>(arg: Array<T>): Array<T> {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like Array<T>","references":"- [Typescriptlang generics](https://www.typescriptlang.org/docs/handbook/generics.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-generics","weblink":"https://codersnack.com/typescript-generics/","featured_image_preview":{"id":62,"name":"typescript-icon.png","hash":"e8fb797f12614842b93ce830ba4463d7","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/e8fb797f12614842b93ce830ba4463d7.png","provider":"local","provider_metadata":null,"created_at":"2020-02-12T22:00:24.949Z","updated_at":"2020-02-12T22:00:24.949Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript generics","created_at":"2020-02-12T22:00:42.768Z","updated_at":"2020-02-12T22:00:42.771Z"},{"id":75,"codersnack":{"id":76,"header":"Typescript Declaration Modules: Library Structure","created_at":"2020-05-21T16:41:56.394Z","updated_at":"2020-05-21T16:41:56.394Z","explanation":"### Library Structures\n\nBroadly speaking, **the way you structure your declaration file depends on how the library is consumed**. There are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.\n\nEach type of major library structuring pattern has a corresponding file in the [Templates](https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html) section. You can start with these templates to help you get going faster.\n\n#### Identifying Kinds of Libraries\nFirst, we’ll review the **kinds of libraries TypeScript declaration files can represent**. We’ll briefly show how each kind of library is used, how it is written, and list some example libraries from the real world.\n\n**Identifying the structure of a library is the first step in writing its declaration file**. We’ll give hints on how to identify structure both based on its usage and its code. Depending on the library’s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.\n\n#### Global Libraries\nA global library is **one that can be accessed from the global scope** (i.e. without using any form of import). Many libraries simply expose one or more global variables for use. For example, if you were **using jQuery, the $ variable can be used by simply referring to it:**\n\n``` \n$(() => { console.log('hello!'); } );\n``` \n\nYou’ll usually see guidance in the **documentation of a global library of how to use the library in an HTML script tag:**\n\n``` \n<script src=\"http://a.great.cdn.for/someLib.js\"></script>\n``` \n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). **UMD library documentation is hard to distinguish from global library documentation**. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n**Identifying a Global Library from Code**\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\n``` \nfunction createGreeting(s) {\n    return \"Hello, \" + s;\n}\n``` \nor like this:\n\n``` \nwindow.createGreeting = function(s) {\n    return \"Hello, \" + s;\n}\n``` \nWhen looking at the code of a global library, you’ll usually see:\n\n- Top-level var statements or function declarations\n- One or more assignments to window.someName\n- Assumptions that DOM primitives like document or window exist\n\nYou won’t see:\n\n- Checks for, or usage of, module loaders like require or define\n- CommonJS/Node.js-style imports of the form var fs = require(\"fs\");\n- Calls to define(...)\n- Documentation describing how to require or import the library\n\n**Examples of Global Libraries**\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have no dependencies) may still be global.\n\n**Global Library Template**\nThe template file **global.d.ts** defines an example library *myLib*. Be sure to read the “Preventing Name Conflicts” footnote.\n\n#### Modular Libraries\n**Some libraries only work in a module loader environment**. For example, express only works in Node.js and must be loaded using the CommonJS require function.\n\nECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of importing a module. In JavaScript CommonJS (Node.js), for example, you would write\n\n``` \nvar fs = require(\"fs\");\n``` \nIn TypeScript or ES6, the *import* keyword serves the same purpose:\n\n``` \nimport fs = require(\"fs\");\n``` \nYou’ll typically see **modular libraries include one of these lines in their documentation**:\n\n``` \nvar someLib = require('someLib');\n``` \nor\n\n``` \ndefine(..., ['someLib'], function(someLib) {\n\n});\n``` \nAs with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.\n\n**Identifying a Module Library from Code**\nModular libraries will typically have at least some of the following:\n\n- Unconditional calls to require or define\n- Declarations like import * as a from 'b'; or export c;\n- Assignments to exports or module.exports\n\nThey will rarely have:\n\n- Assignments to properties of window or global\n\n**Examples of Modular Libraries**\nMany popular Node.js libraries are in the module family, such as express, gulp, and request.\n\n#### UMD\n**A UMD module is one that can either be used as module (through an import), or as a global (when run in an environment without a module loader)**. Many popular libraries, such as Moment.js, are written this way. For example, in Node.js or using RequireJS, you would write:\n\n``` \nimport moment = require(\"moment\");\nconsole.log(moment.format());\n``` \nwhereas in a vanilla browser environment you would write:\n\n``` \nconsole.log(moment.format());\n``` \n\n**Identifying a UMD library**\nUMD modules check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\n``` \n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n``` \n\nIf you see tests for typeof define, typeof window, or typeof module in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing require, and a “Using in the browser” example showing using a ```<script>``` tag to load the script.\n\n**Examples of UMD libraries**\nMost popular libraries are now available as UMD packages. Examples include jQuery, Moment.js, lodash, and many more.\n\n**Template**\nThere are three templates available for modules, module.d.ts, module-class.d.ts and module-function.d.ts.\n\nUse **module-function.d.ts** if your module **can be called like a function**:\n\n``` \nvar x = require(\"foo\");\n// Note: calling 'x' as a function\nvar y = x(42);\n``` \nBe sure to read the footnote “The Impact of ES6 on Module Call Signatures”\n\nUse **module-class.d.ts** if your module **can be constructed using new**:\n\n``` \nvar x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nvar y = new x(\"hello\");\n``` \nThe same footnote applies to these modules.\n\nIf your module is **not callable or constructable**, use the **module.d.ts** file.\n\n#### Module Plugin or UMD Plugin\nA module plugin changes the shape of another module (either UMD or module). For example, in Moment.js, moment-range adds a new range method to the moment object.\n\nFor the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module.\n\n**Template**\nUse the module-plugin.d.ts template.\n\n**Global Plugin**\nA global plugin is global code that changes the shape of some global. As with global-modifying modules, these raise the possibility of runtime conflict.\n\nFor example, some libraries add new functions to Array.prototype or String.prototype.\n\n**Identifying global plugins**\nGlobal plugins are generally easy to identify from their documentation.\n\nYou’ll see examples that look like this:\n\n``` \nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n``` \n\n**Template**\nUse the **global-plugin.d.ts** template.\n\n#### Consuming Dependencies\nThere are several kinds of dependencies your library might have. This section shows **how to import them into the declaration file.**\n\n**Dependencies on Global Libraries**\nIf your library depends on a global library, use a ```/// <reference types=\"...\" />``` directive:\n\n```\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n**Dependencies on Modules**\nIf your library depends on a module, use an import statement:\n```\nimport * as moment from \"moment\";\n\nfunction getThing(): moment;\n```\n**Dependencies on UMD libraries**\nFrom a Global Library\nIf your global library depends on a UMD module, use a ```/// <reference types``` directive:\n\n```\n/// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n**From a Module or UMD Library**\nIf your module or UMD library depends on a UMD library, use an import statement:\n\n```\nimport * as someLib from 'someLib';\n```\nDo not use a ```/// <reference directive``` to declare a dependency to a UMD library!\n\n#### Footnotes\n**Preventing Name Conflicts**\nNote that it’s possible to define **many types in the global scope when writing a global declaration file**. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to **only declare types namespaced by whatever global variable the library defines**. For example, if the library defines the global value ‘cats’, you should write\n\n```\ndeclare namespace cats {\n    interface KittySettings { }\n}\n```\nBut not\n\n```\n// at top-level\ninterface CatsKittySettings { }\n```\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n**The Impact of ES6 on Module Plugins**\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\n**The Impact of ES6 on Module Call Signatures**\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\n```\nimport exp = require(\"express\");\nvar app = exp();\n```\nIn ES6 module loaders, the top-level object (here imported as exp) can only have properties; the top-level module object is never callable. The most common solution here is to define a default export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the default export.\n\n**Library file layout**\n**The layout of your declaration files should mirror the layout of the library**.\n\nA library can consist of multiple modules, such as\n\n```\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\nThese could be imported as\n\n```\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n```\nYour declaration files should thus be\n\n```\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```","references":"- [Typescriptlang Declaration Files: Library structure](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-declaration-files-library-structure","weblink":"https://codersnack.com/typescript-declaration-files-library-structure/","featured_image_preview":{"id":103,"name":"typescript-icon.png","hash":"db467756dfe748c2a60e460cac9cf90a","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/db467756dfe748c2a60e460cac9cf90a.png","provider":"local","provider_metadata":null,"created_at":"2020-05-21T16:41:56.413Z","updated_at":"2020-05-21T16:41:56.413Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript declaration file library structure","created_at":"2020-05-21T16:46:08.202Z","updated_at":"2020-05-21T16:46:08.206Z"},{"id":76,"codersnack":{"id":77,"header":"Typescript - What are declaration files in Typescript?","created_at":"2020-05-21T21:56:09.966Z","updated_at":"2020-05-21T21:56:09.966Z","explanation":"### What are Declaration Files in Typescript?\n\n**Declaration files** are an integral part of the Angular/Typescript ecosystem. However, **it is uncommon to work with declaration files**, because most major libraries have them bundled with respective npm library already (,or are written natively in Typescript). In addition, there are 5,000+ typings created by the open source library [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types). Nonetheless, granted this is the reality of present day Angular development, it is integral to understand how it works. Every application usually has a one-off use case that makes it special. When that time arrives, knowing how a declaration file works is going to come in handy. Most likely because you will need to create one yourself.\n\nDeclaration files, however, happen to be very involved. **They require understanding of numerous prior Typescript concepts**. Let’s go through that now, as efficiently we can.\n\n#### Type Annotation\n\nFirst, there is what we quite frequently see within a Typescript application called a type annotation. That looks something like this:\n```\nconst userName: string;\n```\nIn the above, we inform the Typescript compiler, that the type of this constant is a string. This is for a **single value**. Let’s move onto the next step in the ladder, type annotating an object.\n\n#### Typescript Interface\n\nA Typescript interface can be used to describe an entire object, such as the following *User* interface:\n```\nexport interface User { \n  password: string; \n  userName: string; \n  email: string;\n}\n```\nNow, in our application, if we plan on having user data, we can (type) annotate that object with our interface. A common enterprise example of this:\n```\nimport { User } from '@razroo/data-models/user';\n\nexport interface UserState {\n  list: User; // list of Users; analogous to a sql normalized table\n  selectedId?: string | number; // which User record has been\n  selected loaded: boolean; // has the User list been loaded\n  error?: any; // last none error (if any)\n}\n```\n\nIn the above *UserState* interface, our list, which is where our reducer is going to place user data, has the type annotation for the *User* interface.\n\n#### The Multiple Interface Dilemma\n\nOk, great, so now we know that we can create an interface, and use that to type annotate our object. However, what if wanted to use 10, or so interfaces from the **user.models.ts** file (the file where our user interfaces are located), **is there are a more efficient way to import them all at once, instead of doing something like this:?**\n\n```\nimport { User , UserTable , UserSettings , UserForm , UserProject , UserCorporate, UserConsumer } from '@razroo/data-models/user';\n\n// let's pretend that all imports are being used in this file, for the sake of\n// brevity ..\nexport interface UserState {\n  list: User; // list of Users; analogous to a sql normalized table\n  // ..\n}\n// ..\n```\n\nTypescript’s answer to this came in form of the next two core concepts we shall discuss:\n- Modules\n- Namespaces\n\n#### Modules in Typescript\n\n**A module in Typescript is any file containing**:\n\n1. **Values**\n```\n// e.g.\nexport const person: Person;\n```\n\n2. **Functions**\n```\n// i.e.\nexport function square(n: number) {\n  return n * n; \n}\n```\n\n3. **Classes** \n```\n// i.e.\n@Component({\n  selector: 'razroo-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  constructor() {}\n}\n```\n\n**Example of Module in Typescript**\n\nA great example of using a module in Typescript is **the classic import**. It’s so commonplace that you’ve undoubtedly come across it, and when you read this code example (probably) will say, ”Ooooh, that’s a module, I know what that is!”.\n```\nimport { add } from \"./math\";\n```\n^ the math file is a module in Typescript.\n\n#### Namespaces in Typescript\n\nYou most likely have come across a namespace in Typescript as well. A **local namespace** looks something like this:\n```\nimport * as math from \"./math\";\n```\nwherein **math is the namespace for the math module**. Now that we have our namespace, we can tap into any method within the namespace, using classic dot notation:\n```\nmath.add(2, 3);\n// 5 as 2 + 3 = 5\n```\n\n**A namespace put simply, is a way of grouping all Typescript interfaces, classes, functions, and variables under one single name**. Similar to what we did above ^ for the math namespace. The benefits of this are two-fold:\n\n1. Simplify process of import.\n2. Create a **respective Typescript interface overlay** → for a non-Typescript Javascript library (something we will get to momentarily).\n\n#### Global in Typescript — The Last Piece\n\nThere is just one last missing foundational piece in order to understand what a declaration file is.\n**In Typescript, there is the ability to create global variables, functions, and namespaces**. For instance, if we want to create a variable called car and have it be available across our entire app, we can use something really cool called declare:\n```\ndeclare let razrooAssetsBaseURL = 'assets/logo';\n```\nNow that we have this global variable within our app, we can use it anywhere we want.\n```\nconsole.log('razrooAssetsBaseURL'); \nconsole.log(razrooAssetsBaseURL);\n```\n**Creating a Global Namespace**\nWe can also create a **global namespace**, without the need of using an import/export. We would do this by coding:\n```\ndeclare namespace razrooLib {\n  let numberOfGreetings: number;\n}\n```\nNow we are all set to finally jump into what a declaration file is.\n\n#### What is a Declaration File?\n> Defined concisely:\n“A declaration file in Typescript is simply a way of transferring over a Javascript library to Typescript”\n\nThere is a bit to unpack in this definition, as it’s not immediately apparent why a Javascript library would need to be converted over to Typescript? In addition, how exactly would a declaration file covert a Javascript library to Typescript?\n\n**Fantastic Moment.js Example**\nThe **Moment.js library,** is an extremely popular library used for dates. (For me personally, in the past 10 years working on applications, it is the only library to consistently be used in every application.) **The actual library is written in Javascript**. **However, in order for the Typescript compiler to understand the Moment library, it is necessary to create a declaration file**.\nLucky for us, the Moment.js core contributors have created their own typescript definition files. These **definition files are bundled with the moment npm package.** Lets look at the moment definition file:\n\nmoment.d.ts file. \n```\ndeclare namespace moment {\n  //..\n  interface Moment extends Object {\n    format(format?: string): string;\n\n    startOf(unitOfTime: unitOfTime.StartOf): Moment;\n    endOf(unitOfTime: unitOfTime.StartOf): Moment;\n    //..\n  }\n  //..\n}\n```\n\nThere are three things that have been done here, in order for this declaration file to take hold:\n\n1. We created a **global namespace called *moment***. Whenever Typescript imports the Javascript moment library, it immediately taps into the types for *Moment*, contained within the global moment namespace.\n\n2. We create a **type annotation for all of our methods**. Here we are showing one of the more commonly used one’s, *format(along with startof and endOf)*. Wherein the library specifies that it can optionally take in string parameter, and returns a string.\n\n3. The actual file has the suffix .d.ts. When a file has a suffix of .d.ts, the Typescript compiler will not immediately know of it’s existence. Instead you will have to use a reference path similar to:\n```\n///<reference path=”path/to/file.d.ts” />\n```\n\n**The current practice is to place all reference paths in an index.d.ts file**, and then feed that one index.d.ts file into your application. This is fed into main application, by putting this type into the *typings/types* field in your *package.json*.\n\ntypings field as used by the moment.js library\n\nThis would sum up what a declaration file is.","references":"- [Medium - What are declaration files in typescript? - Charlie Greenman](https://medium.com/razroo/what-are-declaration-files-in-typescript-476c1c06f353)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-what-declaration-files","weblink":"https://codersnack.com/typescript-what-declaration-files/","featured_image_preview":{"id":104,"name":"typescript-icon.png","hash":"753f2608ed124a64994a7264f8edc810","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/753f2608ed124a64994a7264f8edc810.png","provider":"local","provider_metadata":null,"created_at":"2020-05-21T21:56:09.975Z","updated_at":"2020-05-21T21:56:09.975Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript what are declaration files","created_at":"2020-05-21T21:56:39.518Z","updated_at":"2020-05-21T21:56:39.520Z"},{"id":174,"codersnack":{"id":170,"header":"Typescript - decorators introduction","created_at":"2022-04-25T11:18:56.762Z","updated_at":"2022-04-25T11:18:56.762Z","explanation":"With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. **Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members**. Decorators are a stage 2 proposal for JavaScript and are available as an experimental feature of TypeScript.\n\n> **NOTE**  Decorators are an experimental feature that may change in future releases.\n\n**To enable experimental support for decorators, you must enable the *experimentalDecorators* compiler option** either on the command line or in your **tsconfig.json**:\n\n*Command Line:*\n\n```\ntsc --target ES5 --experimentalDecorators\n```\n\n*tsconfig.json:*\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n\n###   Decorators\n\n**A Decorator is a special kind of declaration that can be attached to a *class* declaration, *method*, *accessor*, *property*, or *parameter***. Decorators use the form **@expression**, where expression **must evaluate to a function that will be called at runtime** with information about the decorated declaration.\n\nFor example, given the decorator **@sealed** we might write the sealed function as follows:\n\n```\nfunction sealed(target) {\n  // do something with 'target' ...\n}\n```\n\n\n###  Decorator Factories\n\nIf we want to **customize how a decorator is applied to a declaration, we can write a decorator factory**. A Decorator Factory is simply **a function that returns the expression that will be called by the decorator at runtime**.\n\nWe can write a decorator factory in the following fashion:\n```\nfunction color(value: string) {\n  // this is the decorator factory, it sets up\n  // the returned decorator function\n  return function (target) {\n    // this is the decorator\n    // do something with 'target' and 'value'...\n  };\n}\n```\n\n\n###  Decorator Composition\n\n**Multiple decorators can be applied to a declaration**, for example on a single line:\n\n```\n@f @g x\n```\n\nOn multiple lines:\n\n```\n@f\n@g\nx\n```\n\n**When multiple decorators apply to a single declaration, their evaluation is similar to function composition in mathematics**. In this model, when composing functions f and g, the resulting composite (f ∘ g)(x) is equivalent to f(g(x)).\n\nAs such, the **following steps are performed when evaluating multiple decorators** on a single declaration in TypeScript:\n\n- The expressions for each decorator are evaluated top-to-bottom.\n- The results are then called as functions from bottom-to-top.\n\n**If we were to use decorator factories**, we can observe this evaluation order with the following example:\n\n```\nfunction first() {\n  console.log(\"first(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"first(): called\");\n  };\n}\n \nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"second(): called\");\n  };\n}\n \nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}\n``` \n\nWhich would **print this output** to the console:\n\n```\nfirst(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called\n```\n\n\n###  Decorator Evaluation\n\nThere is a well defined order to **how decorators applied to various declarations inside of a class are applied**:\n\n- **Parameter Decorators**, followed by **Method, Accessor, or Property Decorators** are applied for **each instance member**.\n- **Parameter Decorators**, followed by **Method, Accessor, or Property Decorators** are applied for each **static member**.\n- **Parameter Decorators** are applied for the **constructor**.\n- **Class Decorators** are applied for the class.","references":"- [Typescript decorators - Official doc](https://www.typescriptlang.org/docs/handbook/decorators.html)\n- [A complete guide of typescript decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-decorators-introduction","weblink":"https://codersnack.com/typescript-decorators-introduction","featured_image_preview":{"id":211,"name":"typescript-icon.png","hash":"19b164151f654822b29f66efabdce375","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/19b164151f654822b29f66efabdce375.png","provider":"local","provider_metadata":null,"created_at":"2022-04-25T11:18:56.778Z","updated_at":"2022-04-25T11:18:56.778Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript Decorators Introduction","created_at":"2022-04-25T11:19:26.267Z","updated_at":"2022-04-25T11:19:26.273Z"},{"id":189,"codersnack":{"id":171,"header":"A practical guide to TypeScript decorators","created_at":"2022-04-26T07:44:10.731Z","updated_at":"2022-04-26T09:23:21.705Z","explanation":"We can all agree that JavaScript is an amazing programming language that allows you to build apps on almost any platform. Although it comes with its own fair share of drawbacks, TypeScript has done a great job of covering up some gaps inherent in JavaScript. Not only does it add type safety to a dynamic language, but it also comes with **some cool features that don’t exist yet in JavaScript, such as decorators.**\n\n###  What are decorators?\n\nAlthough the definition might vary for different programming languages, the reason why decorators exist is pretty much the same across the board. In a nutshell, **a decorator is a pattern in programming in which you wrap something to change its behavior**.\n\n**In JavaScript, this feature is currently at stage two. It’s not yet available in browsers or Node.js, but you can test it out by using compilers like Babel**. Having said that, it’s not exactly a brand new thing; several programming languages, such as Python, Java, and C#, adopted this pattern before JavaScript.\n\n**Even though JavaScript already has this feature proposed, TypeScript’s decorator feature is different in a few significant ways**. Since TypeScript is a strongly typed language, you can access some additional information associated with your data types to do some cool stuff, such as runtime type-assertion and dependency injection.\n\n###  Getting started\nStart by **creating a blank Node.js project**.\n\n```\n$ mkdir typescript-decorators\n$ cd typescript decorators\n$ npm init -y\n```\nNext, **install TypeScript as a development dependency**.\n\n```\n$ npm install -D typescript @types/node\n```\nThe @types/node package contains the Node.js type definitions for TypeScript. We need this package to access some Node.js standard libraries.\n\nAdd an npm script in the package.json file to compile your TypeScript code.\n```\n{\n  // ...\n  \"scripts\": {\n    \"build\": \"tsc\"\n  }\n}\n```\n\n**TypeScript has labeled this feature as *experimental***. Nonetheless, it’s **stable enough to use in production**. In fact, the open source community has been using it for quite a while.\n\nTo activate the feature, you’ll need to make some adjustments to your **tsconfig.json file**.\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\nCreate a simple TypeScript **index.ts** file to test it out.\n\n```\nconsole.log(\"Hello, world!\");\n```\n```\n$ npm run build\n$ node index.js\nHello, world!\n``` \nInstead of repeating this command over and over, **you can simplify the compilation and execution process by using a package called *ts-node***. It’s a community package that enables you to run TypeScript code directly without first compiling it.\n\nLet’s install it as a development dependency.\n\n```\n$ npm install -D ts-node\n```\nNext, add a start script to the package.json file.\n\n```\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"ts-node index.ts\"\n  }\n}\n```\nSimply run npm start to run your code.\n\n```\n$ npm start\nHello, world!\n```\nFor reference, I have all the source code on this article published on my GitHub. You can clone it onto your computer using the command below.\n\n```\n$ git clone https://github.com/rahmanfadhil/typescript-decorators.git\n```\n\n\n###  Types of decorators\n\nIn TypeScript, **decorators are functions that can be attached to classes and their members, such as methods and properties**. Let’s look at some examples.\n\n\n####  Class decorator\n\nWhen you attach a function to a class as a decorator, you’ll receive the class constructor as the first parameter.\n\n```\nconst classDecorator = (target: Function) => {\n  // do something with your class\n}\n\n@classDecorator\nclass Rocket {}\n```\n\nIf you want to override the properties within the class, you can return a new class that extends its constructor and set the properties.\n\n```\nconst addFuelToRocket = (target: Function) => {\n  return class extends target {\n    fuel = 100\n  }\n}\n\n@addFuelToRocket\nclass Rocket {}\n```\n\nNow your Rocket class will have a fuel property with a default value of 100.\n\n```\nconst rocket = new Rocket()\nconsole.log((rocket).fuel) // 100\n```\n\n\n####  Method decorator\n\nAnother good place to attach a decorator is the class method. Here, **you’re getting three parameters in your function: *target*, *propertyKey*, and *descriptor***.\n\n```\nconst myDecorator = (target: Object, propertyKey: string, descriptor: PropertyDescriptor) =>  {\n  // do something with your method\n}\n\nclass Rocket {\n  @myDecorator\n  launch() {\n    console.log(\"Launching rocket in 3... 2... 1... 🚀\")\n  }\n}\n```\n\n**The first parameter contains the class where this method lives**, which, in this case, is the Rocket class. \n**The second parameter contains your method name** in string format, \nand the **last parameter is the property descriptor, a set of information that defines a property behavior**. This can be used to **observe, modify, or replace a method definition**.\n\nThe method decorator can be very useful if you want to extend the functionality of your method, which we’ll cover later.\n\n\n####   Property decorator\n\nJust like the method decorator, **you’ll get the *target* and *propertyKey* parameter.** The only difference is that **you don’t get the property descriptor.**\n\n```\nconst propertyDecorator = (target: Object, propertyKey: string) => {\n  // do something with your property\n}\n```\nThere are several other places to attach your decorators in TypeScript, but that’s beyond the scope of this article. If you’re curious, you can read more about it in the TypeScript docs.\n\n\n###  Use cases for TypeScript decorators\n\nNow that we’ve covered what decorators are and how to use them properly, let’s take a look at **some specific problems decorators can help us solve**.\n\n\n####  Calculate execution time\n\nLet’s say **you want to estimate how long it takes to run a function as a way to gauge your application performance**. You can create a decorator to calculate the execution time of a method and print it on the console.\n\n```\nclass Rocket {\n  @measure\n  launch() {\n    console.log(\"Launching in 3... 2... 1... 🚀\");\n  }\n}\n```\n\nThe Rocket class has a launch method inside of it. **To measure the execution time of the launch method,** you can attach the measure decorator.\n\n```\nimport { performance } from \"perf_hooks\";\n\nconst measure = (\n  target: Object,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) => {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args) {\n    const start = performance.now();\n    const result = originalMethod.apply(this, args);\n    const finish = performance.now();\n    console.log(`Execution time: ${finish - start} milliseconds`);\n    return result;\n  };\n\n  return descriptor;\n};\n```\n\nAs you can see, **the measure decorator replaces the original method with a new one that enables it to calculate the execution time of the original method and log it to the console**.\n\nTo calculate the execution time, we’ll use the [Performance Hooks API](https://nodejs.org/api/perf_hooks.html) from the Node.js standard library.\n\nInstantiate a new Rocket instance and call the launch method.\n\n```\nconst rocket = new Rocket();\nrocket.launch();\n```\n\nYou’ll get the following result.\n\n```\nLaunching in 3... 2... 1... 🚀\nExecution time: 1.0407989993691444 milliseconds\n```\n\n####   Decorator factory\n\n**To configure your decorators to act differently in a certain scenario, you can use a concept called decorator *factory*.**\n\n**Decorator factory is a function that returns a decorator**. This enables you to customize the behavior of your decorators by **passing some parameters in the factory**.\n\nTake a look at the example below.\n\n```\nconst changeValue = (value) => (target: Object, propertyKey: string) => {\n  Object.defineProperty(target, propertyKey, { value });\n};\n```\n\nThe changeValue function returns a decorator that change the value of the property based on the value passed from your factory.\n\n```\nclass Rocket {\n  @changeValue(100)\n  fuel = 50\n}\n\n\nconst rocket = new Rocket()\nconsole.log(rocket.fuel) // 100\n```\n\nNow, if you bind your decorator factory to the fuel property, the value will be 100.\n\n\n####   Automatic error guard\n\nLet’s implement what we’ve learned to solve a real-world problem.\n\n```\nclass Rocket {\n  fuel = 50;\n\n  launchToMars() {\n    console.log(\"Launching to Mars in 3... 2... 1... 🚀\");\n  }\n}\n```\n\nLet’s say you have a Rocket class that has a launchToMars method. **To launch a rocket to Mars, the fuel level must be above 100.**\n\nLet’s create the decorator for it.\n\n```\nconst minimumFuel = (fuel: number) => (\n  target: Object,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) => {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args) {\n    if (this.fuel > fuel) {\n      originalMethod.apply(this, args);\n    } else {\n      console.log(\"Not enough fuel!\");\n    }\n  };\n\n  return descriptor;\n}; \n```\nThe minimumFuel is a factory decorator. It takes the fuel parameter, which indicates how much fuel is needed to launch a particular rocket.\n\nTo check the fuel condition, wrap the original method with a new method, just like in the previous use case.\n\nNow you can plug your decorator to the launchToMars method and set the minimum fuel level.\n\n```\nclass Rocket {\n  fuel = 50;\n\n  @minimumFuel(100)\n  launchToMars() {\n    console.log(\"Launching to Mars in 3... 2... 1... 🚀\");\n  }\n}\n```\nNow if you invoke the launchToMars method, it won’t launch the rocket to Mars because the current fuel level is 50.\n\n```\nconst rocket = new Rocket()\nrocket.launchToMars()\n\n\nNot enough fuel!\n```\nThe cool thing about this decorator is that you can apply the same logic into a different method without rewriting the whole if-else statement.\n\nLet’s say you want to make a new method to launch the rocket to the moon. To do that, the fuel level must be above 25.\n\nRepeat the same code and change the parameter.\n\n```\nclass Rocket {\n  fuel = 50;\n\n  @minimumFuel(100)\n  launchToMars() {\n    console.log(\"Launching to Mars in 3... 2... 1... 🚀\");\n  }\n\n  @minimumFuel(25)\n  launchToMoon() {\n    console.log(\"Launching to Moon in 3... 2... 1... 🚀\")\n  }\n}\n```\nNow, this rocket can be launched to the moon.\n\n```\nconst rocket = new Rocket()\nrocket.launchToMoon()\n\n\nLaunching to Moon in 3... 2... 1... 🚀\n```\n\nThis type of decorator can be very useful for authentication and authorization purposes, such as checking whether a user is allowed to access some private data or not.\n\n\n###  Conclusion\n\nIt’s true that, in some scenarios, it’s not necessary to make your own decorators. Many TypeScript libraries/frameworks out there, such as TypeORM and Angular, already provide all the decorators you need. But it’s always worth the extra effort to understand **what’s going on under the hood**, and it might even inspire you to build your own TypeScript framework.","references":"- [A practical guide to TypeScript decorators - Rahman Fadhil](https://blog.logrocket.com/a-practical-guide-to-typescript-decorators/)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-decorators-a-practical-guide","weblink":"https://codersnack.com/typescript-decorators-a-practical-guide","featured_image_preview":{"id":212,"name":"typescript-icon.png","hash":"333e4b548f574703b5e47fcce9f9fc04","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/333e4b548f574703b5e47fcce9f9fc04.png","provider":"local","provider_metadata":null,"created_at":"2022-04-26T07:44:10.748Z","updated_at":"2022-04-26T07:44:10.748Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript decorators - a practical guide","created_at":"2022-04-26T09:23:52.531Z","updated_at":"2022-04-26T09:23:52.535Z"}]