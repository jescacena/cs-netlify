[{"id":46,"codersnack":{"id":47,"header":"Typescript introduction","created_at":"2020-02-11T21:45:15.749Z","updated_at":"2020-02-11T21:55:42.521Z","explanation":"TypeScript is an open-source programming language developed and maintained by **Microsoft**. It is **a strict syntactical superset of JavaScript, and adds optional static typing to the language**.\n\nTypeScript is a strict superset of ECMAScript 2015, which is itself a superset of ECMAScript 5, commonly referred to as JavaScript. As such, **a JavaScript program is also a valid TypeScript program**, and a TypeScript program can seamlessly consume JavaScript. By default the compiler targets ECMAScript 5, the current prevailing standard, but is also able to generate constructs used in ECMAScript 3 or 2015.\n\nWith TypeScript, it is possible to use existing JavaScript code, incorporate popular JavaScript libraries, and call TypeScript-generated code from other JavaScript. Type declarations for these libraries are provided with the source code.\n\n#### Type annotations\n**TypeScript provides static typing through type annotations to enable type checking at compile time**. This is optional and **can be ignored** to use the regular dynamic typing of JavaScript.\n```\nfunction add(left: number, right: number): number {\n\treturn left + right;\n}\n```\nThe annotations for the primitive types are *number*, *boolean* and *string*. Weakly or dynamically-typed structures are of type *any*.\n\n**Type annotations can be exported to a separate declarations file** to make type information available for TypeScript scripts using types already compiled into JavaScript. Annotations can be declared for an existing JavaScript library, as has been done for Node.js and jQuery.\n\n**The TypeScript compiler makes use of type inference** to infer types when types are not given. For example, the add method in the code above would be inferred as returning a number even if no return type annotation had been provided. This is based on the static types of left and right being numbers, and the compiler's knowledge that the result of adding two numbers is always a number. However, explicitly declaring the return type allows the compiler to verify correctness.\n\nIf no type can be inferred because of lack of declarations, then it defaults to the dynamic any type. **A value of the *any* type supports the same operations as a value in JavaScript** and minimal static type checking is performed for operations on any values.\n\n#### Declaration files\nWhen a TypeScript script gets compiled there is an option to generate a declaration file (with the **extension .d.ts**) that functions as **an interface to the components in the compiled JavaScrip**t. In the process the compiler strips away all function and method bodies and preserves only the signatures of the types that are exported. The resulting declaration file **can then be used to describe the exported virtual TypeScript types of a JavaScript library or module when a third-party developer consumes it from TypeScript.**\n\nThe concept of declaration files is analogous to the concept of header file found in C/C++.\n\n```\ndeclare namespace arithmetics {\n    add(left: number, right: number): number;\n    subtract(left: number, right: number): number;\n    multiply(left: number, right: number): number;\n    divide(left: number, right: number): number;\n}\n```\nType declaration files can be written by hand for existing JavaScript libraries, as has been done for jQuery and Node.js.\n\nLarge collections of declaration files for popular JavaScript libraries are hosted on GitHub in DefinitelyTyped","references":"- [Wikipedia -Typescript](https://en.wikipedia.org/wiki/TypeScript)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-introduction","weblink":"https://codersnack.com/typescript-introduction/","featured_image_preview":{"id":59,"name":"typescript-icon.png","hash":"51965127b8234ae0805f416599e2fa28","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/51965127b8234ae0805f416599e2fa28.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:45:15.758Z","updated_at":"2020-02-11T21:45:15.758Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript introduction","created_at":"2020-02-11T21:45:44.933Z","updated_at":"2020-02-11T21:45:44.936Z"},{"id":47,"codersnack":{"id":48,"header":"Typescript Basic Types","created_at":"2020-02-12T17:35:24.449Z","updated_at":"2020-02-12T20:29:42.269Z","explanation":"For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we **support much the same types as you would expect in JavaScript,** with a convenient enumeration type thrown in to help things along.\n\n#### Boolean\nThe most basic datatype is the simple true/false value, which JavaScript and TypeScript call a *boolean* value.\n```\nlet isDone: boolean = false;\n```\n#### Number\n**As in JavaScript, all numbers in TypeScript are floating point values**. These floating point numbers get the type *number*. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.\n\n```\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n```\n#### String\n**Just like JavaScript, TypeScript also uses double quotes (\") or single quotes (') to surround string data**.\n```\nlet color: string = \"blue\";\ncolor = 'red';\n```\n\nYou can also use **template strings**, which can span multiple lines and have embedded expressions. These strings are **surrounded by the backtick/backquote character**, and **embedded expressions are of the form *${ expr }***.\n\n```\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ fullName }.\nI'll be ${ age + 1 } years old next month.`;\n```\nThis is equivalent to declaring sentence like so:\n```\nlet sentence: string = \"Hello, my name is \" + fullName + \".\\n\\n\" +\n    \"I'll be \" + (age + 1) + \" years old next month.\";\n```\n#### Array\nArray types can be written in one of two ways. In the first, you use the type of the elements followed by [] to denote an array of that element type:\n\n```\nlet list: number[] = [1, 2, 3];\n```\nThe second way uses a generic array type, *Array<elemType>*:\n\n```\nlet list: Array<number> = [1, 2, 3];\n```\n#### Tuple\nTuple types allow you to** express an array with a fixed number of elements whose types are known**, but need not be the same. For example, you may want to represent a value as a pair of a string and a number:\n\n```\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\"hello\", 10]; // OK\n// Initialize it incorrectly\nx = [10, \"hello\"]; // Error\n```\nWhen accessing an element with a known index, the correct type is retrieved:\n\n```\nconsole.log(x[0].substring(1)); // OK\nconsole.log(x[1].substring(1)); // Error, 'number' does not have 'substring'\n```\nAccessing an element outside the set of known indices fails with an error:\n\n```\nx[3] = \"world\"; // Error, Property '3' does not exist on type '[string, number]'.\nconsole.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'.\n```\n\n#### Enum\n**A helpful addition to the standard set of datatypes from JavaScript is the enum**. As in languages like C#, an **enum is a way of giving more friendly names to sets of numeric values**.\n\n```\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```\n**By default, enums begin numbering their members starting at 0**. You can change this by manually setting the value of one of its members. For example, we can start the previous example at 1 instead of 0:\n\n```\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\nOr, even manually set all the values in the enum:\n\n```\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n```\nA handy feature of enums is that **you can also go from a numeric value to the name of that value in the enum**. For example, if we had the value 2 but weren’t sure what that mapped to in the Color enum above, we could look up the corresponding name:\n\n```\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName); // Displays 'Green' as its value is 2 above\n```\n\n#### Any\nWe may **need to describe the type of variables that we do not know when we are writing an application**. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, **we want to opt-out of type checking and let the values pass through compile-time checks**. To do so, we label these with the any type:\n\n```\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n```\nThe any type is a **powerful way to work with existing JavaScript**, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect *Object* to play a similar role, as it does in other languages. However, variables of type **Object only allow you to assign any value to them. You can’t call arbitrary methods on them, even ones that actually exist**:\n\n```\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\n```\n\n> Note: Avoid using Object in favor of the non-primitive object type as described in our Do’s and Don’ts section.\n\nThe any type is **also handy if you know some part of the type, but perhaps not all of it**. For example, you may have an array but the array has a mix of different types:\n\n```\nlet list: any[] = [1, true, \"free\"];\n\nlist[1] = 100;\n```\n\n#### Void\n**void is a little like the opposite of any: the absence of having any type at all**. You may commonly see this as the return type of functions that do not return a value:\n\n```\nfunction warnUser(): void {\n    console.log(\"This is my warning message\");\n}\n```\n**Declaring variables of type void is not useful because you can only assign null** (only *if --strictNullChecks* is not specified, see next section) or undefined to them:\n\n```\nlet unusable: void = undefined;\nunusable = null; // OK if `--strictNullChecks` is not given\n```\n\n#### Null and Undefined\nIn TypeScript, **both *undefined* and *null* actually have their own types named undefined and null respectively**. Much like *void*, they’re not extremely useful on their own:\n\n```\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n**By default *null* and *undefined* are subtypes of all other types**. That means you can assign null and undefined to something like number.\n\nHowever, when using the **--strictNullChecks flag**, *null* and *undefined* are **only assignable to any and their respective types** (the one exception being that *undefined* is also assignable to *void*). This helps avoid many common errors. In cases where you want to pass in either a string or null or undefined, **you can use the union type string | null | undefined.**\n\n*Union types* are an advanced topic that we’ll cover in a later chapter.\n\n> As a note: we encourage the use of *--strictNullChecks* when possible, but for the purposes of this handbook, we will assume it is turned off.\n\n#### Never\n**The never type represents the type of values that never occur**. For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type never when narrowed by any type guards that can never be true.\n\n**The never type is a subtype of, and assignable to, every type**; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never.\n\nSome examples of functions returning never:\n\n```\n// Function returning never must have unreachable end point\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// Inferred return type is never\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// Function returning never must have unreachable end point\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```\n#### Object\n***object* is a type that represents the non-primitive type**, i.e. anything that is not *number*, *string*, *boolean*, *bigint*, *symbol*, *null*, or *undefined*.\n\nWith object type, APIs like *Object.create* can be better represented. For example:\n\n```\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n\n#### Type assertions\nSometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does. Usually this will happen when **you know the type of some entity could be more specific than its current type**.\n\n**Type assertions are a way to tell the compiler \"trust me, I know what I’m doing.\"** A type assertion is like a *type cast* in other languages, but **performs no special checking or restructuring of data.** It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.\n\nType assertions have two forms. One is the **\"angle-bracket\" syntax**:\n\n```\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (<string>someValue).length;\n```\nAnd the other is the **as-syntax**:\n\n```\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (someValue as string).length;\n```\n> The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only as-style assertions are allowed.\n","references":"- [Typescriptlang Handbook - Basic Types](https://www.typescriptlang.org/docs/handbook/basic-types.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-basic-types","weblink":"https://codersnack.com/typescript-basic-types/","featured_image_preview":{"id":60,"name":"typescript-icon.png","hash":"acf312cf71ff46218adcce6e2e1d7664","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/acf312cf71ff46218adcce6e2e1d7664.png","provider":"local","provider_metadata":null,"created_at":"2020-02-12T17:35:24.468Z","updated_at":"2020-02-12T17:35:24.468Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript basic types","created_at":"2020-02-12T17:35:47.654Z","updated_at":"2020-02-12T17:35:47.658Z"},{"id":48,"codersnack":{"id":49,"header":"Typescript Interfaces","created_at":"2020-02-12T20:47:11.498Z","updated_at":"2020-02-12T20:47:11.498Z","explanation":"\nOne of TypeScript's core principles is that type checking focuses on the shape that values have. This is sometimes called \"duck typing\" or \"structural subtyping\". In TypeScript, *interfaces* fill the role of naming these types, and are **a powerful way of defining contracts within your code as well as contracts with code outside of your project**.\n\n#### Our First Interface\nThe easiest way to see how interfaces work is to start with a simple example:\n\n```\nfunction printLabel(labeledObj: { label: string }) {\n    console.log(labeledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n\nThe type checker checks the call to *printLabel*. The *printLabel* function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that at least the ones required are present and match the types required. There are some cases where TypeScript isn't as lenient, which we'll cover in a bit.\n\nWe can write the same example again, this time **using an interface to describe the requirement** of having the label property that is a string:\n\n```\ninterface LabeledValue {\n    label: string;\n}\n\nfunction printLabel(labeledObj: LabeledValue) {\n    console.log(labeledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n\nThe interface *LabeledValue* is a name we can now use to describe the requirement in the previous example. It still represents having a single property called label that is of type string. Notice we didn't have to explicitly say that the object we pass to printLabel implements this interface like we might have to in other languages. Here, it's only the shape that matters. If the object we pass to the function meets the requirements listed, then it's allowed.\n\n> It’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.\n\n#### Optional Properties\n**Not all properties of an interface may be required**. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like \"option bags\" where you pass an object to a function that only has a couple of properties filled in.\n\nHere’s an example of this pattern:\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\n    let newSquare = {color: \"white\", area: 100};\n    if (config.color) {\n        newSquare.color = config.color;\n    }\n    if (config.width) {\n        newSquare.area = config.width * config.width;\n    }\n    return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n\nInterfaces with **optional properties** are written similar to other interfaces, with **each optional property denoted by a ? at the end** of the property name in the declaration.\n\nThe advantage of optional properties is that you can describe these possibly available properties while still also **preventing use of properties that are not part of the interface**. For example, had we mistyped the name of the color property in createSquare, we would get an error message letting us know:\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    let newSquare = {color: \"white\", area: 100};\n    if (config.clor) {\n        // Error: Property 'clor' does not exist on type 'SquareConfig'\n        newSquare.color = config.clor;\n    }\n    if (config.width) {\n        newSquare.area = config.width * config.width;\n    }\n    return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n\n#### Readonly properties\nSome properties should only be modifiable when an object is first created. You can specify this by **putting readonly before the name of the property:**\n\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\nYou can construct a *Point* by assigning an object literal. After the assignment, *x* and *y* can't be changed.\n\n```\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\n\nTypeScript comes with a *ReadonlyArray<T>* type that is the same as *Array<T>* with all mutating methods removed, so you can **make sure you don’t change your arrays after creation**:\n\n```\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n\nOn the last line of the snippet you can see that even assigning the entire *ReadonlyArray* back to a normal array is illegal. You can still override it with a type assertion, though:\n\n```\na = ro as number[];\n```\n\n#### readonly vs const\nThe easiest way to remember whether to use *readonly* or *const* is to ask whether you're using it on a variable or a property. **Variables use *const* whereas properties use *readonly***.\n","references":"- [Typescriptlang interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-interfaces","weblink":"https://codersnack.com/typescript-interfaces/","featured_image_preview":{"id":61,"name":"typescript-icon.png","hash":"288b73fd91a14c4fb1ce9deb2d8efc73","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/288b73fd91a14c4fb1ce9deb2d8efc73.png","provider":"local","provider_metadata":null,"created_at":"2020-02-12T20:47:11.505Z","updated_at":"2020-02-12T20:47:11.505Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript interfaces","created_at":"2020-02-12T20:47:37.776Z","updated_at":"2020-02-12T20:47:37.779Z"},{"id":49,"codersnack":{"id":50,"header":"Typescript Generics","created_at":"2020-02-12T22:00:24.934Z","updated_at":"2020-02-12T22:00:24.934Z","explanation":"A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. **Components that are capable of working on the data of today as well as the data of tomorrow** will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is **generics**, that is, being **able to create a component that can work over a variety of types rather than a single one**. This allows users to consume these components and use their own types.\n\n#### Hello World of Generics\nTo start off, let’s do the \"hello world\" of *generics*: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command.\n\n**Without generics**, we would either have to give the identity function a specific type:\n```\nfunction identity(arg: number): number {\n    return arg;\n}\n```\nOr, we could describe the identity function **using the any type**:\n\n```\nfunction identity(arg: any): any {\n    return arg;\n}\n```\nWhile using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, **we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.**\n\nInstead, we need **a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned**. Here, we will use a *type* variable, a special kind of variable that works on types rather than values.\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\nWe’ve now added *a type variable T *to the identity function. **This T allows us to capture the type the user provides** (e.g. number), **so that we can use that information later**. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the *identity* function is generic, as it works over a range of types. Unlike using *any*, it's also just as precise (ie, it doesn't lose any information) as the first *identity* function that used numbers for the argument and return type.\n\nOnce we’ve written the generic *identity* function, **we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:**\n\n```\nlet output = identity<string>(\"myString\");  // type of output will be 'string'\n```\n\nHere we explicitly set T to be string as one of the arguments to the function call, denoted using the <> around the arguments rather than ().\n\nThe second way is also perhaps the most common. Here **we use type argument inference** , that is, we want the compiler to set the value of T for us automatically based on the type of the argument we pass in:\n\n```\nlet output = identity(\"myString\");  // type of output will be 'string'\n```\nNotice that we didn't have to explicitly pass the type in the angle brackets (<>); the compiler just looked at the value \"myString\", and set T to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\n#### Working with Generic Type Variables\nWhen you begin to use generics, you’ll notice that when you create generic functions like identity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our identity function from earlier:\n\n```\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\nWhat if we want to also log the length of the argument arg to the console with each call? We might be tempted to write this:\n\n```\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n```\nWhen we do, the compiler will give us an error that we're using the .length member of arg, but nowhere have we said that arg has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a number instead, which does not have a .length member.\n\nLet's say that we’ve actually intended this function to work on arrays of T rather than T directly. Since we're working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types:\n\n```\nfunction loggingIdentity<T>(arg: T[]): T[] {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\nYou can read the type of *loggingIdentity* as \"the generic function loggingIdentity takes a type parameter T, and an argument arg which is an array of Ts, and returns an array of Ts.\" If we passed in an array of numbers, we'd get an array of numbers back out, as T would bind to number. This allows us to use our generic type variable T as part of the types we're working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\n```\nfunction loggingIdentity<T>(arg: Array<T>): Array<T> {\n    console.log(arg.length);  // Array has a .length, so no more error\n    return arg;\n}\n```\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like Array<T>","references":"- [Typescriptlang generics](https://www.typescriptlang.org/docs/handbook/generics.html)","featured_image_url":"https://codersnack.com/assets/images/typescript-icon.png","slug":"typescript-generics","weblink":"https://codersnack.com/typescript-generics/","featured_image_preview":{"id":62,"name":"typescript-icon.png","hash":"e8fb797f12614842b93ce830ba4463d7","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/e8fb797f12614842b93ce830ba4463d7.png","provider":"local","provider_metadata":null,"created_at":"2020-02-12T22:00:24.949Z","updated_at":"2020-02-12T22:00:24.949Z"}},"codersnacks_category":{"id":10,"header":"Typescript","description":"Syntactical superset of JavaScript to adds optional static typing to Javascript","snacks_by_cat_json_filename":"typescript.snacks.json","key":"typescript","image_url":"https://codersnack.com/assets/images/typescript-icon.png","created_at":"2020-02-11T21:36:00.170Z","updated_at":"2020-02-11T21:54:32.612Z","image_preview":{"id":58,"name":"typescript-icon.png","hash":"3ccf0f127c3f4151a021a2d16c915042","sha256":"ZgtqQkJg-bfOvA-p5xP8Mh5khfeqvzuCd6612g-G6rk","ext":".png","mime":"image/png","size":11.79,"url":"/uploads/3ccf0f127c3f4151a021a2d16c915042.png","provider":"local","provider_metadata":null,"created_at":"2020-02-11T21:36:00.187Z","updated_at":"2020-02-11T21:36:00.187Z"}},"title":"Typescript generics","created_at":"2020-02-12T22:00:42.768Z","updated_at":"2020-02-12T22:00:42.771Z"}]