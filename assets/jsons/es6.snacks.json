[{"id":1,"codersnack":{"id":1,"header":"ES6 let and closures","created_at":"2019-12-30T18:56:27.814Z","updated_at":"2021-10-29T10:32:21.011Z","explanation":"Functions can be nested inside other functions. \nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){ \n       console.log(x); \n    }\n    log();\n})();\n```\nlog() is a nested function inside the autorun() function.log() accesses the variable x from its outer function. The log() function is a closure.\n\n> **Closures** are inner functions. Closures can be created by defining a function inside another function or inside a block.\n> **Lexical scope** is the ability of the inner function to access the outer scope in which it is defined.\nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){\n      console.log(x);\n    };\n    \n    function run(fn){\n      let x = 100;\n      fn();\n    }\n    \n    run(log);//1\n})();\n```\n\nThe log function is a closure. It refers the x variable from its parent function autorun() , not the one from the run() function.\n> The closure function has access to the scope in which it was created, not the scope in which it is executed.\n\nThe local function scope of autorun() is the lexical scope of the log() function.\n\n> Closures store references of outer variables, they do not copy the actual values.\n\nThe for loop statement, with the let declaration, creates a new variable local to the block scope, for each iteration. The next loop creates five closures over five different i variables.\n\n```\n(function run(){\n  for(let i=0; i<5; i++){\n    setTimeout(function log(){\n      console.log(i); //0 1 2 3 4\n    }, 100);\n  }\n})();\n```\nWriting the same code with var will create five closures, over the same variable, so all closures will display the last value of i . The log() function is a closure\n\n","references":"- [[Medium] Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)\n- [[Medium] These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)","featured_image_url":"https://codersnack.com/assets/images/es6-let-closure.png","slug":"es6-let-closures","weblink":"https://codersnack.com/es6-let-closures/","featured_image_preview":{"id":1,"name":"es6-let-closure.png","hash":"fbc6a364da1748bea449d8b8c1f818bd","sha256":"T_ihZTRaAcE59QoXy89nBis36SNKXYyNZ2x8-5yYvBw","ext":".png","mime":"image/png","size":9.35,"url":"/uploads/fbc6a364da1748bea449d8b8c1f818bd.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T18:58:50.917Z","updated_at":"2019-12-30T18:58:50.917Z"}},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"ES6-ES6 let and closures ","created_at":"2019-12-30T19:00:22.032Z","updated_at":"2019-12-31T20:12:05.206Z"},{"id":2,"codersnack":{"id":2,"header":"ES6 let and const","created_at":"2019-12-31T16:35:45.883Z","updated_at":"2020-04-20T19:03:20.605Z","explanation":"There are two ways for declaring a variable (let and const) plus one that has become obsolete (var).\n\n## let\n\n**let declares and optionally initializes a variable in the current scope**. The current scope can be either a module, a function or a block. The value of a variable that is not initialized is undefined.\nScope defines the lifetime and visibility of a variable. Variables are not visible outside the scope in which they are declared.\nConsider the next code that emphasizes let block scope:\n```\nlet x = 1;\n{ \n  let x = 2;\n}\nconsole.log(x); //1\n```\nIn contrast, the var declaration had no block scope:\n```\nvar x = 1;\n{ \n  var x = 2;\n}\nconsole.log(x); //2\n```\n\n## const\n\n**const declares a variable that cannot be reassigned**. It becomes a constant only when the assigned value is immutable.\nAn immutable value is a value that, once created, cannot be changed. \n\n> Primitive values are immutable, objects are mutable.\n\n**```const``` freezes the variable, ```Object.freeze()```  freezes the object.**\n\n**The initialization of the ```const``` variable is mandatory.**\n","references":"- [Medium - These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)\n- [Medium - Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)","featured_image_url":"https://codersnack.com/assets/images/es6-let-const.png","slug":"es6-let-const","weblink":"https://codersnack.com/es6-let-const/","featured_image_preview":{"id":3,"name":"es6-let-const.png","hash":"948e28b024e349818929b0c12c071613","sha256":"2zlsGi4zWiNhlovCU5Vj5PG7oZbokWm2d-9p_RNCB-g","ext":".png","mime":"image/png","size":36.12,"url":"/uploads/948e28b024e349818929b0c12c071613.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T16:35:45.896Z","updated_at":"2019-12-31T16:35:45.896Z"}},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"ES6-ES6 let and const","created_at":"2019-12-31T16:37:07.331Z","updated_at":"2019-12-31T20:12:56.454Z"},{"id":7,"codersnack":{"id":7,"header":"ES6 modules","created_at":"2020-01-06T18:32:38.545Z","updated_at":"2020-02-23T00:27:01.866Z","explanation":"Before modules, a variable declared outside any function was a global variable.\n\n**With modules, a variable declared outside any function is hidden and not available to other modules unless it is explicitly exported**.\n\n*Exporting makes a function or object available to other modules*. In the next example, I export functions from different modules:\n\n```\n//module \"./TodoStore.js\"\nexport default function TodoStore(){}\n\n//module \"./UserStore.js\"\nexport default function UserStore(){}\n```\n\n*Importing makes a function or object, from other modules, available to the current module*.\n\n```\nimport TodoStore from \"./TodoStore\";\nimport UserStore from \"./UserStore\";\n\nconst todoStore = TodoStore();\nconst userStore = UserStore();\n```","references":"- [These are the features in es6 that you should know](https://www.freecodecamp.org/news/these-are-the-features-in-es6-that-you-should-know-1411194c71cb/)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-modules","weblink":"https://codersnack.com/es6-modules/","featured_image_preview":{"id":10,"name":"ECMAScript-01.png","hash":"ec1784864262409a869888331ef51b2b","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/ec1784864262409a869888331ef51b2b.png","provider":"local","provider_metadata":null,"created_at":"2020-01-06T18:32:38.559Z","updated_at":"2020-01-06T18:32:38.559Z"}},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6-es6-modules","created_at":"2020-01-06T18:33:11.388Z","updated_at":"2020-01-06T18:33:11.392Z"},{"id":70,"codersnack":{"id":71,"header":"ES6 classes","created_at":"2020-04-22T19:15:11.222Z","updated_at":"2020-04-22T19:15:11.222Z","explanation":"JavaScript classes, introduced in ECMAScript 2015, are primarily **syntactical sugar over JavaScript's existing prototype-based inheritance**. The class syntax *does not introduce a new object-oriented inheritance model* to JavaScript.\n\n### Defining classes\n**Classes are in fact \"special functions\",** and just as you can define function expressions and function declarations, the class syntax has two components: class expressions and class declarations.\n\n#### Class declarations\nOne way to define a class is using a class declaration. To declare a class, you use the ```class``` keyword with the name of the class (\"Rectangle\" here).\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n```\n#### Hoisting\nAn important difference between function declarations and class declarations is that function declarations are hoisted and class declarations are not. **You first need to declare your class and then access it**, otherwise code like the following will throw a **ReferenceError**:\n\n```\nconst p = new Rectangle(); // ReferenceError\n\nclass Rectangle {}\n```\n\n#### Class expressions\n**A class expression is another way to define a class**. Class expressions can be **named** or **unnamed**. The name given to a named class expression is local to the class's body. (it can be retrieved through the class's (not an instance's) name property, though).\n\n```\n// unnamed\nlet Rectangle = class {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle\"\n\n// named\nlet Rectangle = class Rectangle2 {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle2\"\n```\n\n> Note: Class expressions are subject to the same hoisting restrictions as described in the Class declarations section.\n\n### Class body and method definitions\n**The body of a class is the part that is in curly brackets {}**. This is where you define **class members,** such as methods or **constructor**.\n\n#### Strict mode\n**The body of a class is executed in strict mode**, i.e., **code written here is subject to stricter syntax for increased performance**, some otherwise silent errors will be thrown, and certain keywords are reserved for future versions of ECMAScript.\n\n#### Constructor\n**The constructor method is a special method for creating and initializing an object created with a class**. There can only be one special method with the name \"constructor\" in a class. A SyntaxError will be thrown if the class contains more than one occurrence of a constructor method.\n\nA constructor can use the ```super``` keyword **to call the constructor of the super class**.\n\n#### Prototype methods\nSee also method definitions.\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n  // Getter\n  get area() {\n    return this.calcArea();\n  }\n  // Method\n  calcArea() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Rectangle(10, 10);\n\nconsole.log(square.area); // 100\n```\n\n#### Static methods\nThe ```static``` keyword **defines a static method for a class.** Static methods **are called without instantiating their class and cannot be called through a class instance**. Static methods are often used to create utility functions for an application.\n\n```\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  static distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n\n    return Math.hypot(dx, dy);\n  }\n}\n\nconst p1 = new Point(5, 5);\nconst p2 = new Point(10, 10);\np1.distance; //undefined\np2.distance; //undefined\n\nconsole.log(Point.distance(p1, p2)); // 7.0710678118654755\n```\n#### Boxing with prototype and static methods\n**When a static or prototype method is called without a value for this, the this value will be undefined inside the method**. This behavior will be the same even if the \"use strict\" directive isn't present, because code within the class body's syntactic boundary is always executed in strict mode.\n\n```\nclass Animal { \n  speak() {\n    return this;\n  }\n  static eat() {\n    return this;\n  }\n}\n\nlet obj = new Animal();\nobj.speak(); // the Animal object\nlet speak = obj.speak;\nspeak(); // undefined\n\nAnimal.eat() // class Animal\nlet eat = Animal.eat;\neat(); // undefined\n```\n\n**If the above is written using traditional function-based syntax, then autoboxing in method calls will happen in non–strict mode based on the initial this value**. If the initial value is undefined, this will be set to the global object.\n\nAutoboxing will not happen in strict mode, the this value remains as passed.\n\n```\nfunction Animal() { }\n\nAnimal.prototype.speak = function() {\n  return this;\n}\n\nAnimal.eat = function() {\n  return this;\n}\n\nlet obj = new Animal();\nlet speak = obj.speak;\nspeak(); // global object\n\nlet eat = Animal.eat;\neat(); // global object\n```\n\n#### Instance properties\nInstance properties must be defined inside of class methods:\n\n```\nclass Rectangle {\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\n\nStatic (class-side) data properties and prototype data properties must be defined outside of the ClassBody declaration:\n\n```\nRectangle.staticWidth = 20;\nRectangle.prototype.prototypeWidth = 25;\n```\n#### Field declarations\n> **Public and private field declarations are an experimental feature (stage 3) proposed at TC39**, the JavaScript standards committee. Support in browsers is limited, but the feature can be used through a build step with systems like Babel.\n\n#### Public field declarations\nWith the JavaScript field declaration syntax, the above example can be written as:\n\n```\nclass Rectangle {\n  height = 0;\n  width;\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\nBy declaring fields up-front, **class definitions become more self-documenting**, and the fields are always present.\n\nAs seen above, the fields can be declared with or without a default value.\n\n#### Private field declarations\nUsing private fields, the definition can be refined as below.\n\n```\nclass Rectangle {\n  #height = 0;\n  #width;\n  constructor(height, width) {    \n    this.#height = height;\n    this.#width = width;\n  }\n}\n```\nIt's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things which are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change version to version.\n\nPrivate fields can only be declared up-front in a field declaration.\n\nPrivate fields cannot be created later through assigning to them, the way that normal properties can.\n\n\n### Sub classing with extends\nThe ```extends``` keyword is used in class declarations or class expressions to create a class as a child of another class.\n\n```\nclass Animal { \n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name); // call the super class constructor and pass in the name parameter\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n```\nIf there is a constructor present in the subclass, it needs to first call super() before using \"this\".\n\nOne may also extend traditional function-based \"classes\":\n\n```\nfunction Animal (name) {\n  this.name = name;  \n}\n\nAnimal.prototype.speak = function () {\n  console.log(`${this.name} makes a noise.`);\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n\n//NB: For similar methods, the child's method takes precedence over parent's method\n```\n\n**Note that classes cannot extend regular (non-constructible) objects**. If you want to inherit from a regular object, you can instead use **Object.setPrototypeOf()**:\n\n```\nconst Animal = {\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n};\n\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// If you do not do this you will get a TypeError when you invoke speak\nObject.setPrototypeOf(Dog.prototype, Animal);\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie makes a noise.\n```\n","references":"- [MDN classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-classes","weblink":"https://codersnack.com/es6-classes/","featured_image_preview":{"id":98,"name":"ECMAScript-01.png","hash":"d3322ef305414d6c9c3e83734a95b650","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/d3322ef305414d6c9c3e83734a95b650.png","provider":"local","provider_metadata":null,"created_at":"2020-04-22T19:15:11.249Z","updated_at":"2020-04-22T19:15:11.249Z"}},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"Es6 classes","created_at":"2020-04-22T19:15:29.783Z","updated_at":"2020-04-22T19:15:29.788Z"},{"id":121,"codersnack":{"id":122,"header":"ES6 Proxy","created_at":"2021-12-01T12:37:36.405Z","updated_at":"2021-12-01T12:37:36.405Z","explanation":"**The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.**\n\n## Description\n\nA Proxy is created with two parameters:\n\n- **target**: the original object which you want to proxy\n- **handler**: an object that defines which operations will be intercepted and how to redefine intercepted operations.\n\nFor example, this code defines a simple target with just two properties, and an even simpler handler with no properties:\n\n```\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\n\nconst handler1 = {};\n\nconst proxy1 = new Proxy(target, handler1);\n```\n\nBecause the handler is empty, this proxy behaves just like the original target:\n\n```\nconsole.log(proxy1.message1); // hello\nconsole.log(proxy1.message2); // everyone\n```\n\nTo customise the proxy, we define functions on the handler object:\n\n```\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\n\nconst handler2 = {\n  get: function(target, prop, receiver) {\n    return \"world\";\n  }\n};\n\nconst proxy2 = new Proxy(target, handler2);\n```\n\n**Here we've provided an implementation of the *get()* handler, which intercepts attempts to access properties in the target.**\n\n**Handler functions are sometimes called *traps***, presumably because they trap calls to the target object. The very simple trap in handler2 above redefines all property accessors:\n\n```\nconsole.log(proxy2.message1); // world\nconsole.log(proxy2.message2); // world\n```\n\n**With the help of the Reflect class we can give some accessors the original behavior and redefine others**:\n\n```\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\n\nconst handler3 = {\n  get: function (target, prop, receiver) {\n    if (prop === \"message2\") {\n      return \"world\";\n    }\n    return Reflect.get(...arguments);\n  },\n};\n\nconst proxy3 = new Proxy(target, handler3);\n\nconsole.log(proxy3.message1); // hello\nconsole.log(proxy3.message2); // world\n```\n\n## Constructor\n\n**Proxy()**\nCreates a new Proxy object.\n\n## Static methods\n\n**Proxy.revocable()**\nCreates a revocable Proxy object.\n\n## Examples\n\n//////////\n\n### Basic example\n\n**In this simple example, the number 37 gets returned as the default value when the property name is not in the object. It is using the get() handle**r.\n\n``` \nconst handler = {\n  get: function(obj, prop) {\n    return prop in obj ?\n      obj[prop] :\n      37;\n  }\n};\n\nconst p = new Proxy({}, handler);\np.a = 1;\np.b = undefined;\n\nconsole.log(p.a, p.b);\n//  1, undefined\n\nconsole.log('c' in p, p.c);\n//  false, 37\n``` \n\n### No-op forwarding proxy\nIn this example, we are using a native JavaScript object to which our **proxy will forward all operations that are applied to it**.\n\n```\nconst target = {};\nconst p = new Proxy(target, {});\n\np.a = 37;\n//  operation forwarded to the target\n\nconsole.log(target.a);\n//  37\n//  (The operation has been properly forwarded!)\n```\n\n> Note that while this \"no-op\" works for JavaScript objects, **it does not work for native browser objects like DOM Elements.**\n\n## Validation\n\nWith a Proxy, you can easily **validate the passed value for an object**. This example uses the ***set()* handler**.\n\n```\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) {\n        throw new TypeError('The age is not an integer');\n      }\n      if (value > 200) {\n        throw new RangeError('The age seems invalid');\n      }\n    }\n\n    // The default behavior to store the value\n    obj[prop] = value;\n\n    // Indicate success\n    return true;\n  }\n};\n\nconst person = new Proxy({}, validator);\n\nperson.age = 100;\nconsole.log(person.age); // 100\nperson.age = 'young';    // Throws an exception\nperson.age = 300;        // Throws an exception\n```\n\n### Extending constructor\n\nA function proxy could easily extend a constructor with a new constructor. This example uses the ***construct()* and *apply()* handlers**.\n\n```\nfunction extend(sup, base) {\n  var descriptor = Object.getOwnPropertyDescriptor(\n    base.prototype, 'constructor'\n  );\n  base.prototype = Object.create(sup.prototype);\n  var handler = {\n    construct: function(target, args) {\n      var obj = Object.create(base.prototype);\n      this.apply(target, obj, args);\n      return obj;\n    },\n    apply: function(target, that, args) {\n      sup.apply(that, args);\n      base.apply(that, args);\n    }\n  };\n  var proxy = new Proxy(base, handler);\n  descriptor.value = proxy;\n  Object.defineProperty(base.prototype, 'constructor', descriptor);\n  return proxy;\n}\n\nvar Person = function(name) {\n  this.name = name;\n};\n\nvar Boy = extend(Person, function(name, age) {\n  this.age = age;\n});\n\nBoy.prototype.gender = 'M';\n\nvar Peter = new Boy('Peter', 13);\n\nconsole.log(Peter.gender);  // \"M\"\nconsole.log(Peter.name);    // \"Peter\"\nconsole.log(Peter.age);     // 13\n```\n\n### Manipulating DOM nodes\n\nSometimes **you want to toggle the attribute or class name of two different elements**. Here's how using the *set()* handler.\n\n```\nlet view = new Proxy({\n  selected: null\n},\n{\n  set: function(obj, prop, newval) {\n    let oldval = obj[prop];\n\n    if (prop === 'selected') {\n      if (oldval) {\n        oldval.setAttribute('aria-selected', 'false');\n      }\n      if (newval) {\n        newval.setAttribute('aria-selected', 'true');\n      }\n    }\n\n    // The default behavior to store the value\n    obj[prop] = newval;\n\n    // Indicate success\n    return true;\n  }\n});\n\nlet i1 = view.selected = document.getElementById('item-1');  //giving error here, i1 is null\nconsole.log(i1.getAttribute('aria-selected'));\n//  'true'\n\nlet i2 = view.selected = document.getElementById('item-2');\nconsole.log(i1.getAttribute('aria-selected'));\n//  'false'\n\nconsole.log(i2.getAttribute('aria-selected'));\n//  'true'\nNote: even if selected: !null, then giving oldval.setAttribute is not a function\n```\n\n\n### Value correction and an extra property\n\n**The products proxy object evaluates the passed value and converts it to an array if needed.** The object also supports an extra property called ***latestBrowser*** both as a getter and a setter.\n\n```\nlet products = new Proxy({\n  browsers: ['Internet Explorer', 'Netscape']\n},\n{\n  get: function(obj, prop) {\n    // An extra property\n    if (prop === 'latestBrowser') {\n      return obj.browsers[obj.browsers.length - 1];\n    }\n\n    // The default behavior to return the value\n    return obj[prop];\n  },\n  set: function(obj, prop, value) {\n    // An extra property\n    if (prop === 'latestBrowser') {\n      obj.browsers.push(value);\n      return true;\n    }\n\n    // Convert the value if it is not an array\n    if (typeof value === 'string') {\n      value = [value];\n    }\n\n    // The default behavior to store the value\n    obj[prop] = value;\n\n    // Indicate success\n    return true;\n  }\n});\n\nconsole.log(products.browsers);\n//  ['Internet Explorer', 'Netscape']\n\nproducts.browsers = 'Firefox';\n//  pass a string (by mistake)\n\nconsole.log(products.browsers);\n//  ['Firefox'] <- no problem, the value is an array\n\nproducts.latestBrowser = 'Chrome';\n\nconsole.log(products.browsers);\n//  ['Firefox', 'Chrome']\n\nconsole.log(products.latestBrowser);\n//  'Chrome'\n```\n\n### Finding an array item object by its property\n\n**This proxy extends an array with some utility features**. As you see, you can flexibly \"define\" properties without using Object.defineProperties(). This example can be adapted to find a table row by its cell. In that case, the target will be table.rows.\n\n```\nlet products = new Proxy([\n  { name: 'Firefox', type: 'browser' },\n  { name: 'SeaMonkey', type: 'browser' },\n  { name: 'Thunderbird', type: 'mailer' }\n],\n{\n  get: function(obj, prop) {\n    // The default behavior to return the value; prop is usually an integer\n    if (prop in obj) {\n      return obj[prop];\n    }\n\n    // Get the number of products; an alias of products.length\n    if (prop === 'number') {\n      return obj.length;\n    }\n\n    let result, types = {};\n\n    for (let product of obj) {\n      if (product.name === prop) {\n        result = product;\n      }\n      if (types[product.type]) {\n        types[product.type].push(product);\n      } else {\n        types[product.type] = [product];\n      }\n    }\n\n    // Get a product by name\n    if (result) {\n      return result;\n    }\n\n    // Get products by type\n    if (prop in types) {\n      return types[prop];\n    }\n\n    // Get product types\n    if (prop === 'types') {\n      return Object.keys(types);\n    }\n\n    return undefined;\n  }\n});\n\nconsole.log(products[0]);          // { name: 'Firefox', type: 'browser' }\nconsole.log(products['Firefox']);  // { name: 'Firefox', type: 'browser' }\nconsole.log(products['Chrome']);   // undefined\nconsole.log(products.browser);     // [{ name: 'Firefox', type: 'browser' }, { name: 'SeaMonkey', type: 'browser' }]\nconsole.log(products.types);       // ['browser', 'mailer']\nconsole.log(products.number);      // 3\n```\n\n\n### A complete traps list example\n\nNow in order to create a complete sample traps list, for didactic purposes, we will try to proxify a non-native object that is particularly suited to this type of operation: the docCookies global object created by a simple cookie framework.\n\n```\n/*\n  var docCookies = ... get the \"docCookies\" object here:\n  https://reference.codeproject.com/dom/document/cookie/simple_document.cookie_framework\n*/\n\nvar docCookies = new Proxy(docCookies, {\n  get: function (oTarget, sKey) {\n    return oTarget[sKey] || oTarget.getItem(sKey) || undefined;\n  },\n  set: function (oTarget, sKey, vValue) {\n    if (sKey in oTarget) { return false; }\n    return oTarget.setItem(sKey, vValue);\n  },\n  deleteProperty: function (oTarget, sKey) {\n    if (!sKey in oTarget) { return false; }\n    return oTarget.removeItem(sKey);\n  },\n  enumerate: function (oTarget, sKey) {\n    return oTarget.keys();\n  },\n  ownKeys: function (oTarget, sKey) {\n    return oTarget.keys();\n  },\n  has: function (oTarget, sKey) {\n    return sKey in oTarget || oTarget.hasItem(sKey);\n  },\n  defineProperty: function (oTarget, sKey, oDesc) {\n    if (oDesc && 'value' in oDesc) { oTarget.setItem(sKey, oDesc.value); }\n    return oTarget;\n  },\n  getOwnPropertyDescriptor: function (oTarget, sKey) {\n    var vValue = oTarget.getItem(sKey);\n    return vValue ? {\n      value: vValue,\n      writable: true,\n      enumerable: true,\n      configurable: false\n    } : undefined;\n  },\n});\n\n/* Cookies test */\n\nconsole.log(docCookies.my_cookie1 = 'First value');\nconsole.log(docCookies.getItem('my_cookie1'));\n\ndocCookies.setItem('my_cookie1', 'Changed value');\nconsole.log(docCookies.my_cookie1);\n```","references":"- [MDN - Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n\n","featured_image_url":"https://codersnack.com/assets/images/design-patterns.jpg","slug":"es6-proxy","weblink":"https://codersnack.com/es6-proxy","featured_image_preview":{"id":158,"name":"design-patterns.jpeg","hash":"7f49cf5a0536421bb4595c645fb127d8","sha256":"VsHmj4Ik_4HvdSZoE8wLe3nE7RbkzGzaMehB3mO1T4A","ext":".jpeg","mime":"image/jpeg","size":23.12,"url":"/uploads/7f49cf5a0536421bb4595c645fb127d8.jpeg","provider":"local","provider_metadata":null,"created_at":"2021-12-01T12:37:36.453Z","updated_at":"2021-12-01T12:37:36.453Z"}},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"ES6 Proxy","created_at":"2021-12-01T12:38:27.468Z","updated_at":"2021-12-01T12:38:27.473Z"},{"id":122,"codersnack":{"id":121,"header":"Iterators and Generators","created_at":"2021-12-01T11:12:05.044Z","updated_at":"2021-12-01T11:12:05.044Z","explanation":"**Iterators and Generators bring the concept of iteration directly into the core language and provide a mechanism for customizing the behavior of for...of loops**.\n\nFor details, see also:\n\n- [Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)\n- [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\n- [function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) and [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n- [yield](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield) and [yield*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)\n\n\n## Iterators\n\n**In JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.**\n\nSpecifically, an iterator is **any object which implements the Iterator protocol by having a next() method**  that returns an object with two **properties**:\n\n- value\nThe next value in the iteration sequence.\n\n- done\nThis is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.\n\nOnce created, an iterator object can be iterated explicitly by **repeatedly calling next()**. **Iterating over an iterator is said to consume the iterator**, because it is generally only possible **to do once**. After a **terminating value **has been yielded additional calls to next() should continue to return **{done: true}**.\n\n> The most common iterator in JavaScript is the **Array iterator**, which returns each value in the associated array in sequence.\n\nWhile it is easy to imagine that all iterators could be expressed as arrays, this is not true. **Arrays must be allocated in their entirety, but iterators are consumed only as necessary.** Because of this, iterators can express **sequences of unlimited size**, such as the range of integers between 0 and Infinity.\n\nHere is an **example** which can do just that. It allows creation of a simple range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.\n```\nfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {\n    let nextIndex = start;\n    let iterationCount = 0;\n\n    const rangeIterator = {\n       next: function() {\n           let result;\n           if (nextIndex < end) {\n               result = { value: nextIndex, done: false }\n               nextIndex += step;\n               iterationCount++;\n               return result;\n           }\n           return { value: iterationCount, done: true }\n       }\n    };\n    return rangeIterator;\n}\n```\n\nUsing the iterator then looks like this:\n\n```\nconst it = makeRangeIterator(1, 10, 2);\n\nlet result = it.next();\nwhile (!result.done) {\n console.log(result.value); // 1 3 5 7 9\n result = it.next();\n}\n\nconsole.log(\"Iterated over sequence of size: \", result.value); // [5 numbers returned, that took interval in between: 0 to 10]\n```\n\n> **Note**: It is not possible to know reflectively whether a particular object is an iterator. If you need to do this, use Iterables.\n\n\n## Generator functions\n\nWhile custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. **Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous**. Generator functions are written using the **function* syntax**.\n\n**When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a *Generator***. \n\n**When a value is consumed by calling the generator's *next* method, the Generator function executes until it encounters the *yield* keyword.**\n\n**The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.**\n\nWe can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.\n\n```\nfunction* makeRangeIterator(start = 0, end = 100, step = 1) {\n    let iterationCount = 0;\n    for (let i = start; i < end; i += step) {\n        iterationCount++;\n        yield i;\n    }\n    return iterationCount;\n}\n```\n\n\n## Iterables\n\n**An object is iterable if it defines its iteration behavior, such as what values are looped over in a for...of construct**. \n\n> Some built-in types, such as Array or Map, have a default iteration behavior, while other types (such as Object) do not.\n\nIn order to be iterable, an object **must implement the @@iterator method**. This means that the object (or one of the objects up its prototype chain) **must have a property with a *Symbol.iterator* key**.\n\n**It may be possible to iterate over an iterable more than once, or only once**. It is up to the programmer to know which is the case.\n\n**Iterables which can iterate only once (such as Generators) customarily return *this* from their @@iterator method**, \n\nwhereas **iterables which can be iterated many times must return *a new iterator* on each invocation of @@iterator**.\n\n```\nfunction* makeIterator() {\n    yield 1;\n    yield 2;\n}\n\nconst it = makeIterator();\n\nfor (const itItem of it) {\n    console.log(itItem);\n}\n\nconsole.log(it[Symbol.iterator]() === it) // true;\n\n// This example show us generator(iterator) is iterable object,\n// which has the @@iterator method return the it (itself),\n// and consequently, the it object can iterate only _once_.\n\n// If we change it's @@iterator method to a function/generator\n// which returns a new iterator/generator object, (it)\n// can iterate many times\n\nit[Symbol.iterator] = function* () {\n  yield 2;\n  yield 1;\n};\n```\n\n\n## User-defined iterables\n\nYou can make your own iterables like this:\n\n```\nconst myIterable = {\n    *[Symbol.iterator]() {\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\n\nfor (let value of myIterable) {\n    console.log(value);\n}\n// 1\n// 2\n// 3\n\nor\n\n[...myIterable]; // [1, 2, 3]\n```\n\n## Built-in iterables\n\nString, Array, TypedArray, Map and Set are all built-in iterables, because their prototype objects all have a Symbol.iterator method.\n\n\n## Syntaxes expecting iterables\n\nSome statements and expressions expect iterables. For example: the for-of loops, yield*.\n\n```\nfor (let value of ['a', 'b', 'c']) {\n    console.log(value);\n}\n// \"a\"\n// \"b\"\n// \"c\"\n\n[...'abc'];\n// [\"a\", \"b\", \"c\"]\n\nfunction* gen() {\n  yield* ['a', 'b', 'c'];\n}\n\ngen().next();\n// { value: \"a\", done: false }\n\n[a, b, c] = new Set(['a', 'b', 'c']);\na;\n// \"a\"\n```\n\n## Advanced generators\n\n**Generators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute** (or even infinite sequences, as demonstrated above).\n\n**The *next()* method also accepts a value, which can be used to modify the internal state of the generator**. A value passed to next() will be received by yield .\n\n> **Note**: A value passed to the first invocation of next() is always ignored.\n\nHere is the **fibonacci generator using next(x) to restart the sequence**:\n\n```\nfunction* fibonacci() {\n  let current = 0;\n  let next = 1;\n  while (true) {\n    let reset = yield current;\n    [current, next] = [next, next + current];\n    if (reset) {\n        current = 0;\n        next = 1;\n    }\n  }\n}\n\nconst sequence = fibonacci();\nconsole.log(sequence.next().value);     // 0\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 2\nconsole.log(sequence.next().value);     // 3\nconsole.log(sequence.next().value);     // 5\nconsole.log(sequence.next().value);     // 8\nconsole.log(sequence.next(true).value); // 0\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 2\n```\n\n**You can force a generator to throw an exception by calling its *throw()* method** and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the yield that is currently suspended were instead a throw value statement.\n\nIf the exception is not caught from within the generator,  it will propagate up through the call to throw(), and subsequent calls to next() will result in the done property being true.\n\n**Generators have a *return(value)* method that returns the given value and finishes the generator itself.**\n\n[Codepen Jes Example](https://codepen.io/jescacena/pen/oNGgGJX)\n\n","references":"- [MDN - Iterators and Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)","featured_image_url":"https://codersnack.com/assets/images/design-patterns.jpg","slug":"design-patterns-iterators-generators","weblink":"https://codersnack.com/design-patterns-iterators-generators","featured_image_preview":{"id":157,"name":"design-patterns.jpeg","hash":"4c92947b000b454f98832e0871cd702f","sha256":"VsHmj4Ik_4HvdSZoE8wLe3nE7RbkzGzaMehB3mO1T4A","ext":".jpeg","mime":"image/jpeg","size":23.12,"url":"/uploads/4c92947b000b454f98832e0871cd702f.jpeg","provider":"local","provider_metadata":null,"created_at":"2021-12-01T11:12:05.064Z","updated_at":"2021-12-01T11:12:05.064Z"}},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"ES6 - Iterators and Generators","created_at":"2021-12-01T12:38:53.744Z","updated_at":"2021-12-01T12:38:53.751Z"}]