[{"id":53,"codersnack":{"id":54,"header":"Introduction to Web Components","created_at":"2020-02-29T11:06:51.993Z","updated_at":"2020-02-29T21:31:43.928Z","explanation":"### What are Web Components, anyway?\n\nWeb Components consist of **three separate technologies that are used together:**\n\n- **Custom Elements**. Quite simply, these are fully-valid HTML elements with custom templates, behaviors and tag names (e.g. ```<one-dialog>```) made with a set of JavaScript APIs. Custom Elements are defined in the *HTML Living Standard specification*.\n- **Shadow DOM**. Capable of isolating CSS and JavaScript, almost like an ```<iframe>```. This is defined in the *Living Standard DOM specification*.\n- **HTML templates**. User-defined templates in HTML that aren't rendered until called upon. The ```<template>``` tag is defined in the *HTML Living Standard specification*.\n\nThese are what make up the *Web Components specification*.\n\n> **HTML Modules** is likely to be the fourth technology in the stack, but it has yet to be implemented in any of the big four browsers. The Chrome team has announced it an intent to implement them in a future release.\n\n**Web Components are generally available in all of the major browsers** with the exception of Microsoft Edge and Internet Explorer 11, but polyfills exist to fill in those gaps.\n\nReferring to any of these as Web Components is technically accurate because the term itself is a bit overloaded. As a result, each of the technologies can be used independently or combined with any of the others. In other words, they are not mutually exclusive.\n\n### Custom elements\nAs the name implies, **custom elements are HTML elements,** like ```<div>```, ```<section>``` or ```<article>```, but something **we can name ourselves that are defined via a browser API**. Custom elements are just like those standard HTML elements — names in angle brackets — except **they always have a dash in them**, like ```<news-slider>``` or ```<bacon-cheeseburger>```. Going forward, browser vendors have committed not to create new built-in elements containing a dash in their names to prevent conflicts.\n\nCustom elements contain their own semantics, behaviors, markup and can be shared across frameworks and browsers.\n```\nclass MyComponent extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `<h1>Hello world</h1>`;\n  }\n}\ncustomElements.define('my-component', MyComponent);\n```\n![Custom Elements](https://codersnack.com/assets/images/web-components-custom-elements.png)\n\nIn this example, we define ```<my-component>```, our very own HTML element. Admittedly, it doesn’t do much, however this is the basic building block of a custom element. **All custom elements must in some way extend an HTMLElement in order to be registered with the browser.**\n\n**Custom elements exist without third-party frameworks** and the browser vendors are dedicated to the continued backward compatibility of the spec, all but guaranteeing that components written according to the specifications will not suffer from breaking API changes. What’s more, **these components can generally be used out-of-the-box with today’s most popular frameworks**, including Angular, React, Vue, and others with minimal effort.\n\n### Shadow DOM\n**The shadow DOM is an encapsulated version of the DOM**. This allows authors to effectively isolate DOM fragments from one another, including anything that could be used as a CSS selector and the styles associated with them. Generally, any content inside of the document's scope is referred to as the light DOM, and anything inside a shadow root is referred to as the shadow DOM.\n\nImagine the following scenario:\n```\n<div>\n  <div id=\"example\">\n    <!-- Pseudo-code used to designate a shadow root -->\n    <#shadow-root>\n      <style>\n      button {\n        background: tomato;\n        color: white;\n      }\n      </style>\n      <button id=\"button\">This will use the CSS background tomato</button>\n    </#shadow-root>\n  </div>\n  <button id=\"button\">Not tomato</button>\n</div>\n```\nAside from the pseudo-code of ```<#shadow-root>``` (which is used here to demarcate the shadow boundary which has no HTML element), the HTML is fully valid. To attach a shadow root to the node above, we would run something like:\n\n```\nconst shadowRoot = document.getElementById('example').attachShadow({ mode: 'open' });\nshadowRoot.innerHTML = `<style>\nbutton {\n  color: tomato;\n}\n</style>\n<button id=\"button\">This will use the CSS color tomato <slot></slot></button>`;\n```\nA shadow root can also include content from its containing document by using the ```<slot>``` element. **Using a slot will drop user content from the outer document at a designated spot in your shadow root**.\n\n### HTML templates\nThe aptly-named HTML ```<template>```  element allows us to stamp out **re-usable templates of code inside a normal HTML flow that won't be immediately rendered, but can be used at a later time**.\n\n```\n<template id=\"book-template\">\n  <li><span class=\"title\"></span> &mdash; <span class=\"author\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\nThe example above wouldn’t render any content until a script has consumed the template, instantiated the code and told the browser what to do with it.\n\n```\nconst fragment = document.getElementById('book-template');\nconst books = [\n  { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald' },\n  { title: 'A Farewell to Arms', author: 'Ernest Hemingway' },\n  { title: 'Catch 22', author: 'Joseph Heller' }\n];\n\nbooks.forEach(book => {\n  // Create an instance of the template content\n  const instance = document.importNode(fragment.content, true);\n  // Add relevant content to the template\n  instance.querySelector('.title').innerHTML = book.title;\n  instance.querySelector('.author').innerHTML = book.author;\n  // Append the instance ot the DOM\n  document.getElementById('books').appendChild(instance);\n});\n```\n\nNotice that this example creates a template (```<template id=\"book-template\">```) without any other Web Components technology, illustrating again that **the three technologies in the stack can be used independently or collectively**.\n\nOstensibly, the consumer of a service that utilizes the template API could write a template of any shape or structure that could be created at a later time. Another page on a site might use the same service, but structure the template this way:\n\n```\n<template id=\"book-template\">\n  <li><span class=\"author\"></span>'s classic novel <span class=\"title\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\n","references":"- [CSS trick - Calleb Williams - Introduction to web components](https://css-tricks.com/an-introduction-to-web-components/)\n- [HTML Living Standard specification](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements)\n- [Living Standard DOM specification](https://dom.spec.whatwg.org/#shadow-trees)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-introduction","weblink":"https://codersnack.com/web-components-introduction/","featured_image_preview":{"id":70,"name":"web-components.png","hash":"bb73ea6081f440319172079b80849d32","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bb73ea6081f440319172079b80849d32.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T11:06:52.003Z","updated_at":"2020-02-29T11:06:52.003Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web components introduction","created_at":"2020-02-29T11:07:25.496Z","updated_at":"2020-02-29T11:07:25.500Z"},{"id":58,"codersnack":{"id":59,"header":"LitElement and lit-html Introduction","created_at":"2020-03-30T13:59:50.431Z","updated_at":"2020-03-30T14:04:17.504Z","explanation":"### What is LitElement?\n\n**LitElement** is a **simple base class for creating fast, lightweight web components** that work in any web page with any framework.\n\n**LitElement uses lit-html to render into shadow DOM**, and **adds API to manage properties and attributes**. *Properties are observed by default, and elements update asynchronously when their properties change*.\n\n### Setup\n**You need npm and Node.js** to work with LitElement.\n\n**LitElement uses JavaScript modules to import dependencies** by their npm package names. Since web browsers need to know a file's full URL to import it, your local development server needs to serve full, transformed URL paths to your web browser.\n\n**To deploy an optimized build** that works on your target browsers, you’ll also **need a build toolset** that can handle this transform, along with any bundling.\n\n**One option is Polymer CLI**, which includes a development server that converts module names to paths on the fly; and a configurable build tool that packages your code for deployment.\n\nTo install Polymer CLI with npm:\n```\nnpm install -g polymer-cli\n```\nTo serve a LitElement project locally:\n\n```\npolymer serve\n```\nSee the Polymer CLI documentation for more information on configuring these tools.\n\n\n### Create a LitElement component\nTo create a new class based on LitElement:\n\nIn your project folder, install the lit-element package from npm:\n\n```\nnpm install lit-element\n```\n\nWrite your new element:\n\n- Import the LitElement base class and the html helper function.\n- Create a new class that extends the LitElement base class.\n- Implement render to define a template for your web component.\n- Register your component’s HTML tag with the browser.\n\n*Example*\n\n**my-element.js**\n\n```\n// Import the LitElement base class and html helper function\nimport { LitElement, html } from 'lit-element';\n\n// Extend the LitElement base class\nclass MyElement extends LitElement {\n\n  /**\n   * Implement `render` to define a template for your element.\n   *\n   * You must provide an implementation of `render` for any element\n   * that uses LitElement as a base class.\n   */\n  render(){\n    /**\n     * `render` must return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function:\n     */\n    return html`\n      <!-- template content -->\n      <p>A paragraph</p>\n    `;\n  }\n}\n// Register the new element with the browser.\ncustomElements.define('my-element', MyElement);\n```\n\n### Use LitElement TypeScript decorators\nYou can use the **@customElement TypeScript decorator** to define your class as a custom element:\n\n```\n/**\n * Import LitElement base class, html helper function,\n * and TypeScript decorators\n **/\nimport {\n  LitElement, html, customElement, property\n} from 'lit-element';\n\n/**\n * Use the customElement decorator to define your class as\n * a custom element. Registers <my-element> as an HTML tag.\n */\n@customElement('my-element')\nexport class MyElement extends LitElement {\n\n  /**\n   * Create an observed property. Triggers update on change.\n   */\n  @property()\n  foo = 'foo';\n\n  /**\n   * Implement `render` to define a template for your element.\n   */\n  render(){\n    /**\n     * Use JavaScript expressions to include property values in\n     * the element template.\n     */\n    return html`<p>${this.foo}</p>`;\n  }\n}\n```\n\n### Import a component\nImport your own LitElement component\nIn an HTML document:\n\n```\n<head>\n  <script type=\"module\" src=\"/path/to/my-element.js\"></script>\n</head>\n<body>\n  <my-element></my-element>\n</body>\n```\n\nIn another JavaScript module:\n\n```\n// Use relative paths for peer dependencies\nimport './my-element.js';\n\nclass MyOtherElement extends LitElement{\n  render(){\n    return html`\n      <my-element></my-element>\n    `;\n  }\n}\ncustomElements.define('my-other-element', MyOtherElement);\n```\n### Import a third-party LitElement component\nRefer to third-party component documentation first. To work with any existing component made by a third party, see its documentation. This guide should work for most LitElement-based components if they are published on npm.\n\nMany components are published on npm and can be installed from the command line:\n\n```\ncd my-project-folder\nnpm install package-name\n```\nIn an HTML document, a component published on npm can be imported from the node_modules folder:\n\n```\n<head>\n  <script type=\"module\" src=\"node_modules/package-name/existing-element.js\"></script>\n</head>\n<body>\n  <existing-element></existing-element>\n</body>\n```\nTo import into another JavaScript module, use the component’s package name:\n\n```\nimport 'package-name/existing-element.js';\n\nclass MyElement extends LitElement{\n  render(){\n    return html`\n      <existing-element></existing-element>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### What is lit-html?\nlit-html is a simple, modern, safe, small and fast **HTML templating library for JavaScript.**\n\nlit-html lets you write HTML templates in JavaScript using **template literals with embedded JavaScript expressions**. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.\n\nBuilding components? **lit-html is not tied to any component model**, it focuses only on creating and updating DOM. If you want to build components, check out **LitElement**, a library for building web components using lit-html templates.\n\n### lit-html Templates\nlit-html templates are **tagged template literals** - they look like JavaScript strings but are enclosed in backticks (`) instead of quotes - and tagged with lit-html's html tag:\n\n```\nhtml`<h1>Hello ${name}</h1>`\n```\nSince lit-html templates almost always need to merge in data from JavaScript values, and be able to update DOM when that data changes, they'll most often be written within functions that take some data and return a lit-html template, so that the function can be called multiple times:\n\n```\nlet myTemplate = (data) => html`\n  <h1>${data.title}</h1>\n  <p>${data.body}</p>`;\n```\n**lit-html is lazily rendered**. Calling this function will evaluate the template literal using lit-html html tag, and return a **TemplateResult** - a record of the template to render and data to render it with. TemplateResults are very cheap to produce and no real work actually happens until they are rendered to the DOM.\n\n### Rendering\nTo render a TemplateResult, call the ```render()``` function with a result and DOM container to render to:\n\n```\nconst result = myTemplate({title: 'Hello', body: 'lit-html is cool'});\nrender(result, document.body);\n```\n\n","references":"- [lit-html project](https://lit-html.polymer-project.org/guide)\n- [Example LitElement project](https://github.com/PolymerLabs/start-lit-element)\n- [lit-element project](https://lit-element.polymer-project.org/)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"lit-element-lit-html-introduction","weblink":"https://codersnack.com/lit-element-lit-html-introduction/","featured_image_preview":{"id":77,"name":"web-components.png","hash":"91105265032d4d708a7dd33c29c9a317","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/91105265032d4d708a7dd33c29c9a317.png","provider":"local","provider_metadata":null,"created_at":"2020-03-30T13:59:50.457Z","updated_at":"2020-03-30T13:59:50.457Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - lit-element lit-html introduction","created_at":"2020-03-30T14:00:49.913Z","updated_at":"2020-03-30T14:00:49.919Z"},{"id":59,"codersnack":{"id":60,"header":"LitElement Templates I","created_at":"2020-03-31T08:59:29.566Z","updated_at":"2020-03-31T08:59:29.566Z","explanation":"Add a template to your component to define internal DOM to implement your component.\n\nTo encapsulate the templated DOM LitElement uses **shadow DOM**. Shadow DOM provides three benefits:\n\n- **DOM scoping**. DOM APIs like document.querySelector won’t find elements in the component’s shadow DOM, so it’s harder for global scripts to accidentally break your component.\n- **Style scoping**. You can write encapsulated styles for your shadow DOM that don’t affect the rest of the DOM tree.\n- **Composition**. The component’s shadow DOM (managed by the component) is separate from the component’s children. You can choose how children are rendered in your templated DOM. Component users can add and remove children using standard DOM APIs without accidentally breaking anything in your shadow DOM.\n\nWhere native shadow DOM isn’t available, LitElement uses the **Shady CSS polyfill**.\n\n### Define and render a template\nTo define a template for a LitElement component, write a render function for your element class:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>template content</p>`;\n  }\n}\n```\n\nWrite your template in HTML inside a JavaScript template literal by enclosing the raw HTML in back-ticks (``).\n\n**Tag your template literal with the html tag function**.\n\nThe component’s render method can return anything that lit-html can render. Typically, **it returns a single TemplateResult object** (the same type returned by the html tag function).\n\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n\n  // Implement `render` to define a template for your element.\n  render(){\n    /**\n     * Return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function.\n     */\n    return html`\n      <div>\n        <p>A paragraph</p>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n**LitElement uses lit-html templates**; this page summarizes the features of lit-html templates, for more details, see Writing templates and the Template syntax reference in the lit-html documentation.\n\n### Design a performant template\n**LitElement renders and re-renders asynchronously, updating in response to batched property changes** (see Element update lifecycle for more information).\n\n**During an update, only the parts of the DOM that change are re-rendered**. To get the performance benefits of this model, **you should design your element's template as a pure function of its properties**.\n\nTo do this, make sure the render function:\n\n- Does not change the element’s state.\n- Does not have any side effects.\n- Only depends on the element’s properties.\n- Returns the same result when given the same property values.\n- Also, avoid making DOM updates outside of render. Instead, express the element’s template as a function of its state, and capture its state in properties.\n\nThe following code uses inefficient DOM manipulation:\n\n**dom-manip.js**\n\n```\n// Anti-pattern. Avoid!\n\nconstructor() {\n  super();\n  this.addEventListener('stuff-loaded', (e) => {\n    this.shadowRoot.getElementById('message').innerHTML=e.detail;\n  });\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p id=\"message\">Loading</p>\n  `;\n}\n```\n\nWe can improve the template by capturing the load message as a property, and setting the property in response to the event:\n\n**update-properties.js**\n\n```\nconstructor() {\n  super();\n  this.message = 'Loading';\n  this.addEventListener('stuff-loaded', (e) => { this.message = e.detail } );\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p>${this.message}</p>\n  `;\n}\n```\n\n### Use properties, loops, and conditionals in a template\nWhen defining your element's template, you can **bind the element's properties to the template; the template is re-rendered whenever the properties change.**\n\n##### Properties\nTo add a property value to a template, insert it with ```${this.propName}```:\n\n```\nstatic get properties() {\n  return { myProp: String };\n}\n...\nrender() {\n  return html`<p>${this.myProp}</p>`;\n}\n```\n\n##### Loops\nIterate over an array:\n\n```\nhtml`<ul>\n  ${this.myArray.map(i => html`<li>${i}</li>`)}\n</ul>`;\n```\n##### Conditionals\nRender based on a Boolean condition:\n\n```\nhtml`\n  ${this.myBool?\n    html`<p>Render some HTML if myBool is true</p>`:\n    html`<p>Render some other HTML if myBool is false</p>`}\n`;\n```\n**Examples**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      myString: { type: String },\n      myArray: { type: Array },\n      myBool: { type: Boolean }\n    };\n  }\n  constructor() {\n    super();\n    this.myString = 'Hello World';\n    this.myArray = ['an','array','of','test','data'];\n    this.myBool = true;\n  }\n  render() {\n    return html`\n      <p>${this.myString}</p>\n      <ul>\n        ${this.myArray.map(i => html`<li>${i}</li>`)}\n      </ul>\n      ${this.myBool?\n        html`<p>Render some HTML if myBool is true</p>`:\n        html`<p>Render some other HTML if myBool is false</p>`}\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates","weblink":"https://codersnack.com/webcomponents-litelement-templates/","featured_image_preview":{"id":78,"name":"web-components.png","hash":"b173f34ef15a4e6581f97d99714e591a","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/b173f34ef15a4e6581f97d99714e591a.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T08:59:29.594Z","updated_at":"2020-03-31T08:59:29.594Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates","created_at":"2020-03-31T09:00:01.890Z","updated_at":"2020-03-31T09:00:01.897Z"},{"id":60,"codersnack":{"id":61,"header":"LitElement Templates 2","created_at":"2020-03-31T14:13:31.829Z","updated_at":"2020-03-31T14:13:31.829Z","explanation":"### Bind properties to templated elements\nYou can insert JavaScript expressions as placeholders for HTML text content, attributes, Boolean attributes, properties, and event handlers.\n\n- Text content: ```<p>${...}</p>```\n- Attribute: ```<p id=\"${...}\"></p>```\n- Boolean attribute: ```?disabled=\"${...}\"```\n- Property: ```.value=\"${...}\"```\n- Event handler: ```@event=\"${...}\"```\n\nJavaScript expressions can include your element's properties. **LitElement observes and reacts to property changes, so your templates update automatically**.\n\n**Data bindings are always one-way (parent to child)**. \n> To share data from a child element to its parent, fire an event and capture the relevant data in the detail property**.\n\n#### Bind to text content\nBind prop1 to text content:\n\n```\nhtml`<div>${this.prop1}</div>`\n```\n#### Bind to an attribute\nBind prop2 to an attribute:\n\n```\nhtml`<div id=\"${this.prop2}\"></div>`\n```\nAttribute values are always strings, so an **attribute binding should return a value that can be converted into a string**.\n\n#### Bind to a boolean attribute\nBind prop3 to a boolean attribute:\n\n```\nhtml`<input type=\"text\" ?disabled=\"${this.prop3}\">`\n```\nBoolean attributes are added if the expression evaluates to a truthy value, and removed if it evaluates to a falsy value.\n\n#### Bind to a property\nBind prop4 to a property:\n\n```\nhtml`<input type=\"checkbox\" .value=\"${this.prop4}\"/>`\n```\n\n#### Bind to an event handler\nBind clickHandler to a click event:\n\n```\nhtml`<button @click=\"${this.clickHandler}\">pie?</button>`\n```\nThe default event context for ```@event``` expressions is this, so **there is no need to bind the handler function**.\n\n**Examples**\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: String,\n      prop2: String,\n      prop3: Boolean,\n      prop4: String\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 'text binding';\n    this.prop2 = 'mydiv';\n    this.prop3 = true;\n    this.prop4 = 'pie';\n  }\n  render() {\n    return html`\n      <!-- text binding -->\n      <div>${this.prop1}</div>\n\n      <!-- attribute binding -->\n      <div id=\"${this.prop2}\">attribute binding</div>\n\n      <!-- boolean attribute binding -->\n      <div>\n        boolean attribute binding\n        <input type=\"text\" ?disabled=\"${this.prop3}\"/>\n      </div>\n\n      <!-- property binding -->\n      <div>\n        property binding\n        <input type=\"text\" .value=\"${this.prop4}\"/>\n      </div>\n\n      <!-- event handler binding -->\n      <div>event handler binding\n        <button @click=\"${this.clickHandler}\">click</button>\n      </div>\n    `;\n  }\n  clickHandler(e) {\n    console.log(e.target);\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n\n### Render children with the slot element\nYour component may accept children (like a ```<ul>``` element can have ```<li>``` children).\n\n```\n<my-element>\n  <p>A child</p>\n</my-element>\n```\n\n**By default, if an element has a shadow tree, its children don't render at all. To render children, your template needs to include one or more ```<slot>``` elements, which act as placeholders for child nodes.**\n\n### Use the slot element\nTo render an element's children, create a ```<slot>``` for them in the element's template. For example:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot></slot>\n    </div>\n  `;\n}\n```\nChildren will now render in the ```<slot>```:\n\n```\n<my-element>\n  <p>Render me</p>\n</my-element>\n```\nThe children aren't moved in the DOM tree, but they’re rendered as if they were children of the ```<slot>```.\n\nArbitrarily many children can populate a single slot:\n\n```\n<my-element>\n  <p>Render me</p>\n  <p>Me too</p>\n  <p>Me three</p>\n</my-element>\n```\n\n### Use named slots\nTo assign a child to a specific slot, ensure that the child's slot attribute matches the slot's name attribute:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot name=\"one\"></slot>\n    </div>\n  `;\n}\n```\n**index.html**\n\n```\n<my-element>\n  <p slot=\"one\">Include me in slot \"one\".</p>\n</my-element>\n```\nNamed slots only accept children with a matching slot attribute.\n\nFor example, ```<slot name=\"one\"></slot>``` only accepts children with the attribute ```slot=\"one\"```.\n\nChildren with a slot attribute will only be rendered in a slot with a matching name attribute.\n\nFor example, ```<p slot=\"one\">...</p>``` will only be placed in ```<slot name=\"one\"></slot>```.\n\n**Examples**\n\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render(){\n    return html`\n      <div>\n        <slot name=\"one\"></slot>\n        <slot name=\"two\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*index.html*\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js\"></script>\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js\"></script>\n  \n  <script type=\"module\" src=\"./my-element.js\"></script>\n  <title>lit-element code sample</title>\n</head>\n<body>\n    <!-- Assign child to a specific slot -->\n\n    <my-element>\n      <p slot=\"two\">Include me in slot \"two\".</p>\n    </my-element>\n\n    <!-- \n      Named slots only accept children with a matching `slot` attribute. \n      \n      Children with a `slot` attribute can only go into a slot with a matching name. \n    -->\n\n    <my-element>\n      <p slot=\"one\">Include me in slot \"one\".</p>\n      <p slot=\"nope\">This one will not render at all.</p>\n      <p>No default slot, so this one won't render either.</p>\n    </my-element>\n</body>\n</html>\n```\n\n### Use name, not id, to select slots.\n\nNote that a slot’s id attribute has no effect!\n\n*my-element.js*\n\n```\nrender(){\n  return html`\n    <div>\n      <slot id=\"one\"></slot>\n    </div>\n  `;\n}\n```\n\n*index.html*\n\n```\n<my-element>\n  <p slot=\"one\">nope.</p>\n  <p>ohai..</p>\n</my-element>\n```","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates-2","weblink":"https://codersnack.com/webcomponents-litelement-templates-2/","featured_image_preview":{"id":79,"name":"web-components.png","hash":"c062f6a44328443d8e827c1d23c64994","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/c062f6a44328443d8e827c1d23c64994.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T14:13:31.848Z","updated_at":"2020-03-31T14:13:31.848Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates II","created_at":"2020-03-31T14:13:56.568Z","updated_at":"2020-03-31T14:13:56.572Z"},{"id":61,"codersnack":{"id":62,"header":"LitElement Templates III","created_at":"2020-03-31T14:33:50.941Z","updated_at":"2020-03-31T14:33:50.941Z","explanation":"### Compose a template from other templates\nYou can compose LitElement templates from other LitElement templates. In the following example, we compose a template for an element called ```<my-page>``` from smaller templates for the standard HTML elements ```<header>```, ```<article>```, and ```<footer>```:\n\n```\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      ${this.headerTemplate}\n      ${this.articleTemplate}\n      ${this.footerTemplate}\n    `;\n  }\n  get headerTemplate() {\n    return html`<header>header</header>`;\n  }\n  get articleTemplate() {\n    return html`<article>article</article>`;\n  }\n  get footerTemplate() {\n    return html`<footer>footer</footer>`;\n  }\n}\n```\nYou can also compose templates by importing other elements and using them in your template:\n\n```\nimport './my-header.js';\nimport './my-article.js';\nimport './my-footer.js';\n\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      <my-header></my-header>\n      <my-article></my-article>\n      <my-footer></my-footer>\n    `;\n  }\n}\n```\n\n### Specify the render root\n**The node into which your component's template will render is called its render root**.\n\n**By default, LitElement creates an open shadowRoot and renders inside it,** producing the following DOM structure:\n\n```\n<my-element>\n  #shadow-root\n    <p>child 1</p>\n    <p>child 2</p>\n```\n\nTo customize a component's render root, implement **createRenderRoot** and return the node you want the template to render into.\n\nFor example, to render the template into the main DOM tree as your element's children:\n\n```\n<my-element>\n  <p>child 1</p>\n  <p>child 2</p>\n```\nImplement createRenderRoot and return this:\n\n```\nclass LightDom extends LitElement {\n  render() {\n    return html`\n      <p>This template renders without shadow DOM.</p>\n    `;\n  }\n  createRenderRoot() {\n  /**\n   * Render template without shadow DOM. Note that shadow DOM features like \n   * encapsulated CSS and slots are unavailable.\n   */\n    return this;\n  }\n}\n```\n\n### Using other lit-html features\nSince **LitElement uses the lit-html html tag function to define templates** you can take advantage of the entire lit-html feature set for writing your templates. This includes lit-html directives, special functions that customize the way lit-html renders a binding.\n\n**To import features directly from lit-html, your project should add lit-html as a direct dependency**. We recommend using the widest practical version range for lit-html, to minimize the chance of npm installing two different versions of lit-html:\n\n```\nnpm i lit-element@^2.0.0\nnpm i lit-html@^1.0.0\n```\n#### Import and use a lit-html directive\nYou can import and use a lit-html directive and use it as shown in the lit-html documentation.\n\n```\nimport { LitElement, html } from 'lit-element';\nimport { until } from 'lit-html/directives/until.js';\n\nconst content = fetch('./content.txt').then(r => r.text());\n\nhtml`${until(content, html`<span>Loading...</span>`)}`\n```\nFor a list of directives supplied with lit-html, see Built-in directives in the Template syntax reference.\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates-3","weblink":"https://codersnack.com/webcomponents-litelement-templates-3/","featured_image_preview":{"id":80,"name":"web-components.png","hash":"5ac875bf0ff14b0ea77a14c4b6d826ce","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/5ac875bf0ff14b0ea77a14c4b6d826ce.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T14:33:50.955Z","updated_at":"2020-03-31T14:33:50.955Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component LitElement Templates 3","created_at":"2020-03-31T14:34:33.187Z","updated_at":"2020-03-31T14:34:33.191Z"},{"id":62,"codersnack":{"id":63,"header":"LitElement Properties 1","created_at":"2020-03-31T15:08:19.241Z","updated_at":"2020-03-31T15:08:19.241Z","explanation":"### Overview\n**LitElement manages your declared properties and their corresponding attributes**. By default, LitElement will:\n\n- Ensure that an **element update is scheduled when any declared property changes**.\n- Capture instance values for declared properties. Apply any property values that are set before the browser registers a custom element definition.\n- **Set up an observed (not reflected) attribute** with the lowercased name of each property.\n- **Handle attribute conversion** for properties declared as type String, Number, Boolean, Array, and Object.\n- Use **direct comparison (oldValue !== newValue) to test for property changes**.\n- Apply any property options and accessors declared by a superclass.\n\n> Remember to declare all of the properties that you want LitElement to manage. For the property features above to be applied, you must declare the property.\n\n### Property options\nA property declaration is an object in the following format:\n```\n{ optionName1: optionValue1, optionName2: optionValue2, ... }\n```\n\nThe following options are available:\n\n- **converter**: Convert between properties and attributes.\n- **type**: Use LitElement’s default attribute converter.\n- **attribute**: Configure **observed** attributes.\n- **reflect**: Configure **reflected** attributes.\n- **noAccessor**: Whether to set up a default property accessor.\n- **hasChanged**: Specify what constitutes a property change.\n\n> All property declaration options can be specified in a static properties getter, or with TypeScript decorators.\n\n### Declare properties\nDeclare your element’s properties by implementing a static properties getter, or by using decorators:\n\n```\n// properties getter\nstatic get properties() {\n  return { \n    prop1: { type: String }\n  };\n}\n// Decorators (requires TypeScript or Babel)\nexport class MyElement extends LitElement {\n  @property( { type : String }  ) prop1 = '';\n```\n\n#### Declare properties in a static properties getter\nTo declare properties in a static properties getter:\n\n```\nstatic get properties() { \n  return { \n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean }\n  };\n}\n```\n\nIf you implement a static properties getter, initialize your property values in the element constructor.\n\n```\nconstructor() {\n  // Always call super() first\n  super();\n  this.prop1 = 'Hello World';\n  ...\n}\n```\n> Remember to call ```super()``` first in your constructor, or your element won’t render at all.\n\n**Example**: Declare properties with a static properties getter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = false;\n    this.prop4 = [1,2,3];\n    this.prop5 = { subprop1: 'prop 5 subprop1 value' }\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Declare properties with decorators\nYou can also declare properties with **decorators**:\n\n```\n@property({type : String})  prop1 = 'Hello World';\n```\n> Decorators are a proposed JavaScript feature, so you’ll need to use a transpiler like Babel or the TypeScript compiler to use decorators.\n\nIf you’re using Babel, you’ll need to use the ```@babel/plugin-proposal-decorators```  plugin.\n\nIf you’re using TypeScript, you’ll need to **enable the experimentalDecorators compiler option** (for example, by setting \"experimentalDecorators\": true in *tsconfig.json*). Enabling emitDecoratorMetadata is not required and not recommended.\n\n**Example**: Declare properties with decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'prop 5 subprop1 value' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n```\n\n#### Initialize property values\nInitialize property values in the element constructor\nIf you implement a static properties getter, initialize your property values in the element constructor:\n\n```\nstatic get properties() { return { /* Property declarations */ }; } \n\nconstructor() {\n  // Always call super() first\n  super();\n\n  // Initialize properties \n  this.prop1 = 'Hello World';\n}\n```\n> Remember to call super() first in your constructor, or your element won’t render at all.\n\n**Example**: Initialize property values in the element constructor\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = true;\n    this.prop4 = [1,2,3];\n    this.prop5 = { stuff: 'hi', otherStuff: 'wow' };\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### Initialize property values when using TypeScript decorators\nTypeScript users can initialize property values when they are declared with the @property decorator:\n\n```\n@property({ type : String }) prop1 = 'Hello World';\n```\n**Example**: Initialize property values when using TypeScript decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  // Declare and initialize properties\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'hi', thing: 'fasdfsf' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\n```\n\n#### Initialize property values from attributes in markup\nYou can also initialize property values from observed attributes in markup:\n\n*index.html*\n\n```\n<my-element \n  mystring=\"hello world\"\n  mynumber=\"5\"\n  mybool\n  myobj='{\"stuff\":\"hi\"}'\n  myarray='[1,2,3,4]'></my-element>\n```\n\nSee observed attributes and converting between properties and attributes for more information on setting up initialization from attributes.","references":"- [LitElement properties](https://lit-element.polymer-project.org/guide/properties)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-properties-1","weblink":"https://codersnack.com/webcomponents-litelement-properties-1/","featured_image_preview":{"id":81,"name":"web-components.png","hash":"bab685844ed0414b97905d1d9b06a0c8","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bab685844ed0414b97905d1d9b06a0c8.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T15:08:19.259Z","updated_at":"2020-03-31T15:08:19.259Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Properties 1","created_at":"2020-03-31T15:09:10.363Z","updated_at":"2020-03-31T15:09:10.368Z"},{"id":63,"codersnack":{"id":64,"header":"LitElement Properties 2","created_at":"2020-03-31T15:56:12.994Z","updated_at":"2020-03-31T15:56:12.994Z","explanation":"### Properties vs Attributes\nThe difference between properties and attributes can be confusing. **Properties are available on a DOM node** when being manipulated by JavaScript:\n\n```\nconst myElem = document.querySelector('.my-elem');\nmyElem.className; // className is a property\n```\nAnd **attributes are provided in the HTML itself**. Here alt, width and height are all attributes:\n```\n<img src=\"/path/to/img.svg\" alt=\"My Image\" width=\"150\" height=\"250\">\n```\n**Attributes should only be used for scalar values like strings, numbers and boolean values**. **Properties, on the other hand, are perfectly suited to also hold values that are objects or arrays**.\n\n### Reflecting Properties to Attributes\n**Most properties reflect their values as attributes, meaning that if the property is changed using JavaScript, the corresponding attribute is also changed at the same time to reflect the new value**. This is useful for accessibility and to allow CSS selectors to work as intended.\n\nYou can try it out yourself for a concrete example. Just select, say, an image element in your browser’s developer tools, and then change one of its properties:\n\n```\nconst fancyImage = document.querySelector('.fancy-image');\n\nfancyImage.width = 777;\n```\nNotice how the with attribute in the DOM representation is automatically changed to the new value. The same is true if you change the value for the attribute manually in the DOM inspector, you’ll see that the property will now hold the new value.\n\n![attributes-properties](https://codersnack.com/assets/images/attributes-properties.png)\n\n### Reflecting properties to attributes in Custom Elements\nYour own Custom Elements should also follow this practice of reflecting properties to attributes. Luckily, it's quite easy to do using getters and setters.\n\nFor example, if you have a custom element that has a value property that should be reflected as an attribute, here’s how you would use a getter and a setter to get the value of the attribute when doing property access and setting the new value for the attribute when the property is changed:\n\n```\nget value() {\n  return this.getAttribute('value');\n}\n\nset value(newValue) {\n  this.setAttribute('value', newValue);\n}\n```\nOr, if you have a boolean property, like, say hidden:\n\n```\nget hidden() {\n  return this.hasAttribute('hidden');\n}\n\nset hidden(isHidden) {\n  if (isHidden) {\n    this.setAttribute('hidden', '');\n  } else {\n    this.removeAttribute('hidden');\n  }\n}\n```\n\n### Configure attributes\n\n#### Convert between properties and attributes\n\n**While element properties can be of any type, attributes are always strings**. This impacts the observed attributes and reflected attributes of non-string properties:\n\nTo observe an attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type.\n\nTo reflect an attribute (set an attribute from a property), the property value must be converted to a string.\n\n#### Use the default converter\nLitElement has a default converter which handles String, Number, Boolean, Array, and Object property types.\n\n**To use the default converter, specify the type option in your property declaration**:\n```\n// Use LitElement's default converter \nprop1: { type: String },\nprop2: { type: Number },\nprop3: { type: Boolean },\nprop4: { type: Array },\nprop5: { type: Object }\n```\nThe information below shows how the default converter handles conversion for each type.\n\n#### Convert from attribute to property\n\n- For Strings, when the attribute is defined, set the property to the attribute value.\n- For Numbers, when the attribute is defined, set the property to Number(attributeValue).\n- For Booleans, when the attribute is:\n     non-null, set the property to true.\n     null or undefined, set the property to false.\n- For Objects and Arrays, when the attribute is:\n     Defined, set the property value to JSON.parse(attributeValue).\n\n#### Convert from property to attribute\n\n- For Strings, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Numbers, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Booleans, when the property is:\n    truthy, create the attribute.\n    falsy, remove the attribute.\n- For Objects and Arrays, when the property is:\n    null or undefined, remove the attribute.\n    Defined and not null, set the attribute value to JSON.stringify(propertyValue).\n\n**Example**: Use the default converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String, reflect: true },\n    prop2: { type: Number, reflect: true },\n    prop3: { type: Boolean, reflect: true },\n    prop4: { type: Array, reflect: true },\n    prop5: { type: Object, reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = '';\n    this.prop2 = 0;\n    this.prop3 = false;\n    this.prop4 = [];\n    this.prop5 = { };\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    console.log('attribute change: ', name, newVal);\n    super.attributeChangedCallback(name, oldVal, newVal);\n  }\n\n  render() {\n    return html`\n      <p>prop1 ${this.prop1}</p>\n      <p>prop2 ${this.prop2}</p>\n      <p>prop3 ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.getAttribute('prop3');\n\n    this.setAttribute('prop1', randy.toString());\n    this.setAttribute('prop2', randy.toString());\n    this.setAttribute('prop3', myBool? '' : null);\n    this.setAttribute('prop4', JSON.stringify([...this.prop4, randy]));\n    this.setAttribute('prop5',\n      JSON.stringify(Object.assign({}, this.prop5, {[randy]: randy})));\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.prop3;\n\n    this.prop1 = randy.toString();\n    this.prop2 = randy;\n    this.prop3 = !myBool;\n    this.prop4 = [...this.prop4, randy];\n    this.prop5 = Object.assign({}, this.prop5, {[randy]: randy});\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Configure a custom converter\nYou can specify a custom property converter in your property declaration with the converter option:\n\n```\nmyProp: { \n  converter: // Custom property converter\n} \n```\nconverter can be an object or a function. If it is an object, it can have keys for fromAttribute and toAttribute:\n\n```\nprop1: { \n  converter: { \n    fromAttribute: (value, type) => { \n      // `value` is a string\n      // Convert it to a value of type `type` and return it\n    },\n    toAttribute: (value, type) => { \n      // `value` is of type `type` \n      // Convert it to a string and return it\n    }\n  }\n}\n```\nIf converter is a function, it is used in place of fromAttribute:\n\n```\nmyProp: { \n  converter: (value, type) => { \n    // `value` is a string\n    // Convert it to a value of type `type` and return it\n  }\n} \n```\nIf no **toAttribute** function is supplied for a reflected attribute, the attribute is set to the property value without conversion.\n\nDuring an update:\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n**Example**: Configure a custom converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: {\n      reflect: true,\n      converter: {\n        toAttribute(value) {\n          console.log('myProp\\'s toAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = String(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        },\n\n        fromAttribute(value) {\n          console.log('myProp\\'s fromAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = Number(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        }\n      }\n    },\n\n    theProp: {\n      reflect: true,\n      converter(value) {\n        console.log('theProp\\'s converter.');\n        console.log('Processing:', value, typeof(value));\n\n        let retVal = Number(value);\n        console.log('Returning:', retVal, typeof(retVal));\n        return retVal;\n      }},\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    // console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n    this.theProp='theProp ' + randomString;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure observed attributes\nAn **observed attribute fires** the custom elements API callback **attributeChangedCallback** whenever it changes. By default, whenever an attribute fires this callback, LitElement sets the property value from the attribute using the property's fromAttribute function. See Convert between properties and attributes for more information.\n\n**By default, LitElement creates a corresponding observed attribute for all declared properties**. The name of the observed attribute is the property name, lowercased:\n\n```\n// observed attribute name is \"myprop\"\nmyProp: { type: Number }\n```\nTo create an observed attribute with a different name, set attribute to a string:\n\n```\n// Observed attribute will be called my-prop\nmyProp: { attribute: 'my-prop' }\n```\n\n**To prevent an observed attribute from being created for a property**, set attribute to false. The property will not be initialized from attributes in markup, and attribute changes won’t affect it.\n\n```\n// No observed attribute for this property\nmyProp: { attribute: false }\n```\n\n**An observed attribute can be used to provide an initial value for a property via markup**. See Initialize properties with attributes in markup.\n\n**Example**: Configure observed attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { attribute: true },\n    theProp: { attribute: false },\n    otherProp: { attribute: 'other-prop' },\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n    this.otherProp = 'otherProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n      <p>otherProp ${this.otherProp}</p>\n\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.setAttribute('other-prop', 'other-prop ' + randomString);\n    this.requestUpdate();\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n  ","references":"- [LitElement Properties](https://lit-element.polymer-project.org/guide/properties)\n- [Alligator.io attributes-properties](https://alligator.io/web-components/attributes-properties/)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-properties-1","weblink":"https://codersnack.com/webcomponents-litelement-properties-1/","featured_image_preview":{"id":82,"name":"web-components.png","hash":"6fbc67b16bfb49d8a1ff9394e314e102","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/6fbc67b16bfb49d8a1ff9394e314e102.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T15:56:13.010Z","updated_at":"2020-03-31T15:56:13.010Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Properties 2","created_at":"2020-03-31T15:56:38.406Z","updated_at":"2020-03-31T15:56:38.410Z"}]