[{"id":53,"codersnack":{"id":54,"header":"Introduction to Web Components","created_at":"2020-02-29T11:06:51.993Z","updated_at":"2020-02-29T21:31:43.928Z","explanation":"### What are Web Components, anyway?\n\nWeb Components consist of **three separate technologies that are used together:**\n\n- **Custom Elements**. Quite simply, these are fully-valid HTML elements with custom templates, behaviors and tag names (e.g. ```<one-dialog>```) made with a set of JavaScript APIs. Custom Elements are defined in the *HTML Living Standard specification*.\n- **Shadow DOM**. Capable of isolating CSS and JavaScript, almost like an ```<iframe>```. This is defined in the *Living Standard DOM specification*.\n- **HTML templates**. User-defined templates in HTML that aren't rendered until called upon. The ```<template>``` tag is defined in the *HTML Living Standard specification*.\n\nThese are what make up the *Web Components specification*.\n\n> **HTML Modules** is likely to be the fourth technology in the stack, but it has yet to be implemented in any of the big four browsers. The Chrome team has announced it an intent to implement them in a future release.\n\n**Web Components are generally available in all of the major browsers** with the exception of Microsoft Edge and Internet Explorer 11, but polyfills exist to fill in those gaps.\n\nReferring to any of these as Web Components is technically accurate because the term itself is a bit overloaded. As a result, each of the technologies can be used independently or combined with any of the others. In other words, they are not mutually exclusive.\n\n### Custom elements\nAs the name implies, **custom elements are HTML elements,** like ```<div>```, ```<section>``` or ```<article>```, but something **we can name ourselves that are defined via a browser API**. Custom elements are just like those standard HTML elements — names in angle brackets — except **they always have a dash in them**, like ```<news-slider>``` or ```<bacon-cheeseburger>```. Going forward, browser vendors have committed not to create new built-in elements containing a dash in their names to prevent conflicts.\n\nCustom elements contain their own semantics, behaviors, markup and can be shared across frameworks and browsers.\n```\nclass MyComponent extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `<h1>Hello world</h1>`;\n  }\n}\ncustomElements.define('my-component', MyComponent);\n```\n![Custom Elements](https://codersnack.com/assets/images/web-components-custom-elements.png)\n\nIn this example, we define ```<my-component>```, our very own HTML element. Admittedly, it doesn’t do much, however this is the basic building block of a custom element. **All custom elements must in some way extend an HTMLElement in order to be registered with the browser.**\n\n**Custom elements exist without third-party frameworks** and the browser vendors are dedicated to the continued backward compatibility of the spec, all but guaranteeing that components written according to the specifications will not suffer from breaking API changes. What’s more, **these components can generally be used out-of-the-box with today’s most popular frameworks**, including Angular, React, Vue, and others with minimal effort.\n\n### Shadow DOM\n**The shadow DOM is an encapsulated version of the DOM**. This allows authors to effectively isolate DOM fragments from one another, including anything that could be used as a CSS selector and the styles associated with them. Generally, any content inside of the document's scope is referred to as the light DOM, and anything inside a shadow root is referred to as the shadow DOM.\n\nImagine the following scenario:\n```\n<div>\n  <div id=\"example\">\n    <!-- Pseudo-code used to designate a shadow root -->\n    <#shadow-root>\n      <style>\n      button {\n        background: tomato;\n        color: white;\n      }\n      </style>\n      <button id=\"button\">This will use the CSS background tomato</button>\n    </#shadow-root>\n  </div>\n  <button id=\"button\">Not tomato</button>\n</div>\n```\nAside from the pseudo-code of ```<#shadow-root>``` (which is used here to demarcate the shadow boundary which has no HTML element), the HTML is fully valid. To attach a shadow root to the node above, we would run something like:\n\n```\nconst shadowRoot = document.getElementById('example').attachShadow({ mode: 'open' });\nshadowRoot.innerHTML = `<style>\nbutton {\n  color: tomato;\n}\n</style>\n<button id=\"button\">This will use the CSS color tomato <slot></slot></button>`;\n```\nA shadow root can also include content from its containing document by using the ```<slot>``` element. **Using a slot will drop user content from the outer document at a designated spot in your shadow root**.\n\n### HTML templates\nThe aptly-named HTML ```<template>```  element allows us to stamp out **re-usable templates of code inside a normal HTML flow that won't be immediately rendered, but can be used at a later time**.\n\n```\n<template id=\"book-template\">\n  <li><span class=\"title\"></span> &mdash; <span class=\"author\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\nThe example above wouldn’t render any content until a script has consumed the template, instantiated the code and told the browser what to do with it.\n\n```\nconst fragment = document.getElementById('book-template');\nconst books = [\n  { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald' },\n  { title: 'A Farewell to Arms', author: 'Ernest Hemingway' },\n  { title: 'Catch 22', author: 'Joseph Heller' }\n];\n\nbooks.forEach(book => {\n  // Create an instance of the template content\n  const instance = document.importNode(fragment.content, true);\n  // Add relevant content to the template\n  instance.querySelector('.title').innerHTML = book.title;\n  instance.querySelector('.author').innerHTML = book.author;\n  // Append the instance ot the DOM\n  document.getElementById('books').appendChild(instance);\n});\n```\n\nNotice that this example creates a template (```<template id=\"book-template\">```) without any other Web Components technology, illustrating again that **the three technologies in the stack can be used independently or collectively**.\n\nOstensibly, the consumer of a service that utilizes the template API could write a template of any shape or structure that could be created at a later time. Another page on a site might use the same service, but structure the template this way:\n\n```\n<template id=\"book-template\">\n  <li><span class=\"author\"></span>'s classic novel <span class=\"title\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\n","references":"- [CSS trick - Calleb Williams - Introduction to web components](https://css-tricks.com/an-introduction-to-web-components/)\n- [HTML Living Standard specification](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements)\n- [Living Standard DOM specification](https://dom.spec.whatwg.org/#shadow-trees)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-introduction","weblink":"https://codersnack.com/web-components-introduction/","featured_image_preview":{"id":70,"name":"web-components.png","hash":"bb73ea6081f440319172079b80849d32","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bb73ea6081f440319172079b80849d32.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T11:06:52.003Z","updated_at":"2020-02-29T11:06:52.003Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web components introduction","created_at":"2020-02-29T11:07:25.496Z","updated_at":"2020-02-29T11:07:25.500Z"},{"id":58,"codersnack":{"id":59,"header":"LitElement and lit-html Introduction","created_at":"2020-03-30T13:59:50.431Z","updated_at":"2020-03-30T14:04:17.504Z","explanation":"### What is LitElement?\n\n**LitElement** is a **simple base class for creating fast, lightweight web components** that work in any web page with any framework.\n\n**LitElement uses lit-html to render into shadow DOM**, and **adds API to manage properties and attributes**. *Properties are observed by default, and elements update asynchronously when their properties change*.\n\n### Setup\n**You need npm and Node.js** to work with LitElement.\n\n**LitElement uses JavaScript modules to import dependencies** by their npm package names. Since web browsers need to know a file's full URL to import it, your local development server needs to serve full, transformed URL paths to your web browser.\n\n**To deploy an optimized build** that works on your target browsers, you’ll also **need a build toolset** that can handle this transform, along with any bundling.\n\n**One option is Polymer CLI**, which includes a development server that converts module names to paths on the fly; and a configurable build tool that packages your code for deployment.\n\nTo install Polymer CLI with npm:\n```\nnpm install -g polymer-cli\n```\nTo serve a LitElement project locally:\n\n```\npolymer serve\n```\nSee the Polymer CLI documentation for more information on configuring these tools.\n\n\n### Create a LitElement component\nTo create a new class based on LitElement:\n\nIn your project folder, install the lit-element package from npm:\n\n```\nnpm install lit-element\n```\n\nWrite your new element:\n\n- Import the LitElement base class and the html helper function.\n- Create a new class that extends the LitElement base class.\n- Implement render to define a template for your web component.\n- Register your component’s HTML tag with the browser.\n\n*Example*\n\n**my-element.js**\n\n```\n// Import the LitElement base class and html helper function\nimport { LitElement, html } from 'lit-element';\n\n// Extend the LitElement base class\nclass MyElement extends LitElement {\n\n  /**\n   * Implement `render` to define a template for your element.\n   *\n   * You must provide an implementation of `render` for any element\n   * that uses LitElement as a base class.\n   */\n  render(){\n    /**\n     * `render` must return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function:\n     */\n    return html`\n      <!-- template content -->\n      <p>A paragraph</p>\n    `;\n  }\n}\n// Register the new element with the browser.\ncustomElements.define('my-element', MyElement);\n```\n\n### Use LitElement TypeScript decorators\nYou can use the **@customElement TypeScript decorator** to define your class as a custom element:\n\n```\n/**\n * Import LitElement base class, html helper function,\n * and TypeScript decorators\n **/\nimport {\n  LitElement, html, customElement, property\n} from 'lit-element';\n\n/**\n * Use the customElement decorator to define your class as\n * a custom element. Registers <my-element> as an HTML tag.\n */\n@customElement('my-element')\nexport class MyElement extends LitElement {\n\n  /**\n   * Create an observed property. Triggers update on change.\n   */\n  @property()\n  foo = 'foo';\n\n  /**\n   * Implement `render` to define a template for your element.\n   */\n  render(){\n    /**\n     * Use JavaScript expressions to include property values in\n     * the element template.\n     */\n    return html`<p>${this.foo}</p>`;\n  }\n}\n```\n\n### Import a component\nImport your own LitElement component\nIn an HTML document:\n\n```\n<head>\n  <script type=\"module\" src=\"/path/to/my-element.js\"></script>\n</head>\n<body>\n  <my-element></my-element>\n</body>\n```\n\nIn another JavaScript module:\n\n```\n// Use relative paths for peer dependencies\nimport './my-element.js';\n\nclass MyOtherElement extends LitElement{\n  render(){\n    return html`\n      <my-element></my-element>\n    `;\n  }\n}\ncustomElements.define('my-other-element', MyOtherElement);\n```\n### Import a third-party LitElement component\nRefer to third-party component documentation first. To work with any existing component made by a third party, see its documentation. This guide should work for most LitElement-based components if they are published on npm.\n\nMany components are published on npm and can be installed from the command line:\n\n```\ncd my-project-folder\nnpm install package-name\n```\nIn an HTML document, a component published on npm can be imported from the node_modules folder:\n\n```\n<head>\n  <script type=\"module\" src=\"node_modules/package-name/existing-element.js\"></script>\n</head>\n<body>\n  <existing-element></existing-element>\n</body>\n```\nTo import into another JavaScript module, use the component’s package name:\n\n```\nimport 'package-name/existing-element.js';\n\nclass MyElement extends LitElement{\n  render(){\n    return html`\n      <existing-element></existing-element>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### What is lit-html?\nlit-html is a simple, modern, safe, small and fast **HTML templating library for JavaScript.**\n\nlit-html lets you write HTML templates in JavaScript using **template literals with embedded JavaScript expressions**. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.\n\nBuilding components? **lit-html is not tied to any component model**, it focuses only on creating and updating DOM. If you want to build components, check out **LitElement**, a library for building web components using lit-html templates.\n\n### lit-html Templates\nlit-html templates are **tagged template literals** - they look like JavaScript strings but are enclosed in backticks (`) instead of quotes - and tagged with lit-html's html tag:\n\n```\nhtml`<h1>Hello ${name}</h1>`\n```\nSince lit-html templates almost always need to merge in data from JavaScript values, and be able to update DOM when that data changes, they'll most often be written within functions that take some data and return a lit-html template, so that the function can be called multiple times:\n\n```\nlet myTemplate = (data) => html`\n  <h1>${data.title}</h1>\n  <p>${data.body}</p>`;\n```\n**lit-html is lazily rendered**. Calling this function will evaluate the template literal using lit-html html tag, and return a **TemplateResult** - a record of the template to render and data to render it with. TemplateResults are very cheap to produce and no real work actually happens until they are rendered to the DOM.\n\n### Rendering\nTo render a TemplateResult, call the ```render()``` function with a result and DOM container to render to:\n\n```\nconst result = myTemplate({title: 'Hello', body: 'lit-html is cool'});\nrender(result, document.body);\n```\n\n","references":"- [lit-html project](https://lit-html.polymer-project.org/guide)\n- [Example LitElement project](https://github.com/PolymerLabs/start-lit-element)\n- [lit-element project](https://lit-element.polymer-project.org/)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"lit-element-lit-html-introduction","weblink":"https://codersnack.com/lit-element-lit-html-introduction/","featured_image_preview":{"id":77,"name":"web-components.png","hash":"91105265032d4d708a7dd33c29c9a317","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/91105265032d4d708a7dd33c29c9a317.png","provider":"local","provider_metadata":null,"created_at":"2020-03-30T13:59:50.457Z","updated_at":"2020-03-30T13:59:50.457Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - lit-element lit-html introduction","created_at":"2020-03-30T14:00:49.913Z","updated_at":"2020-03-30T14:00:49.919Z"},{"id":59,"codersnack":{"id":60,"header":"LitElement Templates 1","created_at":"2020-03-31T08:59:29.566Z","updated_at":"2020-03-31T18:19:00.931Z","explanation":"Add a template to your component to define internal DOM to implement your component.\n\nTo encapsulate the templated DOM LitElement uses **shadow DOM**. Shadow DOM provides three benefits:\n\n- **DOM scoping**. DOM APIs like document.querySelector won’t find elements in the component’s shadow DOM, so it’s harder for global scripts to accidentally break your component.\n- **Style scoping**. You can write encapsulated styles for your shadow DOM that don’t affect the rest of the DOM tree.\n- **Composition**. The component’s shadow DOM (managed by the component) is separate from the component’s children. You can choose how children are rendered in your templated DOM. Component users can add and remove children using standard DOM APIs without accidentally breaking anything in your shadow DOM.\n\nWhere native shadow DOM isn’t available, LitElement uses the **Shady CSS polyfill**.\n\n### Define and render a template\nTo define a template for a LitElement component, write a render function for your element class:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>template content</p>`;\n  }\n}\n```\n\nWrite your template in HTML inside a JavaScript template literal by enclosing the raw HTML in back-ticks (``).\n\n**Tag your template literal with the html tag function**.\n\nThe component’s render method can return anything that lit-html can render. Typically, **it returns a single TemplateResult object** (the same type returned by the html tag function).\n\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n\n  // Implement `render` to define a template for your element.\n  render(){\n    /**\n     * Return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function.\n     */\n    return html`\n      <div>\n        <p>A paragraph</p>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n**LitElement uses lit-html templates**; this page summarizes the features of lit-html templates, for more details, see Writing templates and the Template syntax reference in the lit-html documentation.\n\n### Design a performant template\n**LitElement renders and re-renders asynchronously, updating in response to batched property changes** (see Element update lifecycle for more information).\n\n**During an update, only the parts of the DOM that change are re-rendered**. To get the performance benefits of this model, **you should design your element's template as a pure function of its properties**.\n\nTo do this, make sure the render function:\n\n- Does not change the element’s state.\n- Does not have any side effects.\n- Only depends on the element’s properties.\n- Returns the same result when given the same property values.\n- Also, avoid making DOM updates outside of render. Instead, express the element’s template as a function of its state, and capture its state in properties.\n\nThe following code uses inefficient DOM manipulation:\n\n**dom-manip.js**\n\n```\n// Anti-pattern. Avoid!\n\nconstructor() {\n  super();\n  this.addEventListener('stuff-loaded', (e) => {\n    this.shadowRoot.getElementById('message').innerHTML=e.detail;\n  });\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p id=\"message\">Loading</p>\n  `;\n}\n```\n\nWe can improve the template by capturing the load message as a property, and setting the property in response to the event:\n\n**update-properties.js**\n\n```\nconstructor() {\n  super();\n  this.message = 'Loading';\n  this.addEventListener('stuff-loaded', (e) => { this.message = e.detail } );\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p>${this.message}</p>\n  `;\n}\n```\n\n### Use properties, loops, and conditionals in a template\nWhen defining your element's template, you can **bind the element's properties to the template; the template is re-rendered whenever the properties change.**\n\n##### Properties\nTo add a property value to a template, insert it with ```${this.propName}```:\n\n```\nstatic get properties() {\n  return { myProp: String };\n}\n...\nrender() {\n  return html`<p>${this.myProp}</p>`;\n}\n```\n\n##### Loops\nIterate over an array:\n\n```\nhtml`<ul>\n  ${this.myArray.map(i => html`<li>${i}</li>`)}\n</ul>`;\n```\n##### Conditionals\nRender based on a Boolean condition:\n\n```\nhtml`\n  ${this.myBool?\n    html`<p>Render some HTML if myBool is true</p>`:\n    html`<p>Render some other HTML if myBool is false</p>`}\n`;\n```\n**Examples**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      myString: { type: String },\n      myArray: { type: Array },\n      myBool: { type: Boolean }\n    };\n  }\n  constructor() {\n    super();\n    this.myString = 'Hello World';\n    this.myArray = ['an','array','of','test','data'];\n    this.myBool = true;\n  }\n  render() {\n    return html`\n      <p>${this.myString}</p>\n      <ul>\n        ${this.myArray.map(i => html`<li>${i}</li>`)}\n      </ul>\n      ${this.myBool?\n        html`<p>Render some HTML if myBool is true</p>`:\n        html`<p>Render some other HTML if myBool is false</p>`}\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates","weblink":"https://codersnack.com/webcomponents-litelement-templates/","featured_image_preview":{"id":78,"name":"web-components.png","hash":"b173f34ef15a4e6581f97d99714e591a","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/b173f34ef15a4e6581f97d99714e591a.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T08:59:29.594Z","updated_at":"2020-03-31T08:59:29.594Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates","created_at":"2020-03-31T09:00:01.890Z","updated_at":"2020-03-31T09:00:01.897Z"},{"id":60,"codersnack":{"id":61,"header":"LitElement Templates 2","created_at":"2020-03-31T14:13:31.829Z","updated_at":"2020-03-31T14:13:31.829Z","explanation":"### Bind properties to templated elements\nYou can insert JavaScript expressions as placeholders for HTML text content, attributes, Boolean attributes, properties, and event handlers.\n\n- Text content: ```<p>${...}</p>```\n- Attribute: ```<p id=\"${...}\"></p>```\n- Boolean attribute: ```?disabled=\"${...}\"```\n- Property: ```.value=\"${...}\"```\n- Event handler: ```@event=\"${...}\"```\n\nJavaScript expressions can include your element's properties. **LitElement observes and reacts to property changes, so your templates update automatically**.\n\n**Data bindings are always one-way (parent to child)**. \n> To share data from a child element to its parent, fire an event and capture the relevant data in the detail property**.\n\n#### Bind to text content\nBind prop1 to text content:\n\n```\nhtml`<div>${this.prop1}</div>`\n```\n#### Bind to an attribute\nBind prop2 to an attribute:\n\n```\nhtml`<div id=\"${this.prop2}\"></div>`\n```\nAttribute values are always strings, so an **attribute binding should return a value that can be converted into a string**.\n\n#### Bind to a boolean attribute\nBind prop3 to a boolean attribute:\n\n```\nhtml`<input type=\"text\" ?disabled=\"${this.prop3}\">`\n```\nBoolean attributes are added if the expression evaluates to a truthy value, and removed if it evaluates to a falsy value.\n\n#### Bind to a property\nBind prop4 to a property:\n\n```\nhtml`<input type=\"checkbox\" .value=\"${this.prop4}\"/>`\n```\n\n#### Bind to an event handler\nBind clickHandler to a click event:\n\n```\nhtml`<button @click=\"${this.clickHandler}\">pie?</button>`\n```\nThe default event context for ```@event``` expressions is this, so **there is no need to bind the handler function**.\n\n**Examples**\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: String,\n      prop2: String,\n      prop3: Boolean,\n      prop4: String\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 'text binding';\n    this.prop2 = 'mydiv';\n    this.prop3 = true;\n    this.prop4 = 'pie';\n  }\n  render() {\n    return html`\n      <!-- text binding -->\n      <div>${this.prop1}</div>\n\n      <!-- attribute binding -->\n      <div id=\"${this.prop2}\">attribute binding</div>\n\n      <!-- boolean attribute binding -->\n      <div>\n        boolean attribute binding\n        <input type=\"text\" ?disabled=\"${this.prop3}\"/>\n      </div>\n\n      <!-- property binding -->\n      <div>\n        property binding\n        <input type=\"text\" .value=\"${this.prop4}\"/>\n      </div>\n\n      <!-- event handler binding -->\n      <div>event handler binding\n        <button @click=\"${this.clickHandler}\">click</button>\n      </div>\n    `;\n  }\n  clickHandler(e) {\n    console.log(e.target);\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n\n### Render children with the slot element\nYour component may accept children (like a ```<ul>``` element can have ```<li>``` children).\n\n```\n<my-element>\n  <p>A child</p>\n</my-element>\n```\n\n**By default, if an element has a shadow tree, its children don't render at all. To render children, your template needs to include one or more ```<slot>``` elements, which act as placeholders for child nodes.**\n\n### Use the slot element\nTo render an element's children, create a ```<slot>``` for them in the element's template. For example:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot></slot>\n    </div>\n  `;\n}\n```\nChildren will now render in the ```<slot>```:\n\n```\n<my-element>\n  <p>Render me</p>\n</my-element>\n```\nThe children aren't moved in the DOM tree, but they’re rendered as if they were children of the ```<slot>```.\n\nArbitrarily many children can populate a single slot:\n\n```\n<my-element>\n  <p>Render me</p>\n  <p>Me too</p>\n  <p>Me three</p>\n</my-element>\n```\n\n### Use named slots\nTo assign a child to a specific slot, ensure that the child's slot attribute matches the slot's name attribute:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot name=\"one\"></slot>\n    </div>\n  `;\n}\n```\n**index.html**\n\n```\n<my-element>\n  <p slot=\"one\">Include me in slot \"one\".</p>\n</my-element>\n```\nNamed slots only accept children with a matching slot attribute.\n\nFor example, ```<slot name=\"one\"></slot>``` only accepts children with the attribute ```slot=\"one\"```.\n\nChildren with a slot attribute will only be rendered in a slot with a matching name attribute.\n\nFor example, ```<p slot=\"one\">...</p>``` will only be placed in ```<slot name=\"one\"></slot>```.\n\n**Examples**\n\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render(){\n    return html`\n      <div>\n        <slot name=\"one\"></slot>\n        <slot name=\"two\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*index.html*\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js\"></script>\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js\"></script>\n  \n  <script type=\"module\" src=\"./my-element.js\"></script>\n  <title>lit-element code sample</title>\n</head>\n<body>\n    <!-- Assign child to a specific slot -->\n\n    <my-element>\n      <p slot=\"two\">Include me in slot \"two\".</p>\n    </my-element>\n\n    <!-- \n      Named slots only accept children with a matching `slot` attribute. \n      \n      Children with a `slot` attribute can only go into a slot with a matching name. \n    -->\n\n    <my-element>\n      <p slot=\"one\">Include me in slot \"one\".</p>\n      <p slot=\"nope\">This one will not render at all.</p>\n      <p>No default slot, so this one won't render either.</p>\n    </my-element>\n</body>\n</html>\n```\n\n### Use name, not id, to select slots.\n\nNote that a slot’s id attribute has no effect!\n\n*my-element.js*\n\n```\nrender(){\n  return html`\n    <div>\n      <slot id=\"one\"></slot>\n    </div>\n  `;\n}\n```\n\n*index.html*\n\n```\n<my-element>\n  <p slot=\"one\">nope.</p>\n  <p>ohai..</p>\n</my-element>\n```","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates-2","weblink":"https://codersnack.com/webcomponents-litelement-templates-2/","featured_image_preview":{"id":79,"name":"web-components.png","hash":"c062f6a44328443d8e827c1d23c64994","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/c062f6a44328443d8e827c1d23c64994.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T14:13:31.848Z","updated_at":"2020-03-31T14:13:31.848Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates II","created_at":"2020-03-31T14:13:56.568Z","updated_at":"2020-03-31T14:13:56.572Z"},{"id":61,"codersnack":{"id":62,"header":"LitElement Templates 3","created_at":"2020-03-31T14:33:50.941Z","updated_at":"2020-03-31T18:18:52.056Z","explanation":"### Compose a template from other templates\nYou can compose LitElement templates from other LitElement templates. In the following example, we compose a template for an element called ```<my-page>``` from smaller templates for the standard HTML elements ```<header>```, ```<article>```, and ```<footer>```:\n\n```\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      ${this.headerTemplate}\n      ${this.articleTemplate}\n      ${this.footerTemplate}\n    `;\n  }\n  get headerTemplate() {\n    return html`<header>header</header>`;\n  }\n  get articleTemplate() {\n    return html`<article>article</article>`;\n  }\n  get footerTemplate() {\n    return html`<footer>footer</footer>`;\n  }\n}\n```\nYou can also compose templates by importing other elements and using them in your template:\n\n```\nimport './my-header.js';\nimport './my-article.js';\nimport './my-footer.js';\n\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      <my-header></my-header>\n      <my-article></my-article>\n      <my-footer></my-footer>\n    `;\n  }\n}\n```\n\n### Specify the render root\n**The node into which your component's template will render is called its render root**.\n\n**By default, LitElement creates an open shadowRoot and renders inside it,** producing the following DOM structure:\n\n```\n<my-element>\n  #shadow-root\n    <p>child 1</p>\n    <p>child 2</p>\n```\n\nTo customize a component's render root, implement **createRenderRoot** and return the node you want the template to render into.\n\nFor example, to render the template into the main DOM tree as your element's children:\n\n```\n<my-element>\n  <p>child 1</p>\n  <p>child 2</p>\n```\nImplement createRenderRoot and return this:\n\n```\nclass LightDom extends LitElement {\n  render() {\n    return html`\n      <p>This template renders without shadow DOM.</p>\n    `;\n  }\n  createRenderRoot() {\n  /**\n   * Render template without shadow DOM. Note that shadow DOM features like \n   * encapsulated CSS and slots are unavailable.\n   */\n    return this;\n  }\n}\n```\n\n### Using other lit-html features\nSince **LitElement uses the lit-html html tag function to define templates** you can take advantage of the entire lit-html feature set for writing your templates. This includes lit-html directives, special functions that customize the way lit-html renders a binding.\n\n**To import features directly from lit-html, your project should add lit-html as a direct dependency**. We recommend using the widest practical version range for lit-html, to minimize the chance of npm installing two different versions of lit-html:\n\n```\nnpm i lit-element@^2.0.0\nnpm i lit-html@^1.0.0\n```\n#### Import and use a lit-html directive\nYou can import and use a lit-html directive and use it as shown in the lit-html documentation.\n\n```\nimport { LitElement, html } from 'lit-element';\nimport { until } from 'lit-html/directives/until.js';\n\nconst content = fetch('./content.txt').then(r => r.text());\n\nhtml`${until(content, html`<span>Loading...</span>`)}`\n```\nFor a list of directives supplied with lit-html, see Built-in directives in the Template syntax reference.\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates-3","weblink":"https://codersnack.com/webcomponents-litelement-templates-3/","featured_image_preview":{"id":80,"name":"web-components.png","hash":"5ac875bf0ff14b0ea77a14c4b6d826ce","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/5ac875bf0ff14b0ea77a14c4b6d826ce.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T14:33:50.955Z","updated_at":"2020-03-31T14:33:50.955Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component LitElement Templates 3","created_at":"2020-03-31T14:34:33.187Z","updated_at":"2020-03-31T14:34:33.191Z"},{"id":62,"codersnack":{"id":63,"header":"LitElement Properties 1","created_at":"2020-03-31T15:08:19.241Z","updated_at":"2020-03-31T15:08:19.241Z","explanation":"### Overview\n**LitElement manages your declared properties and their corresponding attributes**. By default, LitElement will:\n\n- Ensure that an **element update is scheduled when any declared property changes**.\n- Capture instance values for declared properties. Apply any property values that are set before the browser registers a custom element definition.\n- **Set up an observed (not reflected) attribute** with the lowercased name of each property.\n- **Handle attribute conversion** for properties declared as type String, Number, Boolean, Array, and Object.\n- Use **direct comparison (oldValue !== newValue) to test for property changes**.\n- Apply any property options and accessors declared by a superclass.\n\n> Remember to declare all of the properties that you want LitElement to manage. For the property features above to be applied, you must declare the property.\n\n### Property options\nA property declaration is an object in the following format:\n```\n{ optionName1: optionValue1, optionName2: optionValue2, ... }\n```\n\nThe following options are available:\n\n- **converter**: Convert between properties and attributes.\n- **type**: Use LitElement’s default attribute converter.\n- **attribute**: Configure **observed** attributes.\n- **reflect**: Configure **reflected** attributes.\n- **noAccessor**: Whether to set up a default property accessor.\n- **hasChanged**: Specify what constitutes a property change.\n\n> All property declaration options can be specified in a static properties getter, or with TypeScript decorators.\n\n### Declare properties\nDeclare your element’s properties by implementing a static properties getter, or by using decorators:\n\n```\n// properties getter\nstatic get properties() {\n  return { \n    prop1: { type: String }\n  };\n}\n// Decorators (requires TypeScript or Babel)\nexport class MyElement extends LitElement {\n  @property( { type : String }  ) prop1 = '';\n```\n\n#### Declare properties in a static properties getter\nTo declare properties in a static properties getter:\n\n```\nstatic get properties() { \n  return { \n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean }\n  };\n}\n```\n\nIf you implement a static properties getter, initialize your property values in the element constructor.\n\n```\nconstructor() {\n  // Always call super() first\n  super();\n  this.prop1 = 'Hello World';\n  ...\n}\n```\n> Remember to call ```super()``` first in your constructor, or your element won’t render at all.\n\n**Example**: Declare properties with a static properties getter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = false;\n    this.prop4 = [1,2,3];\n    this.prop5 = { subprop1: 'prop 5 subprop1 value' }\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Declare properties with decorators\nYou can also declare properties with **decorators**:\n\n```\n@property({type : String})  prop1 = 'Hello World';\n```\n> Decorators are a proposed JavaScript feature, so you’ll need to use a transpiler like Babel or the TypeScript compiler to use decorators.\n\nIf you’re using Babel, you’ll need to use the ```@babel/plugin-proposal-decorators```  plugin.\n\nIf you’re using TypeScript, you’ll need to **enable the experimentalDecorators compiler option** (for example, by setting \"experimentalDecorators\": true in *tsconfig.json*). Enabling emitDecoratorMetadata is not required and not recommended.\n\n**Example**: Declare properties with decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'prop 5 subprop1 value' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n```\n\n#### Initialize property values\nInitialize property values in the element constructor\nIf you implement a static properties getter, initialize your property values in the element constructor:\n\n```\nstatic get properties() { return { /* Property declarations */ }; } \n\nconstructor() {\n  // Always call super() first\n  super();\n\n  // Initialize properties \n  this.prop1 = 'Hello World';\n}\n```\n> Remember to call super() first in your constructor, or your element won’t render at all.\n\n**Example**: Initialize property values in the element constructor\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = true;\n    this.prop4 = [1,2,3];\n    this.prop5 = { stuff: 'hi', otherStuff: 'wow' };\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### Initialize property values when using TypeScript decorators\nTypeScript users can initialize property values when they are declared with the @property decorator:\n\n```\n@property({ type : String }) prop1 = 'Hello World';\n```\n**Example**: Initialize property values when using TypeScript decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  // Declare and initialize properties\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'hi', thing: 'fasdfsf' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\n```\n\n#### Initialize property values from attributes in markup\nYou can also initialize property values from observed attributes in markup:\n\n*index.html*\n\n```\n<my-element \n  mystring=\"hello world\"\n  mynumber=\"5\"\n  mybool\n  myobj='{\"stuff\":\"hi\"}'\n  myarray='[1,2,3,4]'></my-element>\n```\n\nSee observed attributes and converting between properties and attributes for more information on setting up initialization from attributes.","references":"- [LitElement properties](https://lit-element.polymer-project.org/guide/properties)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-properties-1","weblink":"https://codersnack.com/webcomponents-litelement-properties-1/","featured_image_preview":{"id":81,"name":"web-components.png","hash":"bab685844ed0414b97905d1d9b06a0c8","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bab685844ed0414b97905d1d9b06a0c8.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T15:08:19.259Z","updated_at":"2020-03-31T15:08:19.259Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Properties 1","created_at":"2020-03-31T15:09:10.363Z","updated_at":"2020-03-31T15:09:10.368Z"},{"id":63,"codersnack":{"id":64,"header":"LitElement Properties 2","created_at":"2020-03-31T15:56:12.994Z","updated_at":"2020-03-31T18:16:25.581Z","explanation":"### Properties vs Attributes\nThe difference between properties and attributes can be confusing. **Properties are available on a DOM node** when being manipulated by JavaScript:\n\n```\nconst myElem = document.querySelector('.my-elem');\nmyElem.className; // className is a property\n```\nAnd **attributes are provided in the HTML itself**. Here alt, width and height are all attributes:\n```\n<img src=\"/path/to/img.svg\" alt=\"My Image\" width=\"150\" height=\"250\">\n```\n**Attributes should only be used for scalar values like strings, numbers and boolean values**. **Properties, on the other hand, are perfectly suited to also hold values that are objects or arrays**.\n\n### Reflecting Properties to Attributes\n**Most properties reflect their values as attributes, meaning that if the property is changed using JavaScript, the corresponding attribute is also changed at the same time to reflect the new value**. This is useful for accessibility and to allow CSS selectors to work as intended.\n\nYou can try it out yourself for a concrete example. Just select, say, an image element in your browser’s developer tools, and then change one of its properties:\n\n```\nconst fancyImage = document.querySelector('.fancy-image');\n\nfancyImage.width = 777;\n```\nNotice how the with attribute in the DOM representation is automatically changed to the new value. The same is true if you change the value for the attribute manually in the DOM inspector, you’ll see that the property will now hold the new value.\n\n![attributes-properties](https://codersnack.com/assets/images/attributes-properties.png)\n\n### Reflecting properties to attributes in Custom Elements\nYour own Custom Elements should also follow this practice of reflecting properties to attributes. Luckily, it's quite easy to do using getters and setters.\n\nFor example, if you have a custom element that has a value property that should be reflected as an attribute, here’s how you would use a getter and a setter to get the value of the attribute when doing property access and setting the new value for the attribute when the property is changed:\n\n```\nget value() {\n  return this.getAttribute('value');\n}\n\nset value(newValue) {\n  this.setAttribute('value', newValue);\n}\n```\nOr, if you have a boolean property, like, say hidden:\n\n```\nget hidden() {\n  return this.hasAttribute('hidden');\n}\n\nset hidden(isHidden) {\n  if (isHidden) {\n    this.setAttribute('hidden', '');\n  } else {\n    this.removeAttribute('hidden');\n  }\n}\n```\n\n### Configure attributes\n\n#### Convert between properties and attributes\n\n**While element properties can be of any type, attributes are always strings**. This impacts the observed attributes and reflected attributes of non-string properties:\n\nTo observe an attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type.\n\nTo reflect an attribute (set an attribute from a property), the property value must be converted to a string.\n\n#### Use the default converter\nLitElement has a default converter which handles String, Number, Boolean, Array, and Object property types.\n\n**To use the default converter, specify the type option in your property declaration**:\n```\n// Use LitElement's default converter \nprop1: { type: String },\nprop2: { type: Number },\nprop3: { type: Boolean },\nprop4: { type: Array },\nprop5: { type: Object }\n```\nThe information below shows how the default converter handles conversion for each type.\n\n#### Convert from attribute to property\n\n- For Strings, when the attribute is defined, set the property to the attribute value.\n- For Numbers, when the attribute is defined, set the property to Number(attributeValue).\n- For Booleans, when the attribute is:\n     non-null, set the property to true.\n     null or undefined, set the property to false.\n- For Objects and Arrays, when the attribute is:\n     Defined, set the property value to JSON.parse(attributeValue).\n\n#### Convert from property to attribute\n\n- For Strings, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Numbers, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Booleans, when the property is:\n    truthy, create the attribute.\n    falsy, remove the attribute.\n- For Objects and Arrays, when the property is:\n    null or undefined, remove the attribute.\n    Defined and not null, set the attribute value to JSON.stringify(propertyValue).\n\n**Example**: Use the default converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String, reflect: true },\n    prop2: { type: Number, reflect: true },\n    prop3: { type: Boolean, reflect: true },\n    prop4: { type: Array, reflect: true },\n    prop5: { type: Object, reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = '';\n    this.prop2 = 0;\n    this.prop3 = false;\n    this.prop4 = [];\n    this.prop5 = { };\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    console.log('attribute change: ', name, newVal);\n    super.attributeChangedCallback(name, oldVal, newVal);\n  }\n\n  render() {\n    return html`\n      <p>prop1 ${this.prop1}</p>\n      <p>prop2 ${this.prop2}</p>\n      <p>prop3 ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.getAttribute('prop3');\n\n    this.setAttribute('prop1', randy.toString());\n    this.setAttribute('prop2', randy.toString());\n    this.setAttribute('prop3', myBool? '' : null);\n    this.setAttribute('prop4', JSON.stringify([...this.prop4, randy]));\n    this.setAttribute('prop5',\n      JSON.stringify(Object.assign({}, this.prop5, {[randy]: randy})));\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.prop3;\n\n    this.prop1 = randy.toString();\n    this.prop2 = randy;\n    this.prop3 = !myBool;\n    this.prop4 = [...this.prop4, randy];\n    this.prop5 = Object.assign({}, this.prop5, {[randy]: randy});\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Configure a custom converter\nYou can specify a custom property converter in your property declaration with the converter option:\n\n```\nmyProp: { \n  converter: // Custom property converter\n} \n```\nconverter can be an object or a function. If it is an object, it can have keys for fromAttribute and toAttribute:\n\n```\nprop1: { \n  converter: { \n    fromAttribute: (value, type) => { \n      // `value` is a string\n      // Convert it to a value of type `type` and return it\n    },\n    toAttribute: (value, type) => { \n      // `value` is of type `type` \n      // Convert it to a string and return it\n    }\n  }\n}\n```\nIf converter is a function, it is used in place of fromAttribute:\n\n```\nmyProp: { \n  converter: (value, type) => { \n    // `value` is a string\n    // Convert it to a value of type `type` and return it\n  }\n} \n```\nIf no **toAttribute** function is supplied for a reflected attribute, the attribute is set to the property value without conversion.\n\nDuring an update:\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n**Example**: Configure a custom converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: {\n      reflect: true,\n      converter: {\n        toAttribute(value) {\n          console.log('myProp\\'s toAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = String(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        },\n\n        fromAttribute(value) {\n          console.log('myProp\\'s fromAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = Number(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        }\n      }\n    },\n\n    theProp: {\n      reflect: true,\n      converter(value) {\n        console.log('theProp\\'s converter.');\n        console.log('Processing:', value, typeof(value));\n\n        let retVal = Number(value);\n        console.log('Returning:', retVal, typeof(retVal));\n        return retVal;\n      }},\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    // console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n    this.theProp='theProp ' + randomString;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure observed attributes\nAn **observed attribute fires** the custom elements API callback **attributeChangedCallback** whenever it changes. By default, whenever an attribute fires this callback, LitElement sets the property value from the attribute using the property's fromAttribute function. See Convert between properties and attributes for more information.\n\n**By default, LitElement creates a corresponding observed attribute for all declared properties**. The name of the observed attribute is the property name, lowercased:\n\n```\n// observed attribute name is \"myprop\"\nmyProp: { type: Number }\n```\nTo create an observed attribute with a different name, set attribute to a string:\n\n```\n// Observed attribute will be called my-prop\nmyProp: { attribute: 'my-prop' }\n```\n\n**To prevent an observed attribute from being created for a property**, set attribute to false. The property will not be initialized from attributes in markup, and attribute changes won’t affect it.\n\n```\n// No observed attribute for this property\nmyProp: { attribute: false }\n```\n\n**An observed attribute can be used to provide an initial value for a property via markup**. See Initialize properties with attributes in markup.\n\n**Example**: Configure observed attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { attribute: true },\n    theProp: { attribute: false },\n    otherProp: { attribute: 'other-prop' },\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n    this.otherProp = 'otherProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n      <p>otherProp ${this.otherProp}</p>\n\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.setAttribute('other-prop', 'other-prop ' + randomString);\n    this.requestUpdate();\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\nAn observed attribute can be used to provide an initial value for a property via markup. See Initialize properties with attributes in markup.\n\n### Configure reflected attributes\n**You can configure a property so that whenever it changes, its value is reflected to its observed attribute**. For example:\n\n```\n// Value of property \"myProp\" will reflect to attribute \"myprop\"\nmyProp: { reflect: true }\n```\n\nWhen the property changes, LitElement uses the toAttribute function in the property's converter to set the attribute value from the new property value.\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n- If toAttribute itself is undefined, the property value is set to the attribute value without conversion.\n\nLitElement tracks reflection state during updates. LitElement keeps track of state information to avoid creating an infinite loop of changes between a property and an observed, reflected attribute.\n\n**Example**: Configure reflected attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.myProp='myProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>${this.myProp}</p>\n\n      <button @click=\"${this.changeProperty}\">change property</button>\n    `;\n  }\n\n  changeProperty() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n  }\n\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure property changes\nAll declared properties have a function, **hasChanged**, which is **called whenever the property is set.**\n\nhasChanged compares the property's old and new values, and evaluates whether or not the property has changed. If hasChanged returns true, **LitElement starts an element update if one is not already scheduled**. See the Element update lifecycle documentation for more information on how updates work.\n\nBy default:\n\n- hasChanged returns true if newVal !== oldVal.\n- hasChanged returns false if both the new and old values are NaN.\n\nTo customize **hasChanged** for a property, specify it as a property option:\n\n```\nmyProp: { hasChanged(newVal, oldVal) {\n  // compare newVal and oldVal\n  // return `true` if an update should proceed\n}}\n```\n**Example**: Configure property changes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties(){ return {\n    myProp: {\n      type: Number,\n\n      /**\n       * Compare myProp's new value with its old value.\n       *\n       * Only consider myProp to have changed if newVal is larger than\n       * oldVal.\n       */\n      hasChanged(newVal, oldVal) {\n        if (newVal > oldVal) {\n          console.log(`${newVal} > ${oldVal}. hasChanged: true.`);\n          return true;\n        }\n        else {\n          console.log(`${newVal} <= ${oldVal}. hasChanged: false.`);\n          return false;\n        }\n      }\n    }};\n  }\n\n  constructor(){\n    super();\n    this.myProp = 1;\n  }\n\n  render(){\n    return html`\n      <p>${this.myProp}</p>\n      <button @click=\"${this.getNewVal}\">get new value</button>\n    `;\n  }\n\n  updated(){\n    console.log('updated');\n  }\n\n  getNewVal(){\n    let newVal = Math.floor(Math.random()*10);\n    this.myProp = newVal;\n  }\n\n}\ncustomElements.define('my-element', MyElement);\n```\n\n  ","references":"- [LitElement Properties](https://lit-element.polymer-project.org/guide/properties)\n- [Alligator.io attributes-properties](https://alligator.io/web-components/attributes-properties/)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-properties-2","weblink":"https://codersnack.com/webcomponents-litelement-properties-2/","featured_image_preview":{"id":82,"name":"web-components.png","hash":"6fbc67b16bfb49d8a1ff9394e314e102","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/6fbc67b16bfb49d8a1ff9394e314e102.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T15:56:13.010Z","updated_at":"2020-03-31T15:56:13.010Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Properties 2","created_at":"2020-03-31T15:56:38.406Z","updated_at":"2020-03-31T15:56:38.410Z"},{"id":64,"codersnack":{"id":65,"header":"LitElement Lifecycle 1","created_at":"2020-03-31T19:29:29.965Z","updated_at":"2020-03-31T19:30:32.335Z","explanation":"### Overview\n**LitElement-based components update asynchronously in response to observed property changes**. **Property changes are batched**—if more properties change after an update is requested, but before the update starts, all of the changes are captured in the same update.\n\nAt a high level, the update lifecycle is:\n\n- A property is set.\n- Check whether an update is needed. If an update is needed, request one.\n- Perform the update:\n    Process properties and attributes.\n    Render the element.\n- Resolve a Promise, indicating that the update is complete.\n\n#### LitElement and the browser event loop\n**The browser executes JavaScript code by processing a queue of tasks in the event loop**. In each iteration of the event loop, the browser takes a task from the queue and runs it to completion.\n\nWhen the task completes, before taking the next task from the queue, the browser allocates time to perform work from other sources—including DOM updates, user interactions, and the microtask queue.\n\nBy default, **LitElement updates are requested asynchronously, and queued as microtasks**. This means that Step 3 above (Perform the update) is executed at the end of the next iteration of the event loop.\n\n> You can change this behavior so that Step 3 awaits a Promise before performing the update. See performUpdate for more information.\n\n#### Lifecycle callbacks\nLitElement also inherits the default lifecycle callbacks from the Web Component standard:\n\n- **connectedCallback**: Invoked when a component is added to the document’s DOM.\n- **disconnectedCallback**: Invoked when a component is removed from the document’s DOM.\n- **adoptedCallback**: Invoked when a component is moved to a new document.\n- **attributeChangedCallback**: Invoked when component attribute changes.\n\n> Be aware that adoptedCallback is not polyfilled.\n\n**All lifecycle methods need to call the super method.**\n\n*Example*:\n\n```\nconnectedCallback() {\n  super.connectedCallback()\n\n  console.log('connected')\n}\n```\n\n#### Promises and asynchronous functions\n**LitElement uses *Promise* objects to schedule and respond to element updates**.\n\nUsing *async* and *await* makes it easy to work with *Promises*. For example, you can await the **updateComplete** Promise:\n\n```\n// `async` makes the function return a Promise & lets you use `await`\nasync myFunc(data) {\n  // Set a property, triggering an update\n  this.myProp = data;\n\n  // Wait for the updateComplete promise to resolve\n  await this.updateComplete;\n  // ...do stuff...\n  return 'done';\n}\n```\n\nBecause *async* functions return a *Promise*, you can await them, too:\n\n```\nlet result = await myFunc('stuff');\n// `result` is resolved! You can do something with it\n```\nSee the Web Fundamentals primer on Promises for a more in-depth tutorial.\n\n#### Methods and properties\n**In call order, the methods and properties in the update lifecycle are:**\n\n- **someProperty.hasChanged**\n- **requestUpdate**\n- **performUpdate**\n- **shouldUpdate**\n- **update**\n- **render**\n- **firstUpdated**\n- **updated**\n- **updateComplete**\n\n#### someProperty.hasChanged\n\nAll declared properties have a function, *hasChanged*, which is called whenever the property is set; if *hasChanged* returns true, an update is scheduled.\n\nSee the Properties documentation for information on configuring hasChanged to customize what constitutes a property change.\n\n#### requestUpdate\n\n```\n// Manually start an update\nthis.requestUpdate();\n\n// Call from within a custom property setter\nthis.requestUpdate(propertyName, oldValue);\n```\nParams:\n- propertyName: Name of property to be updated.\n- oldValue: Previous property value.\n\nReturns:\n- Promise: Returns the updateComplete Promise, which resolves on completion of the update.\n\nUpdates?:\n - No: Property changes inside this method will not trigger an element update.\n\nIf *hasChanged* returned true, requestUpdate fires, and the update proceeds.\n\n**To manually start an element update, call requestUpdate with no parameters**.\n\nTo implement a custom property setter that supports property options, pass the property name and its previous value as parameters.\n\n*Example*: Manually start an element update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  constructor() {\n    super();\n\n    // Request an update in response to an event\n    this.addEventListener('load-complete', async (e) => {\n      console.log(e.detail.message);\n      console.log(await this.requestUpdate());\n    });\n  }\n  render() {\n    return html`\n      <button @click=\"${this.fire}\">Fire a \"load-complete\" event</button>\n    `;\n  }\n  fire() {\n    let newMessage = new CustomEvent('load-complete', {\n      detail: { message: 'hello. a load-complete happened.' }\n    });\n    this.dispatchEvent(newMessage);\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*Example*: Call **requestUpdate from a custom property setter**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { \n    return { prop: { type: Number } };\n  }\n\n  set prop(val) {\n    let oldVal = this._prop;\n    this._prop = Math.floor(val);\n    this.requestUpdate('prop', oldVal);\n  }\n\n  get prop() { return this._prop; }\n\n  constructor() {\n    super();\n    this._prop = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop: ${this.prop}</p>\n      <button @click=\"${() =>  { this.prop = Math.random()*10; }}\">\n        change prop\n      </button>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### performUpdate\n```\n/**\n * Implement to override default behavior.\n */\nperformUpdate() { ... }\n```\nReturns: void or Promise: Performs an update.\nUpdates?: No : Property changes inside this method will not trigger an element update.\n\n**By default, performUpdate is scheduled as a *microtask* after the end of the next execution of the browser event loop**. To schedule *performUpdate*, implement it as an asynchronous method that awaits some state before calling *super.performUpdate()*. For example:\n\n```\nasync performUpdate() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n  super.performUpdate();\n}\n```\n\n#### shouldUpdate\n```\n/**\n * Implement to override default behavior.\n */\nshouldUpdate(changedProperties) { ... }\n```\nParams:\n- *changedProperties*: Map. Keys are the names of changed properties; Values are the corresponding previous values.\n\nReturns: Boolean: If true, update proceeds. Default return value is true.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Controls whether an update should proceed**. Implement shouldUpdate to specify which property changes should cause updates. By default, this method always returns true.\n\n*Example*: Customize which property changes should cause updates\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number },\n      prop2: { type: Number }\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 0;\n    this.prop2 = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <button @click=\"${() => this.prop1=this.change()}\">Change prop1</button>\n      <button @click=\"${() => this.prop2=this.change()}\">Change prop2</button>\n    `;\n  }\n\n  /**\n   * Only update element if prop1 changed.\n   */\n  shouldUpdate(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    return changedProperties.has('prop1');\n  }\n\n  change() {\n    return Math.floor(Math.random()*10);\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### update\nParams:\n- changedProperties:Map. Keys are the names of changed properties; Values are the corresponding previous values.\n\nUpdates? : No: Property changes inside this method do not trigger an element update.\n\n**Reflects property values to attributes and calls render to render DOM via lit-html**. Provided here for reference. **You don’t need to override or call this method**.\n\n##### render\n```\n/**\n * Implement to override default behavior.\n */\nrender() { ... }\n```\nReturns: TemplateResult: Must return a lit-html TemplateResult.\nUpdates?: No: Property changes inside this method will not trigger an element update.\n\n**Uses *lit-html* to render the element template**. You must implement render for any component that extends the LitElement base class.\n\n","references":"- [LitElement lifecycle](https://lit-element.polymer-project.org/guide/lifecycle)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-lifecycle","weblink":"https://codersnack.com/webcomponents-litelement-lifecycle/","featured_image_preview":{"id":83,"name":"web-components.png","hash":"67b4451c527b46db8f63c304af7e262b","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/67b4451c527b46db8f63c304af7e262b.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T19:29:29.981Z","updated_at":"2020-03-31T19:29:29.981Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElements Lifecycle 1","created_at":"2020-03-31T19:30:08.056Z","updated_at":"2020-03-31T19:30:08.062Z"},{"id":65,"codersnack":{"id":66,"header":"LitElement Lifecycle 2","created_at":"2020-03-31T19:51:01.653Z","updated_at":"2020-03-31T19:51:01.653Z","explanation":"#### firstUpdated\n```\n/**\n * Implement to override default behavior.\n */\nfirstUpdated(changedProperties) { ... }\n```\nParams: changedProperties: Map. Keys are the names of changed properties; Values are the corresponding previous values.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Called after the element's DOM has been updated the first time, immediately before updated is called**.\n\n> Implement firstUpdated to perform one-time work after the element's template has been created.\n\n*Example*: Focus an input element on first update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      textAreaId: { type: String },\n      startingText: { type: String }\n    };\n  }\n  constructor() {\n    super();\n    this.textAreaId = 'myText';\n    this.startingText = 'Focus me on first update';\n  }\n  render() {\n    return html`\n      <textarea id=\"${this.textAreaId}\">${this.startingText}</textarea>\n    `;\n  }\n  firstUpdated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    const textArea = this.shadowRoot.getElementById(this.textAreaId);\n    textArea.focus();\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### updated\n```\n/**\n * Implement to override default behavior.\n */\nupdated(changedProperties) { ... }\n```\nParams: changedProperties:Map. Keys are the names of changed properties; Values are the corresponding previous values.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Called when the element’s DOM has been updated and rendered**. Implement to perform some task after an update.\n\n**Example**: Focus an element after update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number },\n      prop2: { type: Number }\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 0;\n    this.prop2 = 0;\n  }\n  render() {\n    return html`\n      <style>button:focus { background-color: aliceblue; }</style>\n\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n\n      <button id=\"a\" @click=\"${() => this.prop1=Math.random()}\">prop1</button>\n      <button id=\"b\" @click=\"${() => this.prop2=Math.random()}\">prop2</button>\n    `;\n  }\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    let b = this.shadowRoot.getElementById('b');\n    b.focus();\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### updateComplete\n```\n// Await Promise property.\nawait this.updateComplete;\n```\nType: Promise: Resolves with a Boolean when the element has finished updating.\nResolves: true if there are no more pending updates.false if this update cycle triggered another update.\n\nThe *updateComplete* Promise resolves when the element has finished updating. **Use updateComplete to wait for an update**:\n```\n  await this.updateComplete;\n  // do stuff\n  this.updateComplete.then(() => { /* do stuff */ });\n```\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number }\n    };\n  }\n\n  constructor() {\n    super();\n    this.prop1 = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <button @click=\"${this.changeProp}\">prop1</button>\n    `;\n  }\n\n  async getMoreState() {\n    return;\n  }\n\n  async changeProp() {\n    this.prop1 = Math.random();\n    await Promise.all([this.updateComplete, this.getMoreState()]);\n    console.log('Update complete. Other state completed.');\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Overriding updateComplete\n\nTo await additional state before fulfilling the *updateComplete* promise, override the *_getUpdateComplete* method. For example, it may be useful to await the update of a child element here. First await *super._getUpdateComplete()*, then any subsequent state.\n\n> It’s recommended to override the *_getUpdateComplete* method instead of the *updateComplete* getter to ensure compatibility with users who are using TypeScript’s ES5 output (see TypeScript#338).\n\n```\n  class MyElement extends LitElement {\n    async _getUpdateComplete() {\n      await super._getUpdateComplete();\n      await this._myChild.updateComplete;\n    }\n  }\n```\n### Examples\n#### Control when updates are processed\nImplement **performUpdate**:\n\n```\nasync performUpdate() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve());\n  super.performUpdate();\n}\n```\n\n#### Customize which property changes should cause an update\nImplement **shouldUpdate**:\n\n```\nshouldUpdate(changedProps) {\n  return changedProps.has('prop1');\n}\n```\n\n#### Customize what constitutes a property change\nSpecify *hasChanged* for the property. See the Properties documentation.\n\nManage property changes and updates for object subproperties\n\n> **Mutations** (changes to object subproperties and array items) **are not observable**. Instead, either rewrite the whole object, or call requestUpdate after a mutation.\n\n```\n// Option 1: Rewrite whole object, triggering an update\nthis.prop1 = Object.assign({}, this.prop1, { subProp: 'data' });\n\n// Option 2: Mutate a subproperty, then call requestUpdate\nthis.prop1.subProp = 'data';\nthis.requestUpdate();\n```\n#### Update in response to something that isn’t a property change\nCall **requestUpdate**:\n```\n// Request an update in response to an event\nthis.addEventListener('load-complete', async (e) => {\n  console.log(e.detail.message);\n  console.log(await this.requestUpdate());\n});\n```\n\n#### Request an update regardless of property changes\nCall **requestUpdate()**:\n\n```\nthis.requestUpdate();\n```\n#### Request an update for a specific property\nCall requestUpdate(propName, oldValue):\n\n```\nlet oldValue = this.prop1;\nthis.prop1 = 'new value';\nthis.requestUpdate('prop1', oldValue);\n\n```\n#### Do something after the first update\nImplement **firstUpdated**:\n\n```\nfirstUpdated(changedProps) {\n  console.log(changedProps.get('prop1'));\n}\n```\n\n#### Do something after every update\nImplement updated:\n\n```\nupdated(changedProps) {\n  console.log(changedProps.get('prop1'));\n}\n```\n\n#### Do something when the element next updates\nAwait the updateComplete promise:\n\n```\nawait this.updateComplete;\n// do stuff\nthis.updateComplete.then(() => {\n  // do stuff\n});\n```\n#### Wait for an element to finish updating\nAwait the **updateComplete** promise:\n\n```\nlet done = await updateComplete;\nupdateComplete.then(() => {\n  // finished updating\n});\n```","references":"- [LitElement lifecycle](https://lit-element.polymer-project.org/guide/lifecycle)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-lifecycle-2","weblink":"https://codersnack.com/webcomponents-litelement-lifecycle-2/","featured_image_preview":{"id":84,"name":"web-components.png","hash":"b2662578910947778db5dff923d891dd","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/b2662578910947778db5dff923d891dd.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T19:51:01.667Z","updated_at":"2020-03-31T19:51:01.667Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Lifecycle 2","created_at":"2020-03-31T19:51:34.365Z","updated_at":"2020-03-31T19:51:34.369Z"}]