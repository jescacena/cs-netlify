[{"id":53,"codersnack":{"id":54,"header":"Introduction to Web Components","created_at":"2020-02-29T11:06:51.993Z","updated_at":"2020-02-29T21:31:43.928Z","explanation":"### What are Web Components, anyway?\n\nWeb Components consist of **three separate technologies that are used together:**\n\n- **Custom Elements**. Quite simply, these are fully-valid HTML elements with custom templates, behaviors and tag names (e.g. ```<one-dialog>```) made with a set of JavaScript APIs. Custom Elements are defined in the *HTML Living Standard specification*.\n- **Shadow DOM**. Capable of isolating CSS and JavaScript, almost like an ```<iframe>```. This is defined in the *Living Standard DOM specification*.\n- **HTML templates**. User-defined templates in HTML that aren't rendered until called upon. The ```<template>``` tag is defined in the *HTML Living Standard specification*.\n\nThese are what make up the *Web Components specification*.\n\n> **HTML Modules** is likely to be the fourth technology in the stack, but it has yet to be implemented in any of the big four browsers. The Chrome team has announced it an intent to implement them in a future release.\n\n**Web Components are generally available in all of the major browsers** with the exception of Microsoft Edge and Internet Explorer 11, but polyfills exist to fill in those gaps.\n\nReferring to any of these as Web Components is technically accurate because the term itself is a bit overloaded. As a result, each of the technologies can be used independently or combined with any of the others. In other words, they are not mutually exclusive.\n\n### Custom elements\nAs the name implies, **custom elements are HTML elements,** like ```<div>```, ```<section>``` or ```<article>```, but something **we can name ourselves that are defined via a browser API**. Custom elements are just like those standard HTML elements — names in angle brackets — except **they always have a dash in them**, like ```<news-slider>``` or ```<bacon-cheeseburger>```. Going forward, browser vendors have committed not to create new built-in elements containing a dash in their names to prevent conflicts.\n\nCustom elements contain their own semantics, behaviors, markup and can be shared across frameworks and browsers.\n```\nclass MyComponent extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `<h1>Hello world</h1>`;\n  }\n}\ncustomElements.define('my-component', MyComponent);\n```\n![Custom Elements](https://codersnack.com/assets/images/web-components-custom-elements.png)\n\nIn this example, we define ```<my-component>```, our very own HTML element. Admittedly, it doesn’t do much, however this is the basic building block of a custom element. **All custom elements must in some way extend an HTMLElement in order to be registered with the browser.**\n\n**Custom elements exist without third-party frameworks** and the browser vendors are dedicated to the continued backward compatibility of the spec, all but guaranteeing that components written according to the specifications will not suffer from breaking API changes. What’s more, **these components can generally be used out-of-the-box with today’s most popular frameworks**, including Angular, React, Vue, and others with minimal effort.\n\n### Shadow DOM\n**The shadow DOM is an encapsulated version of the DOM**. This allows authors to effectively isolate DOM fragments from one another, including anything that could be used as a CSS selector and the styles associated with them. Generally, any content inside of the document's scope is referred to as the light DOM, and anything inside a shadow root is referred to as the shadow DOM.\n\nImagine the following scenario:\n```\n<div>\n  <div id=\"example\">\n    <!-- Pseudo-code used to designate a shadow root -->\n    <#shadow-root>\n      <style>\n      button {\n        background: tomato;\n        color: white;\n      }\n      </style>\n      <button id=\"button\">This will use the CSS background tomato</button>\n    </#shadow-root>\n  </div>\n  <button id=\"button\">Not tomato</button>\n</div>\n```\nAside from the pseudo-code of ```<#shadow-root>``` (which is used here to demarcate the shadow boundary which has no HTML element), the HTML is fully valid. To attach a shadow root to the node above, we would run something like:\n\n```\nconst shadowRoot = document.getElementById('example').attachShadow({ mode: 'open' });\nshadowRoot.innerHTML = `<style>\nbutton {\n  color: tomato;\n}\n</style>\n<button id=\"button\">This will use the CSS color tomato <slot></slot></button>`;\n```\nA shadow root can also include content from its containing document by using the ```<slot>``` element. **Using a slot will drop user content from the outer document at a designated spot in your shadow root**.\n\n### HTML templates\nThe aptly-named HTML ```<template>```  element allows us to stamp out **re-usable templates of code inside a normal HTML flow that won't be immediately rendered, but can be used at a later time**.\n\n```\n<template id=\"book-template\">\n  <li><span class=\"title\"></span> &mdash; <span class=\"author\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\nThe example above wouldn’t render any content until a script has consumed the template, instantiated the code and told the browser what to do with it.\n\n```\nconst fragment = document.getElementById('book-template');\nconst books = [\n  { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald' },\n  { title: 'A Farewell to Arms', author: 'Ernest Hemingway' },\n  { title: 'Catch 22', author: 'Joseph Heller' }\n];\n\nbooks.forEach(book => {\n  // Create an instance of the template content\n  const instance = document.importNode(fragment.content, true);\n  // Add relevant content to the template\n  instance.querySelector('.title').innerHTML = book.title;\n  instance.querySelector('.author').innerHTML = book.author;\n  // Append the instance ot the DOM\n  document.getElementById('books').appendChild(instance);\n});\n```\n\nNotice that this example creates a template (```<template id=\"book-template\">```) without any other Web Components technology, illustrating again that **the three technologies in the stack can be used independently or collectively**.\n\nOstensibly, the consumer of a service that utilizes the template API could write a template of any shape or structure that could be created at a later time. Another page on a site might use the same service, but structure the template this way:\n\n```\n<template id=\"book-template\">\n  <li><span class=\"author\"></span>'s classic novel <span class=\"title\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\n","references":"- [CSS trick - Calleb Williams - Introduction to web components](https://css-tricks.com/an-introduction-to-web-components/)\n- [HTML Living Standard specification](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements)\n- [Living Standard DOM specification](https://dom.spec.whatwg.org/#shadow-trees)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-introduction","weblink":"https://codersnack.com/web-components-introduction/","featured_image_preview":{"id":70,"name":"web-components.png","hash":"bb73ea6081f440319172079b80849d32","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bb73ea6081f440319172079b80849d32.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T11:06:52.003Z","updated_at":"2020-02-29T11:06:52.003Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web components introduction","created_at":"2020-02-29T11:07:25.496Z","updated_at":"2020-02-29T11:07:25.500Z"},{"id":58,"codersnack":{"id":59,"header":"LitElement and lit-html Introduction","created_at":"2020-03-30T13:59:50.431Z","updated_at":"2020-03-30T14:04:17.504Z","explanation":"### What is LitElement?\n\n**LitElement** is a **simple base class for creating fast, lightweight web components** that work in any web page with any framework.\n\n**LitElement uses lit-html to render into shadow DOM**, and **adds API to manage properties and attributes**. *Properties are observed by default, and elements update asynchronously when their properties change*.\n\n### Setup\n**You need npm and Node.js** to work with LitElement.\n\n**LitElement uses JavaScript modules to import dependencies** by their npm package names. Since web browsers need to know a file's full URL to import it, your local development server needs to serve full, transformed URL paths to your web browser.\n\n**To deploy an optimized build** that works on your target browsers, you’ll also **need a build toolset** that can handle this transform, along with any bundling.\n\n**One option is Polymer CLI**, which includes a development server that converts module names to paths on the fly; and a configurable build tool that packages your code for deployment.\n\nTo install Polymer CLI with npm:\n```\nnpm install -g polymer-cli\n```\nTo serve a LitElement project locally:\n\n```\npolymer serve\n```\nSee the Polymer CLI documentation for more information on configuring these tools.\n\n\n### Create a LitElement component\nTo create a new class based on LitElement:\n\nIn your project folder, install the lit-element package from npm:\n\n```\nnpm install lit-element\n```\n\nWrite your new element:\n\n- Import the LitElement base class and the html helper function.\n- Create a new class that extends the LitElement base class.\n- Implement render to define a template for your web component.\n- Register your component’s HTML tag with the browser.\n\n*Example*\n\n**my-element.js**\n\n```\n// Import the LitElement base class and html helper function\nimport { LitElement, html } from 'lit-element';\n\n// Extend the LitElement base class\nclass MyElement extends LitElement {\n\n  /**\n   * Implement `render` to define a template for your element.\n   *\n   * You must provide an implementation of `render` for any element\n   * that uses LitElement as a base class.\n   */\n  render(){\n    /**\n     * `render` must return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function:\n     */\n    return html`\n      <!-- template content -->\n      <p>A paragraph</p>\n    `;\n  }\n}\n// Register the new element with the browser.\ncustomElements.define('my-element', MyElement);\n```\n\n### Use LitElement TypeScript decorators\nYou can use the **@customElement TypeScript decorator** to define your class as a custom element:\n\n```\n/**\n * Import LitElement base class, html helper function,\n * and TypeScript decorators\n **/\nimport {\n  LitElement, html, customElement, property\n} from 'lit-element';\n\n/**\n * Use the customElement decorator to define your class as\n * a custom element. Registers <my-element> as an HTML tag.\n */\n@customElement('my-element')\nexport class MyElement extends LitElement {\n\n  /**\n   * Create an observed property. Triggers update on change.\n   */\n  @property()\n  foo = 'foo';\n\n  /**\n   * Implement `render` to define a template for your element.\n   */\n  render(){\n    /**\n     * Use JavaScript expressions to include property values in\n     * the element template.\n     */\n    return html`<p>${this.foo}</p>`;\n  }\n}\n```\n\n### Import a component\nImport your own LitElement component\nIn an HTML document:\n\n```\n<head>\n  <script type=\"module\" src=\"/path/to/my-element.js\"></script>\n</head>\n<body>\n  <my-element></my-element>\n</body>\n```\n\nIn another JavaScript module:\n\n```\n// Use relative paths for peer dependencies\nimport './my-element.js';\n\nclass MyOtherElement extends LitElement{\n  render(){\n    return html`\n      <my-element></my-element>\n    `;\n  }\n}\ncustomElements.define('my-other-element', MyOtherElement);\n```\n### Import a third-party LitElement component\nRefer to third-party component documentation first. To work with any existing component made by a third party, see its documentation. This guide should work for most LitElement-based components if they are published on npm.\n\nMany components are published on npm and can be installed from the command line:\n\n```\ncd my-project-folder\nnpm install package-name\n```\nIn an HTML document, a component published on npm can be imported from the node_modules folder:\n\n```\n<head>\n  <script type=\"module\" src=\"node_modules/package-name/existing-element.js\"></script>\n</head>\n<body>\n  <existing-element></existing-element>\n</body>\n```\nTo import into another JavaScript module, use the component’s package name:\n\n```\nimport 'package-name/existing-element.js';\n\nclass MyElement extends LitElement{\n  render(){\n    return html`\n      <existing-element></existing-element>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### What is lit-html?\nlit-html is a simple, modern, safe, small and fast **HTML templating library for JavaScript.**\n\nlit-html lets you write HTML templates in JavaScript using **template literals with embedded JavaScript expressions**. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.\n\nBuilding components? **lit-html is not tied to any component model**, it focuses only on creating and updating DOM. If you want to build components, check out **LitElement**, a library for building web components using lit-html templates.\n\n### lit-html Templates\nlit-html templates are **tagged template literals** - they look like JavaScript strings but are enclosed in backticks (`) instead of quotes - and tagged with lit-html's html tag:\n\n```\nhtml`<h1>Hello ${name}</h1>`\n```\nSince lit-html templates almost always need to merge in data from JavaScript values, and be able to update DOM when that data changes, they'll most often be written within functions that take some data and return a lit-html template, so that the function can be called multiple times:\n\n```\nlet myTemplate = (data) => html`\n  <h1>${data.title}</h1>\n  <p>${data.body}</p>`;\n```\n**lit-html is lazily rendered**. Calling this function will evaluate the template literal using lit-html html tag, and return a **TemplateResult** - a record of the template to render and data to render it with. TemplateResults are very cheap to produce and no real work actually happens until they are rendered to the DOM.\n\n### Rendering\nTo render a TemplateResult, call the ```render()``` function with a result and DOM container to render to:\n\n```\nconst result = myTemplate({title: 'Hello', body: 'lit-html is cool'});\nrender(result, document.body);\n```\n\n","references":"- [lit-html project](https://lit-html.polymer-project.org/guide)\n- [Example LitElement project](https://github.com/PolymerLabs/start-lit-element)\n- [lit-element project](https://lit-element.polymer-project.org/)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"lit-element-lit-html-introduction","weblink":"https://codersnack.com/lit-element-lit-html-introduction/","featured_image_preview":{"id":77,"name":"web-components.png","hash":"91105265032d4d708a7dd33c29c9a317","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/91105265032d4d708a7dd33c29c9a317.png","provider":"local","provider_metadata":null,"created_at":"2020-03-30T13:59:50.457Z","updated_at":"2020-03-30T13:59:50.457Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - lit-element lit-html introduction","created_at":"2020-03-30T14:00:49.913Z","updated_at":"2020-03-30T14:00:49.919Z"},{"id":59,"codersnack":{"id":60,"header":"LitElement Templates I","created_at":"2020-03-31T08:59:29.566Z","updated_at":"2020-03-31T08:59:29.566Z","explanation":"Add a template to your component to define internal DOM to implement your component.\n\nTo encapsulate the templated DOM LitElement uses **shadow DOM**. Shadow DOM provides three benefits:\n\n- **DOM scoping**. DOM APIs like document.querySelector won’t find elements in the component’s shadow DOM, so it’s harder for global scripts to accidentally break your component.\n- **Style scoping**. You can write encapsulated styles for your shadow DOM that don’t affect the rest of the DOM tree.\n- **Composition**. The component’s shadow DOM (managed by the component) is separate from the component’s children. You can choose how children are rendered in your templated DOM. Component users can add and remove children using standard DOM APIs without accidentally breaking anything in your shadow DOM.\n\nWhere native shadow DOM isn’t available, LitElement uses the **Shady CSS polyfill**.\n\n### Define and render a template\nTo define a template for a LitElement component, write a render function for your element class:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>template content</p>`;\n  }\n}\n```\n\nWrite your template in HTML inside a JavaScript template literal by enclosing the raw HTML in back-ticks (``).\n\n**Tag your template literal with the html tag function**.\n\nThe component’s render method can return anything that lit-html can render. Typically, **it returns a single TemplateResult object** (the same type returned by the html tag function).\n\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n\n  // Implement `render` to define a template for your element.\n  render(){\n    /**\n     * Return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function.\n     */\n    return html`\n      <div>\n        <p>A paragraph</p>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n**LitElement uses lit-html templates**; this page summarizes the features of lit-html templates, for more details, see Writing templates and the Template syntax reference in the lit-html documentation.\n\n### Design a performant template\n**LitElement renders and re-renders asynchronously, updating in response to batched property changes** (see Element update lifecycle for more information).\n\n**During an update, only the parts of the DOM that change are re-rendered**. To get the performance benefits of this model, **you should design your element's template as a pure function of its properties**.\n\nTo do this, make sure the render function:\n\n- Does not change the element’s state.\n- Does not have any side effects.\n- Only depends on the element’s properties.\n- Returns the same result when given the same property values.\n- Also, avoid making DOM updates outside of render. Instead, express the element’s template as a function of its state, and capture its state in properties.\n\nThe following code uses inefficient DOM manipulation:\n\n**dom-manip.js**\n\n```\n// Anti-pattern. Avoid!\n\nconstructor() {\n  super();\n  this.addEventListener('stuff-loaded', (e) => {\n    this.shadowRoot.getElementById('message').innerHTML=e.detail;\n  });\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p id=\"message\">Loading</p>\n  `;\n}\n```\n\nWe can improve the template by capturing the load message as a property, and setting the property in response to the event:\n\n**update-properties.js**\n\n```\nconstructor() {\n  super();\n  this.message = 'Loading';\n  this.addEventListener('stuff-loaded', (e) => { this.message = e.detail } );\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p>${this.message}</p>\n  `;\n}\n```\n\n### Use properties, loops, and conditionals in a template\nWhen defining your element's template, you can **bind the element's properties to the template; the template is re-rendered whenever the properties change.**\n\n##### Properties\nTo add a property value to a template, insert it with ```${this.propName}```:\n\n```\nstatic get properties() {\n  return { myProp: String };\n}\n...\nrender() {\n  return html`<p>${this.myProp}</p>`;\n}\n```\n\n##### Loops\nIterate over an array:\n\n```\nhtml`<ul>\n  ${this.myArray.map(i => html`<li>${i}</li>`)}\n</ul>`;\n```\n##### Conditionals\nRender based on a Boolean condition:\n\n```\nhtml`\n  ${this.myBool?\n    html`<p>Render some HTML if myBool is true</p>`:\n    html`<p>Render some other HTML if myBool is false</p>`}\n`;\n```\n**Examples**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      myString: { type: String },\n      myArray: { type: Array },\n      myBool: { type: Boolean }\n    };\n  }\n  constructor() {\n    super();\n    this.myString = 'Hello World';\n    this.myArray = ['an','array','of','test','data'];\n    this.myBool = true;\n  }\n  render() {\n    return html`\n      <p>${this.myString}</p>\n      <ul>\n        ${this.myArray.map(i => html`<li>${i}</li>`)}\n      </ul>\n      ${this.myBool?\n        html`<p>Render some HTML if myBool is true</p>`:\n        html`<p>Render some other HTML if myBool is false</p>`}\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"webcomponents-litelement-templates","weblink":"https://codersnack.com/webcomponents-litelement-templates/","featured_image_preview":{"id":78,"name":"web-components.png","hash":"b173f34ef15a4e6581f97d99714e591a","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/b173f34ef15a4e6581f97d99714e591a.png","provider":"local","provider_metadata":null,"created_at":"2020-03-31T08:59:29.594Z","updated_at":"2020-03-31T08:59:29.594Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates","created_at":"2020-03-31T09:00:01.890Z","updated_at":"2020-03-31T09:00:01.897Z"}]