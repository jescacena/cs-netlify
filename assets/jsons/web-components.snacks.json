[{"id":53,"codersnack":{"id":54,"header":"Introduction to Web Components","created_at":"2020-02-29T11:06:51.993Z","updated_at":"2020-02-29T21:31:43.928Z","explanation":"### What are Web Components, anyway?\n\nWeb Components consist of **three separate technologies that are used together:**\n\n- **Custom Elements**. Quite simply, these are fully-valid HTML elements with custom templates, behaviors and tag names (e.g. ```<one-dialog>```) made with a set of JavaScript APIs. Custom Elements are defined in the *HTML Living Standard specification*.\n- **Shadow DOM**. Capable of isolating CSS and JavaScript, almost like an ```<iframe>```. This is defined in the *Living Standard DOM specification*.\n- **HTML templates**. User-defined templates in HTML that aren't rendered until called upon. The ```<template>``` tag is defined in the *HTML Living Standard specification*.\n\nThese are what make up the *Web Components specification*.\n\n> **HTML Modules** is likely to be the fourth technology in the stack, but it has yet to be implemented in any of the big four browsers. The Chrome team has announced it an intent to implement them in a future release.\n\n**Web Components are generally available in all of the major browsers** with the exception of Microsoft Edge and Internet Explorer 11, but polyfills exist to fill in those gaps.\n\nReferring to any of these as Web Components is technically accurate because the term itself is a bit overloaded. As a result, each of the technologies can be used independently or combined with any of the others. In other words, they are not mutually exclusive.\n\n### Custom elements\nAs the name implies, **custom elements are HTML elements,** like ```<div>```, ```<section>``` or ```<article>```, but something **we can name ourselves that are defined via a browser API**. Custom elements are just like those standard HTML elements — names in angle brackets — except **they always have a dash in them**, like ```<news-slider>``` or ```<bacon-cheeseburger>```. Going forward, browser vendors have committed not to create new built-in elements containing a dash in their names to prevent conflicts.\n\nCustom elements contain their own semantics, behaviors, markup and can be shared across frameworks and browsers.\n```\nclass MyComponent extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `<h1>Hello world</h1>`;\n  }\n}\ncustomElements.define('my-component', MyComponent);\n```\n![Custom Elements](https://codersnack.com/assets/images/web-components-custom-elements.png)\n\nIn this example, we define ```<my-component>```, our very own HTML element. Admittedly, it doesn’t do much, however this is the basic building block of a custom element. **All custom elements must in some way extend an HTMLElement in order to be registered with the browser.**\n\n**Custom elements exist without third-party frameworks** and the browser vendors are dedicated to the continued backward compatibility of the spec, all but guaranteeing that components written according to the specifications will not suffer from breaking API changes. What’s more, **these components can generally be used out-of-the-box with today’s most popular frameworks**, including Angular, React, Vue, and others with minimal effort.\n\n### Shadow DOM\n**The shadow DOM is an encapsulated version of the DOM**. This allows authors to effectively isolate DOM fragments from one another, including anything that could be used as a CSS selector and the styles associated with them. Generally, any content inside of the document's scope is referred to as the light DOM, and anything inside a shadow root is referred to as the shadow DOM.\n\nImagine the following scenario:\n```\n<div>\n  <div id=\"example\">\n    <!-- Pseudo-code used to designate a shadow root -->\n    <#shadow-root>\n      <style>\n      button {\n        background: tomato;\n        color: white;\n      }\n      </style>\n      <button id=\"button\">This will use the CSS background tomato</button>\n    </#shadow-root>\n  </div>\n  <button id=\"button\">Not tomato</button>\n</div>\n```\nAside from the pseudo-code of ```<#shadow-root>``` (which is used here to demarcate the shadow boundary which has no HTML element), the HTML is fully valid. To attach a shadow root to the node above, we would run something like:\n\n```\nconst shadowRoot = document.getElementById('example').attachShadow({ mode: 'open' });\nshadowRoot.innerHTML = `<style>\nbutton {\n  color: tomato;\n}\n</style>\n<button id=\"button\">This will use the CSS color tomato <slot></slot></button>`;\n```\nA shadow root can also include content from its containing document by using the ```<slot>``` element. **Using a slot will drop user content from the outer document at a designated spot in your shadow root**.\n\n### HTML templates\nThe aptly-named HTML ```<template>```  element allows us to stamp out **re-usable templates of code inside a normal HTML flow that won't be immediately rendered, but can be used at a later time**.\n\n```\n<template id=\"book-template\">\n  <li><span class=\"title\"></span> &mdash; <span class=\"author\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\nThe example above wouldn’t render any content until a script has consumed the template, instantiated the code and told the browser what to do with it.\n\n```\nconst fragment = document.getElementById('book-template');\nconst books = [\n  { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald' },\n  { title: 'A Farewell to Arms', author: 'Ernest Hemingway' },\n  { title: 'Catch 22', author: 'Joseph Heller' }\n];\n\nbooks.forEach(book => {\n  // Create an instance of the template content\n  const instance = document.importNode(fragment.content, true);\n  // Add relevant content to the template\n  instance.querySelector('.title').innerHTML = book.title;\n  instance.querySelector('.author').innerHTML = book.author;\n  // Append the instance ot the DOM\n  document.getElementById('books').appendChild(instance);\n});\n```\n\nNotice that this example creates a template (```<template id=\"book-template\">```) without any other Web Components technology, illustrating again that **the three technologies in the stack can be used independently or collectively**.\n\nOstensibly, the consumer of a service that utilizes the template API could write a template of any shape or structure that could be created at a later time. Another page on a site might use the same service, but structure the template this way:\n\n```\n<template id=\"book-template\">\n  <li><span class=\"author\"></span>'s classic novel <span class=\"title\"></span></li>\n</template>\n\n<ul id=\"books\"></ul>\n```\n","references":"- [CSS trick - Calleb Williams - Introduction to web components](https://css-tricks.com/an-introduction-to-web-components/)\n- [HTML Living Standard specification](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements)\n- [Living Standard DOM specification](https://dom.spec.whatwg.org/#shadow-trees)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-introduction","weblink":"https://codersnack.com/web-components-introduction/","featured_image_preview":{"id":70,"name":"web-components.png","hash":"bb73ea6081f440319172079b80849d32","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/bb73ea6081f440319172079b80849d32.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T11:06:52.003Z","updated_at":"2020-02-29T11:06:52.003Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web components introduction","created_at":"2020-02-29T11:07:25.496Z","updated_at":"2020-02-29T11:07:25.500Z"},{"id":58,"codersnack":{"id":59,"header":"LitElement and lit-html Introduction","created_at":"2020-03-30T13:59:50.431Z","updated_at":"2020-04-14T15:08:28.972Z","explanation":"### What is LitElement?\n\n**LitElement** is a **simple base class for creating fast, lightweight web components** that work in any web page with any framework.\n\n**LitElement uses lit-html to render into shadow DOM**, and **adds API to manage properties and attributes**. *Properties are observed by default, and elements update asynchronously when their properties change*.\n\n### Setup\n**You need npm and Node.js** to work with LitElement.\n\n**LitElement uses JavaScript modules to import dependencies** by their npm package names. Since web browsers need to know a file's full URL to import it, your local development server needs to serve full, transformed URL paths to your web browser.\n\n**To deploy an optimized build** that works on your target browsers, you’ll also **need a build toolset** that can handle this transform, along with any bundling.\n\n**One option is Polymer CLI**, which includes a development server that converts module names to paths on the fly; and a configurable build tool that packages your code for deployment.\n\nTo install Polymer CLI with npm:\n```\nnpm install -g polymer-cli\n```\nTo serve a LitElement project locally:\n\n```\npolymer serve\n```\nSee the Polymer CLI documentation for more information on configuring these tools.\n\n\n### Create a LitElement component\nTo create a new class based on LitElement:\n\nIn your project folder, install the lit-element package from npm:\n\n```\nnpm install lit-element\n```\n\nWrite your new element:\n\n- Import the LitElement base class and the html helper function.\n- Create a new class that extends the LitElement base class.\n- Implement render to define a template for your web component.\n- Register your component’s HTML tag with the browser.\n\n*Example*\n\n**my-element.js**\n\n```\n// Import the LitElement base class and html helper function\nimport { LitElement, html } from 'lit-element';\n\n// Extend the LitElement base class\nclass MyElement extends LitElement {\n\n  /**\n   * Implement `render` to define a template for your element.\n   *\n   * You must provide an implementation of `render` for any element\n   * that uses LitElement as a base class.\n   */\n  render(){\n    /**\n     * `render` must return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function:\n     */\n    return html`\n      <!-- template content -->\n      <p>A paragraph</p>\n    `;\n  }\n}\n// Register the new element with the browser.\ncustomElements.define('my-element', MyElement);\n```\n\n### Use LitElement TypeScript decorators\nYou can use the **@customElement TypeScript decorator** to define your class as a custom element:\n\n```\n/**\n * Import LitElement base class, html helper function,\n * and TypeScript decorators\n **/\nimport {\n  LitElement, html, customElement, property\n} from 'lit-element';\n\n/**\n * Use the customElement decorator to define your class as\n * a custom element. Registers <my-element> as an HTML tag.\n */\n@customElement('my-element')\nexport class MyElement extends LitElement {\n\n  /**\n   * Create an observed property. Triggers update on change.\n   */\n  @property()\n  foo = 'foo';\n\n  /**\n   * Implement `render` to define a template for your element.\n   */\n  render(){\n    /**\n     * Use JavaScript expressions to include property values in\n     * the element template.\n     */\n    return html`<p>${this.foo}</p>`;\n  }\n}\n```\n\n### Import a component\nImport your own LitElement component\nIn an HTML document:\n\n```\n<head>\n  <script type=\"module\" src=\"/path/to/my-element.js\"></script>\n</head>\n<body>\n  <my-element></my-element>\n</body>\n```\n\nIn another JavaScript module:\n\n```\n// Use relative paths for peer dependencies\nimport './my-element.js';\n\nclass MyOtherElement extends LitElement{\n  render(){\n    return html`\n      <my-element></my-element>\n    `;\n  }\n}\ncustomElements.define('my-other-element', MyOtherElement);\n```\n### Import a third-party LitElement component\nRefer to third-party component documentation first. To work with any existing component made by a third party, see its documentation. This guide should work for most LitElement-based components if they are published on npm.\n\nMany components are published on npm and can be installed from the command line:\n\n```\ncd my-project-folder\nnpm install package-name\n```\nIn an HTML document, a component published on npm can be imported from the node_modules folder:\n\n```\n<head>\n  <script type=\"module\" src=\"node_modules/package-name/existing-element.js\"></script>\n</head>\n<body>\n  <existing-element></existing-element>\n</body>\n```\nTo import into another JavaScript module, use the component’s package name:\n\n```\nimport 'package-name/existing-element.js';\n\nclass MyElement extends LitElement{\n  render(){\n    return html`\n      <existing-element></existing-element>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### What is lit-html?\nlit-html is a simple, modern, safe, small and fast **HTML templating library for JavaScript.**\n\nlit-html lets you write HTML templates in JavaScript using **template literals with embedded JavaScript expressions**. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.\n\nBuilding components? **lit-html is not tied to any component model**, it focuses only on creating and updating DOM. If you want to build components, check out **LitElement**, a library for building web components using lit-html templates.\n\n### lit-html Templates\nlit-html templates are **tagged template literals** - they look like JavaScript strings but are enclosed in backticks (`) instead of quotes - and tagged with lit-html's html tag:\n\n```\nhtml`<h1>Hello ${name}</h1>`\n```\nSince lit-html templates almost always need to merge in data from JavaScript values, and be able to update DOM when that data changes, they'll most often be written within functions that take some data and return a lit-html template, so that the function can be called multiple times:\n\n```\nlet myTemplate = (data) => html`\n  <h1>${data.title}</h1>\n  <p>${data.body}</p>`;\n```\n**lit-html is lazily rendered**. Calling this function will evaluate the template literal using lit-html html tag, and return a **TemplateResult** - a record of the template to render and data to render it with. TemplateResults are very cheap to produce and no real work actually happens until they are rendered to the DOM.\n\n### Rendering\nTo render a TemplateResult, call the ```render()``` function with a result and DOM container to render to:\n\n```\nconst result = myTemplate({title: 'Hello', body: 'lit-html is cool'});\nrender(result, document.body);\n```\n\n","references":"- [lit-html project](https://lit-html.polymer-project.org/guide)\n- [Example LitElement project](https://github.com/PolymerLabs/start-lit-element)\n- [lit-element project](https://lit-element.polymer-project.org/)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"lit-element-lit-html-introduction","weblink":"https://codersnack.com/lit-element-lit-html-introduction/","featured_image_preview":{"id":95,"name":"litelement-icon.png","hash":"06b6d9e7bfb645fa926460601fc692d2","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/06b6d9e7bfb645fa926460601fc692d2.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:28.984Z","updated_at":"2020-04-14T15:08:28.984Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - lit-element lit-html introduction","created_at":"2020-03-30T14:00:49.913Z","updated_at":"2020-03-30T14:00:49.919Z"},{"id":59,"codersnack":{"id":60,"header":"LitElement Templates 1","created_at":"2020-03-31T08:59:29.566Z","updated_at":"2020-04-14T15:08:15.088Z","explanation":"Add a template to your component to define internal DOM to implement your component.\n\nTo encapsulate the templated DOM LitElement uses **shadow DOM**. Shadow DOM provides three benefits:\n\n- **DOM scoping**. DOM APIs like document.querySelector won’t find elements in the component’s shadow DOM, so it’s harder for global scripts to accidentally break your component.\n- **Style scoping**. You can write encapsulated styles for your shadow DOM that don’t affect the rest of the DOM tree.\n- **Composition**. The component’s shadow DOM (managed by the component) is separate from the component’s children. You can choose how children are rendered in your templated DOM. Component users can add and remove children using standard DOM APIs without accidentally breaking anything in your shadow DOM.\n\nWhere native shadow DOM isn’t available, LitElement uses the **Shady CSS polyfill**.\n\n### Define and render a template\nTo define a template for a LitElement component, write a render function for your element class:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>template content</p>`;\n  }\n}\n```\n\nWrite your template in HTML inside a JavaScript template literal by enclosing the raw HTML in back-ticks (``).\n\n**Tag your template literal with the html tag function**.\n\nThe component’s render method can return anything that lit-html can render. Typically, **it returns a single TemplateResult object** (the same type returned by the html tag function).\n\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n\n  // Implement `render` to define a template for your element.\n  render(){\n    /**\n     * Return a lit-html `TemplateResult`.\n     *\n     * To create a `TemplateResult`, tag a JavaScript template literal\n     * with the `html` helper function.\n     */\n    return html`\n      <div>\n        <p>A paragraph</p>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n**LitElement uses lit-html templates**; this page summarizes the features of lit-html templates, for more details, see Writing templates and the Template syntax reference in the lit-html documentation.\n\n### Design a performant template\n**LitElement renders and re-renders asynchronously, updating in response to batched property changes** (see Element update lifecycle for more information).\n\n**During an update, only the parts of the DOM that change are re-rendered**. To get the performance benefits of this model, **you should design your element's template as a pure function of its properties**.\n\nTo do this, make sure the render function:\n\n- Does not change the element’s state.\n- Does not have any side effects.\n- Only depends on the element’s properties.\n- Returns the same result when given the same property values.\n- Also, avoid making DOM updates outside of render. Instead, express the element’s template as a function of its state, and capture its state in properties.\n\nThe following code uses inefficient DOM manipulation:\n\n**dom-manip.js**\n\n```\n// Anti-pattern. Avoid!\n\nconstructor() {\n  super();\n  this.addEventListener('stuff-loaded', (e) => {\n    this.shadowRoot.getElementById('message').innerHTML=e.detail;\n  });\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p id=\"message\">Loading</p>\n  `;\n}\n```\n\nWe can improve the template by capturing the load message as a property, and setting the property in response to the event:\n\n**update-properties.js**\n\n```\nconstructor() {\n  super();\n  this.message = 'Loading';\n  this.addEventListener('stuff-loaded', (e) => { this.message = e.detail } );\n  this.loadStuff();\n}\nrender() {\n  return html`\n    <p>${this.message}</p>\n  `;\n}\n```\n\n### Use properties, loops, and conditionals in a template\nWhen defining your element's template, you can **bind the element's properties to the template; the template is re-rendered whenever the properties change.**\n\n##### Properties\nTo add a property value to a template, insert it with ```${this.propName}```:\n\n```\nstatic get properties() {\n  return { myProp: String };\n}\n...\nrender() {\n  return html`<p>${this.myProp}</p>`;\n}\n```\n\n##### Loops\nIterate over an array:\n\n```\nhtml`<ul>\n  ${this.myArray.map(i => html`<li>${i}</li>`)}\n</ul>`;\n```\n##### Conditionals\nRender based on a Boolean condition:\n\n```\nhtml`\n  ${this.myBool?\n    html`<p>Render some HTML if myBool is true</p>`:\n    html`<p>Render some other HTML if myBool is false</p>`}\n`;\n```\n**Examples**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      myString: { type: String },\n      myArray: { type: Array },\n      myBool: { type: Boolean }\n    };\n  }\n  constructor() {\n    super();\n    this.myString = 'Hello World';\n    this.myArray = ['an','array','of','test','data'];\n    this.myBool = true;\n  }\n  render() {\n    return html`\n      <p>${this.myString}</p>\n      <ul>\n        ${this.myArray.map(i => html`<li>${i}</li>`)}\n      </ul>\n      ${this.myBool?\n        html`<p>Render some HTML if myBool is true</p>`:\n        html`<p>Render some other HTML if myBool is false</p>`}\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates","weblink":"https://codersnack.com/webcomponents-litelement-templates/","featured_image_preview":{"id":94,"name":"litelement-icon.png","hash":"b3ca5cab6412452092f10c43a1ab61c3","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/b3ca5cab6412452092f10c43a1ab61c3.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:15.101Z","updated_at":"2020-04-14T15:08:15.101Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates","created_at":"2020-03-31T09:00:01.890Z","updated_at":"2020-03-31T09:00:01.897Z"},{"id":60,"codersnack":{"id":61,"header":"LitElement Templates 2","created_at":"2020-03-31T14:13:31.829Z","updated_at":"2020-04-14T15:08:01.179Z","explanation":"### Bind properties to templated elements\nYou can insert JavaScript expressions as placeholders for HTML text content, attributes, Boolean attributes, properties, and event handlers.\n\n- Text content: ```<p>${...}</p>```\n- Attribute: ```<p id=\"${...}\"></p>```\n- Boolean attribute: ```?disabled=\"${...}\"```\n- Property: ```.value=\"${...}\"```\n- Event handler: ```@event=\"${...}\"```\n\nJavaScript expressions can include your element's properties. **LitElement observes and reacts to property changes, so your templates update automatically**.\n\n**Data bindings are always one-way (parent to child)**. \n> To share data from a child element to its parent, fire an event and capture the relevant data in the detail property**.\n\n#### Bind to text content\nBind prop1 to text content:\n\n```\nhtml`<div>${this.prop1}</div>`\n```\n#### Bind to an attribute\nBind prop2 to an attribute:\n\n```\nhtml`<div id=\"${this.prop2}\"></div>`\n```\nAttribute values are always strings, so an **attribute binding should return a value that can be converted into a string**.\n\n#### Bind to a boolean attribute\nBind prop3 to a boolean attribute:\n\n```\nhtml`<input type=\"text\" ?disabled=\"${this.prop3}\">`\n```\nBoolean attributes are added if the expression evaluates to a truthy value, and removed if it evaluates to a falsy value.\n\n#### Bind to a property\nBind prop4 to a property:\n\n```\nhtml`<input type=\"checkbox\" .value=\"${this.prop4}\"/>`\n```\n\n#### Bind to an event handler\nBind clickHandler to a click event:\n\n```\nhtml`<button @click=\"${this.clickHandler}\">pie?</button>`\n```\nThe default event context for ```@event``` expressions is this, so **there is no need to bind the handler function**.\n\n**Examples**\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: String,\n      prop2: String,\n      prop3: Boolean,\n      prop4: String\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 'text binding';\n    this.prop2 = 'mydiv';\n    this.prop3 = true;\n    this.prop4 = 'pie';\n  }\n  render() {\n    return html`\n      <!-- text binding -->\n      <div>${this.prop1}</div>\n\n      <!-- attribute binding -->\n      <div id=\"${this.prop2}\">attribute binding</div>\n\n      <!-- boolean attribute binding -->\n      <div>\n        boolean attribute binding\n        <input type=\"text\" ?disabled=\"${this.prop3}\"/>\n      </div>\n\n      <!-- property binding -->\n      <div>\n        property binding\n        <input type=\"text\" .value=\"${this.prop4}\"/>\n      </div>\n\n      <!-- event handler binding -->\n      <div>event handler binding\n        <button @click=\"${this.clickHandler}\">click</button>\n      </div>\n    `;\n  }\n  clickHandler(e) {\n    console.log(e.target);\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n\n### Render children with the slot element\nYour component may accept children (like a ```<ul>``` element can have ```<li>``` children).\n\n```\n<my-element>\n  <p>A child</p>\n</my-element>\n```\n\n**By default, if an element has a shadow tree, its children don't render at all. To render children, your template needs to include one or more ```<slot>``` elements, which act as placeholders for child nodes.**\n\n### Use the slot element\nTo render an element's children, create a ```<slot>``` for them in the element's template. For example:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot></slot>\n    </div>\n  `;\n}\n```\nChildren will now render in the ```<slot>```:\n\n```\n<my-element>\n  <p>Render me</p>\n</my-element>\n```\nThe children aren't moved in the DOM tree, but they’re rendered as if they were children of the ```<slot>```.\n\nArbitrarily many children can populate a single slot:\n\n```\n<my-element>\n  <p>Render me</p>\n  <p>Me too</p>\n  <p>Me three</p>\n</my-element>\n```\n\n### Use named slots\nTo assign a child to a specific slot, ensure that the child's slot attribute matches the slot's name attribute:\n\n```\nrender(){\n  return html`\n    <div>\n      <slot name=\"one\"></slot>\n    </div>\n  `;\n}\n```\n**index.html**\n\n```\n<my-element>\n  <p slot=\"one\">Include me in slot \"one\".</p>\n</my-element>\n```\nNamed slots only accept children with a matching slot attribute.\n\nFor example, ```<slot name=\"one\"></slot>``` only accepts children with the attribute ```slot=\"one\"```.\n\nChildren with a slot attribute will only be rendered in a slot with a matching name attribute.\n\nFor example, ```<p slot=\"one\">...</p>``` will only be placed in ```<slot name=\"one\"></slot>```.\n\n**Examples**\n\n*my-element.js*\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render(){\n    return html`\n      <div>\n        <slot name=\"one\"></slot>\n        <slot name=\"two\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*index.html*\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js\"></script>\n  <script src=\"/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js\"></script>\n  \n  <script type=\"module\" src=\"./my-element.js\"></script>\n  <title>lit-element code sample</title>\n</head>\n<body>\n    <!-- Assign child to a specific slot -->\n\n    <my-element>\n      <p slot=\"two\">Include me in slot \"two\".</p>\n    </my-element>\n\n    <!-- \n      Named slots only accept children with a matching `slot` attribute. \n      \n      Children with a `slot` attribute can only go into a slot with a matching name. \n    -->\n\n    <my-element>\n      <p slot=\"one\">Include me in slot \"one\".</p>\n      <p slot=\"nope\">This one will not render at all.</p>\n      <p>No default slot, so this one won't render either.</p>\n    </my-element>\n</body>\n</html>\n```\n\n### Use name, not id, to select slots.\n\nNote that a slot’s id attribute has no effect!\n\n*my-element.js*\n\n```\nrender(){\n  return html`\n    <div>\n      <slot id=\"one\"></slot>\n    </div>\n  `;\n}\n```\n\n*index.html*\n\n```\n<my-element>\n  <p slot=\"one\">nope.</p>\n  <p>ohai..</p>\n</my-element>\n```","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates-2","weblink":"https://codersnack.com/webcomponents-litelement-templates-2/","featured_image_preview":{"id":93,"name":"litelement-icon.png","hash":"37397228be82426aba418750bb5b0e7a","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/37397228be82426aba418750bb5b0e7a.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:08:01.192Z","updated_at":"2020-04-14T15:08:01.192Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Templates II","created_at":"2020-03-31T14:13:56.568Z","updated_at":"2020-03-31T14:13:56.572Z"},{"id":61,"codersnack":{"id":62,"header":"LitElement Templates 3","created_at":"2020-03-31T14:33:50.941Z","updated_at":"2020-04-14T15:07:30.838Z","explanation":"### Compose a template from other templates\nYou can compose LitElement templates from other LitElement templates. In the following example, we compose a template for an element called ```<my-page>``` from smaller templates for the standard HTML elements ```<header>```, ```<article>```, and ```<footer>```:\n\n```\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      ${this.headerTemplate}\n      ${this.articleTemplate}\n      ${this.footerTemplate}\n    `;\n  }\n  get headerTemplate() {\n    return html`<header>header</header>`;\n  }\n  get articleTemplate() {\n    return html`<article>article</article>`;\n  }\n  get footerTemplate() {\n    return html`<footer>footer</footer>`;\n  }\n}\n```\nYou can also compose templates by importing other elements and using them in your template:\n\n```\nimport './my-header.js';\nimport './my-article.js';\nimport './my-footer.js';\n\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      <my-header></my-header>\n      <my-article></my-article>\n      <my-footer></my-footer>\n    `;\n  }\n}\n```\n\n### Specify the render root\n**The node into which your component's template will render is called its render root**.\n\n**By default, LitElement creates an open shadowRoot and renders inside it,** producing the following DOM structure:\n\n```\n<my-element>\n  #shadow-root\n    <p>child 1</p>\n    <p>child 2</p>\n```\n\nTo customize a component's render root, implement **createRenderRoot** and return the node you want the template to render into.\n\nFor example, to render the template into the main DOM tree as your element's children:\n\n```\n<my-element>\n  <p>child 1</p>\n  <p>child 2</p>\n```\nImplement createRenderRoot and return this:\n\n```\nclass LightDom extends LitElement {\n  render() {\n    return html`\n      <p>This template renders without shadow DOM.</p>\n    `;\n  }\n  createRenderRoot() {\n  /**\n   * Render template without shadow DOM. Note that shadow DOM features like \n   * encapsulated CSS and slots are unavailable.\n   */\n    return this;\n  }\n}\n```\n\n### Using other lit-html features\nSince **LitElement uses the lit-html html tag function to define templates** you can take advantage of the entire lit-html feature set for writing your templates. This includes lit-html directives, special functions that customize the way lit-html renders a binding.\n\n**To import features directly from lit-html, your project should add lit-html as a direct dependency**. We recommend using the widest practical version range for lit-html, to minimize the chance of npm installing two different versions of lit-html:\n\n```\nnpm i lit-element@^2.0.0\nnpm i lit-html@^1.0.0\n```\n#### Import and use a lit-html directive\nYou can import and use a lit-html directive and use it as shown in the lit-html documentation.\n\n```\nimport { LitElement, html } from 'lit-element';\nimport { until } from 'lit-html/directives/until.js';\n\nconst content = fetch('./content.txt').then(r => r.text());\n\nhtml`${until(content, html`<span>Loading...</span>`)}`\n```\nFor a list of directives supplied with lit-html, see Built-in directives in the Template syntax reference.\n","references":"- [LitElement Templates](https://lit-element.polymer-project.org/guide/templates)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-templates-3","weblink":"https://codersnack.com/webcomponents-litelement-templates-3/","featured_image_preview":{"id":91,"name":"litelement-icon.png","hash":"84ac11553a3f4f228ba6fc881c25bf10","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/84ac11553a3f4f228ba6fc881c25bf10.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:30.851Z","updated_at":"2020-04-14T15:07:30.851Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component LitElement Templates 3","created_at":"2020-03-31T14:34:33.187Z","updated_at":"2020-03-31T14:34:33.191Z"},{"id":62,"codersnack":{"id":63,"header":"LitElement Properties 1","created_at":"2020-03-31T15:08:19.241Z","updated_at":"2020-04-14T15:07:45.096Z","explanation":"### Overview\n**LitElement manages your declared properties and their corresponding attributes**. By default, LitElement will:\n\n- Ensure that an **element update is scheduled when any declared property changes**.\n- Capture instance values for declared properties. Apply any property values that are set before the browser registers a custom element definition.\n- **Set up an observed (not reflected) attribute** with the lowercased name of each property.\n- **Handle attribute conversion** for properties declared as type String, Number, Boolean, Array, and Object.\n- Use **direct comparison (oldValue !== newValue) to test for property changes**.\n- Apply any property options and accessors declared by a superclass.\n\n> Remember to declare all of the properties that you want LitElement to manage. For the property features above to be applied, you must declare the property.\n\n### Property options\nA property declaration is an object in the following format:\n```\n{ optionName1: optionValue1, optionName2: optionValue2, ... }\n```\n\nThe following options are available:\n\n- **converter**: Convert between properties and attributes.\n- **type**: Use LitElement’s default attribute converter.\n- **attribute**: Configure **observed** attributes.\n- **reflect**: Configure **reflected** attributes.\n- **noAccessor**: Whether to set up a default property accessor.\n- **hasChanged**: Specify what constitutes a property change.\n\n> All property declaration options can be specified in a static properties getter, or with TypeScript decorators.\n\n### Declare properties\nDeclare your element’s properties by implementing a static properties getter, or by using decorators:\n\n```\n// properties getter\nstatic get properties() {\n  return { \n    prop1: { type: String }\n  };\n}\n// Decorators (requires TypeScript or Babel)\nexport class MyElement extends LitElement {\n  @property( { type : String }  ) prop1 = '';\n```\n\n#### Declare properties in a static properties getter\nTo declare properties in a static properties getter:\n\n```\nstatic get properties() { \n  return { \n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean }\n  };\n}\n```\n\nIf you implement a static properties getter, initialize your property values in the element constructor.\n\n```\nconstructor() {\n  // Always call super() first\n  super();\n  this.prop1 = 'Hello World';\n  ...\n}\n```\n> Remember to call ```super()``` first in your constructor, or your element won’t render at all.\n\n**Example**: Declare properties with a static properties getter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = false;\n    this.prop4 = [1,2,3];\n    this.prop5 = { subprop1: 'prop 5 subprop1 value' }\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Declare properties with decorators\nYou can also declare properties with **decorators**:\n\n```\n@property({type : String})  prop1 = 'Hello World';\n```\n> Decorators are a proposed JavaScript feature, so you’ll need to use a transpiler like Babel or the TypeScript compiler to use decorators.\n\nIf you’re using Babel, you’ll need to use the ```@babel/plugin-proposal-decorators```  plugin.\n\nIf you’re using TypeScript, you’ll need to **enable the experimentalDecorators compiler option** (for example, by setting \"experimentalDecorators\": true in *tsconfig.json*). Enabling emitDecoratorMetadata is not required and not recommended.\n\n**Example**: Declare properties with decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'prop 5 subprop1 value' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n      <p>prop4[0]: ${this.prop4[0]}</p>\n      <p>prop5.subprop1: ${this.prop5.subprop1}</p>\n    `;\n  }\n}\n```\n\n#### Initialize property values\nInitialize property values in the element constructor\nIf you implement a static properties getter, initialize your property values in the element constructor:\n\n```\nstatic get properties() { return { /* Property declarations */ }; } \n\nconstructor() {\n  // Always call super() first\n  super();\n\n  // Initialize properties \n  this.prop1 = 'Hello World';\n}\n```\n> Remember to call super() first in your constructor, or your element won’t render at all.\n\n**Example**: Initialize property values in the element constructor\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String },\n    prop2: { type: Number },\n    prop3: { type: Boolean },\n    prop4: { type: Array },\n    prop5: { type: Object }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = 'Hello World';\n    this.prop2 = 5;\n    this.prop3 = true;\n    this.prop4 = [1,2,3];\n    this.prop5 = { stuff: 'hi', otherStuff: 'wow' };\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### Initialize property values when using TypeScript decorators\nTypeScript users can initialize property values when they are declared with the @property decorator:\n\n```\n@property({ type : String }) prop1 = 'Hello World';\n```\n**Example**: Initialize property values when using TypeScript decorators\n\n```\nimport { LitElement, html, customElement, property } from 'lit-element';\n\n@customElement('my-element')\nexport class MyElement extends LitElement {\n  // Declare and initialize properties\n  @property({type : String})  prop1 = 'Hello World';\n  @property({type : Number})  prop2 = 5;\n  @property({type : Boolean}) prop3 = true;\n  @property({type : Array})   prop4 = [1,2,3];\n  @property({type : Object})  prop5 = { subprop1: 'hi', thing: 'fasdfsf' };\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <p>prop3: ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n    `;\n  }\n}\n```\n\n#### Initialize property values from attributes in markup\nYou can also initialize property values from observed attributes in markup:\n\n*index.html*\n\n```\n<my-element \n  mystring=\"hello world\"\n  mynumber=\"5\"\n  mybool\n  myobj='{\"stuff\":\"hi\"}'\n  myarray='[1,2,3,4]'></my-element>\n```\n\nSee observed attributes and converting between properties and attributes for more information on setting up initialization from attributes.","references":"- [LitElement properties](https://lit-element.polymer-project.org/guide/properties)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-properties-1","weblink":"https://codersnack.com/webcomponents-litelement-properties-1/","featured_image_preview":{"id":92,"name":"litelement-icon.png","hash":"c591b268b2d142c7a416e5f1a2c4f06e","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/c591b268b2d142c7a416e5f1a2c4f06e.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:45.109Z","updated_at":"2020-04-14T15:07:45.109Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Properties 1","created_at":"2020-03-31T15:09:10.363Z","updated_at":"2020-03-31T15:09:10.368Z"},{"id":63,"codersnack":{"id":64,"header":"LitElement Properties 2","created_at":"2020-03-31T15:56:12.994Z","updated_at":"2020-04-14T15:07:15.496Z","explanation":"### Properties vs Attributes\nThe difference between properties and attributes can be confusing. **Properties are available on a DOM node** when being manipulated by JavaScript:\n\n```\nconst myElem = document.querySelector('.my-elem');\nmyElem.className; // className is a property\n```\nAnd **attributes are provided in the HTML itself**. Here alt, width and height are all attributes:\n```\n<img src=\"/path/to/img.svg\" alt=\"My Image\" width=\"150\" height=\"250\">\n```\n**Attributes should only be used for scalar values like strings, numbers and boolean values**. **Properties, on the other hand, are perfectly suited to also hold values that are objects or arrays**.\n\n### Reflecting Properties to Attributes\n**Most properties reflect their values as attributes, meaning that if the property is changed using JavaScript, the corresponding attribute is also changed at the same time to reflect the new value**. This is useful for accessibility and to allow CSS selectors to work as intended.\n\nYou can try it out yourself for a concrete example. Just select, say, an image element in your browser’s developer tools, and then change one of its properties:\n\n```\nconst fancyImage = document.querySelector('.fancy-image');\n\nfancyImage.width = 777;\n```\nNotice how the with attribute in the DOM representation is automatically changed to the new value. The same is true if you change the value for the attribute manually in the DOM inspector, you’ll see that the property will now hold the new value.\n\n![attributes-properties](https://codersnack.com/assets/images/attributes-properties.png)\n\n### Reflecting properties to attributes in Custom Elements\nYour own Custom Elements should also follow this practice of reflecting properties to attributes. Luckily, it's quite easy to do using getters and setters.\n\nFor example, if you have a custom element that has a value property that should be reflected as an attribute, here’s how you would use a getter and a setter to get the value of the attribute when doing property access and setting the new value for the attribute when the property is changed:\n\n```\nget value() {\n  return this.getAttribute('value');\n}\n\nset value(newValue) {\n  this.setAttribute('value', newValue);\n}\n```\nOr, if you have a boolean property, like, say hidden:\n\n```\nget hidden() {\n  return this.hasAttribute('hidden');\n}\n\nset hidden(isHidden) {\n  if (isHidden) {\n    this.setAttribute('hidden', '');\n  } else {\n    this.removeAttribute('hidden');\n  }\n}\n```\n\n### Configure attributes\n\n#### Convert between properties and attributes\n\n**While element properties can be of any type, attributes are always strings**. This impacts the observed attributes and reflected attributes of non-string properties:\n\nTo observe an attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type.\n\nTo reflect an attribute (set an attribute from a property), the property value must be converted to a string.\n\n#### Use the default converter\nLitElement has a default converter which handles String, Number, Boolean, Array, and Object property types.\n\n**To use the default converter, specify the type option in your property declaration**:\n```\n// Use LitElement's default converter \nprop1: { type: String },\nprop2: { type: Number },\nprop3: { type: Boolean },\nprop4: { type: Array },\nprop5: { type: Object }\n```\nThe information below shows how the default converter handles conversion for each type.\n\n#### Convert from attribute to property\n\n- For Strings, when the attribute is defined, set the property to the attribute value.\n- For Numbers, when the attribute is defined, set the property to Number(attributeValue).\n- For Booleans, when the attribute is:\n     non-null, set the property to true.\n     null or undefined, set the property to false.\n- For Objects and Arrays, when the attribute is:\n     Defined, set the property value to JSON.parse(attributeValue).\n\n#### Convert from property to attribute\n\n- For Strings, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Numbers, when the property is:\n    null, remove the attribute.\n    undefined, don’t change the attribute.\n    Defined and not null, set the attribute to the property value.\n- For Booleans, when the property is:\n    truthy, create the attribute.\n    falsy, remove the attribute.\n- For Objects and Arrays, when the property is:\n    null or undefined, remove the attribute.\n    Defined and not null, set the attribute value to JSON.stringify(propertyValue).\n\n**Example**: Use the default converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    prop1: { type: String, reflect: true },\n    prop2: { type: Number, reflect: true },\n    prop3: { type: Boolean, reflect: true },\n    prop4: { type: Array, reflect: true },\n    prop5: { type: Object, reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.prop1 = '';\n    this.prop2 = 0;\n    this.prop3 = false;\n    this.prop4 = [];\n    this.prop5 = { };\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    console.log('attribute change: ', name, newVal);\n    super.attributeChangedCallback(name, oldVal, newVal);\n  }\n\n  render() {\n    return html`\n      <p>prop1 ${this.prop1}</p>\n      <p>prop2 ${this.prop2}</p>\n      <p>prop3 ${this.prop3}</p>\n\n      <p>prop4: ${this.prop4.map((item, index) =>\n        html`<span>[${index}]:${item}&nbsp;</span>`)}\n      </p>\n\n      <p>prop5:\n        ${Object.keys(this.prop5).map(item =>\n          html`<span>${item}: ${this.prop5[item]}&nbsp;</span>`)}\n      </p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.getAttribute('prop3');\n\n    this.setAttribute('prop1', randy.toString());\n    this.setAttribute('prop2', randy.toString());\n    this.setAttribute('prop3', myBool? '' : null);\n    this.setAttribute('prop4', JSON.stringify([...this.prop4, randy]));\n    this.setAttribute('prop5',\n      JSON.stringify(Object.assign({}, this.prop5, {[randy]: randy})));\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randy = Math.floor(Math.random()*10);\n    let myBool = this.prop3;\n\n    this.prop1 = randy.toString();\n    this.prop2 = randy;\n    this.prop3 = !myBool;\n    this.prop4 = [...this.prop4, randy];\n    this.prop5 = Object.assign({}, this.prop5, {[randy]: randy});\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Configure a custom converter\nYou can specify a custom property converter in your property declaration with the converter option:\n\n```\nmyProp: { \n  converter: // Custom property converter\n} \n```\nconverter can be an object or a function. If it is an object, it can have keys for fromAttribute and toAttribute:\n\n```\nprop1: { \n  converter: { \n    fromAttribute: (value, type) => { \n      // `value` is a string\n      // Convert it to a value of type `type` and return it\n    },\n    toAttribute: (value, type) => { \n      // `value` is of type `type` \n      // Convert it to a string and return it\n    }\n  }\n}\n```\nIf converter is a function, it is used in place of fromAttribute:\n\n```\nmyProp: { \n  converter: (value, type) => { \n    // `value` is a string\n    // Convert it to a value of type `type` and return it\n  }\n} \n```\nIf no **toAttribute** function is supplied for a reflected attribute, the attribute is set to the property value without conversion.\n\nDuring an update:\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n**Example**: Configure a custom converter\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: {\n      reflect: true,\n      converter: {\n        toAttribute(value) {\n          console.log('myProp\\'s toAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = String(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        },\n\n        fromAttribute(value) {\n          console.log('myProp\\'s fromAttribute.');\n          console.log('Processing:', value, typeof(value));\n          let retVal = Number(value);\n          console.log('Returning:', retVal, typeof(retVal));\n          return retVal;\n        }\n      }\n    },\n\n    theProp: {\n      reflect: true,\n      converter(value) {\n        console.log('theProp\\'s converter.');\n        console.log('Processing:', value, typeof(value));\n\n        let retVal = Number(value);\n        console.log('Returning:', retVal, typeof(retVal));\n        return retVal;\n      }},\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    // console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n\n      <button @click=\"${this.changeProperties}\">change properties</button>\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.requestUpdate();\n  }\n\n  changeProperties() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n    this.theProp='theProp ' + randomString;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure observed attributes\nAn **observed attribute fires** the custom elements API callback **attributeChangedCallback** whenever it changes. By default, whenever an attribute fires this callback, LitElement sets the property value from the attribute using the property's fromAttribute function. See Convert between properties and attributes for more information.\n\n**By default, LitElement creates a corresponding observed attribute for all declared properties**. The name of the observed attribute is the property name, lowercased:\n\n```\n// observed attribute name is \"myprop\"\nmyProp: { type: Number }\n```\nTo create an observed attribute with a different name, set attribute to a string:\n\n```\n// Observed attribute will be called my-prop\nmyProp: { attribute: 'my-prop' }\n```\n\n**To prevent an observed attribute from being created for a property**, set attribute to false. The property will not be initialized from attributes in markup, and attribute changes won’t affect it.\n\n```\n// No observed attribute for this property\nmyProp: { attribute: false }\n```\n\n**An observed attribute can be used to provide an initial value for a property via markup**. See Initialize properties with attributes in markup.\n\n**Example**: Configure observed attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { attribute: true },\n    theProp: { attribute: false },\n    otherProp: { attribute: 'other-prop' },\n  };}\n\n  constructor() {\n    super();\n    this.myProp = 'myProp';\n    this.theProp = 'theProp';\n    this.otherProp = 'otherProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', name, newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>myProp ${this.myProp}</p>\n      <p>theProp ${this.theProp}</p>\n      <p>otherProp ${this.otherProp}</p>\n\n      <button @click=\"${this.changeAttributes}\">change attributes</button>\n    `;\n  }\n\n  changeAttributes() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.setAttribute('myprop', 'myprop ' + randomString);\n    this.setAttribute('theprop', 'theprop ' + randomString);\n    this.setAttribute('other-prop', 'other-prop ' + randomString);\n    this.requestUpdate();\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\nAn observed attribute can be used to provide an initial value for a property via markup. See Initialize properties with attributes in markup.\n\n### Configure reflected attributes\n**You can configure a property so that whenever it changes, its value is reflected to its observed attribute**. For example:\n\n```\n// Value of property \"myProp\" will reflect to attribute \"myprop\"\nmyProp: { reflect: true }\n```\n\nWhen the property changes, LitElement uses the toAttribute function in the property's converter to set the attribute value from the new property value.\n\n- If toAttribute returns null, the attribute is removed.\n\n- If toAttribute returns undefined, the attribute is not changed.\n\n- If toAttribute itself is undefined, the property value is set to the attribute value without conversion.\n\nLitElement tracks reflection state during updates. LitElement keeps track of state information to avoid creating an infinite loop of changes between a property and an observed, reflected attribute.\n\n**Example**: Configure reflected attributes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { return {\n    myProp: { reflect: true }\n  };}\n\n  constructor() {\n    super();\n    this.myProp='myProp';\n  }\n\n  attributeChangedCallback(name, oldval, newval) {\n    console.log('attribute change: ', newval);\n    super.attributeChangedCallback(name, oldval, newval);\n  }\n\n  render() {\n    return html`\n      <p>${this.myProp}</p>\n\n      <button @click=\"${this.changeProperty}\">change property</button>\n    `;\n  }\n\n  changeProperty() {\n    let randomString = Math.floor(Math.random()*100).toString();\n    this.myProp='myProp ' + randomString;\n  }\n\n}\ncustomElements.define('my-element', MyElement);\n```\n\n### Configure property changes\nAll declared properties have a function, **hasChanged**, which is **called whenever the property is set.**\n\nhasChanged compares the property's old and new values, and evaluates whether or not the property has changed. If hasChanged returns true, **LitElement starts an element update if one is not already scheduled**. See the Element update lifecycle documentation for more information on how updates work.\n\nBy default:\n\n- hasChanged returns true if newVal !== oldVal.\n- hasChanged returns false if both the new and old values are NaN.\n\nTo customize **hasChanged** for a property, specify it as a property option:\n\n```\nmyProp: { hasChanged(newVal, oldVal) {\n  // compare newVal and oldVal\n  // return `true` if an update should proceed\n}}\n```\n**Example**: Configure property changes\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties(){ return {\n    myProp: {\n      type: Number,\n\n      /**\n       * Compare myProp's new value with its old value.\n       *\n       * Only consider myProp to have changed if newVal is larger than\n       * oldVal.\n       */\n      hasChanged(newVal, oldVal) {\n        if (newVal > oldVal) {\n          console.log(`${newVal} > ${oldVal}. hasChanged: true.`);\n          return true;\n        }\n        else {\n          console.log(`${newVal} <= ${oldVal}. hasChanged: false.`);\n          return false;\n        }\n      }\n    }};\n  }\n\n  constructor(){\n    super();\n    this.myProp = 1;\n  }\n\n  render(){\n    return html`\n      <p>${this.myProp}</p>\n      <button @click=\"${this.getNewVal}\">get new value</button>\n    `;\n  }\n\n  updated(){\n    console.log('updated');\n  }\n\n  getNewVal(){\n    let newVal = Math.floor(Math.random()*10);\n    this.myProp = newVal;\n  }\n\n}\ncustomElements.define('my-element', MyElement);\n```\n\n  ","references":"- [LitElement Properties](https://lit-element.polymer-project.org/guide/properties)\n- [Alligator.io attributes-properties](https://alligator.io/web-components/attributes-properties/)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-properties-2","weblink":"https://codersnack.com/webcomponents-litelement-properties-2/","featured_image_preview":{"id":90,"name":"litelement-icon.png","hash":"285d00e1391c4f73b8ec7ff893b42e9d","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/285d00e1391c4f73b8ec7ff893b42e9d.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:15.512Z","updated_at":"2020-04-14T15:07:15.512Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Properties 2","created_at":"2020-03-31T15:56:38.406Z","updated_at":"2020-03-31T15:56:38.410Z"},{"id":64,"codersnack":{"id":65,"header":"LitElement Lifecycle 1","created_at":"2020-03-31T19:29:29.965Z","updated_at":"2020-04-14T15:07:00.130Z","explanation":"### Overview\n**LitElement-based components update asynchronously in response to observed property changes**. **Property changes are batched**—if more properties change after an update is requested, but before the update starts, all of the changes are captured in the same update.\n\nAt a high level, the update lifecycle is:\n\n- A property is set.\n- Check whether an update is needed. If an update is needed, request one.\n- Perform the update:\n    Process properties and attributes.\n    Render the element.\n- Resolve a Promise, indicating that the update is complete.\n\n#### LitElement and the browser event loop\n**The browser executes JavaScript code by processing a queue of tasks in the event loop**. In each iteration of the event loop, the browser takes a task from the queue and runs it to completion.\n\nWhen the task completes, before taking the next task from the queue, the browser allocates time to perform work from other sources—including DOM updates, user interactions, and the microtask queue.\n\nBy default, **LitElement updates are requested asynchronously, and queued as microtasks**. This means that Step 3 above (Perform the update) is executed at the end of the next iteration of the event loop.\n\n> You can change this behavior so that Step 3 awaits a Promise before performing the update. See performUpdate for more information.\n\n#### Lifecycle callbacks\nLitElement also inherits the default lifecycle callbacks from the Web Component standard:\n\n- **connectedCallback**: Invoked when a component is added to the document’s DOM.\n- **disconnectedCallback**: Invoked when a component is removed from the document’s DOM.\n- **adoptedCallback**: Invoked when a component is moved to a new document.\n- **attributeChangedCallback**: Invoked when component attribute changes.\n\n> Be aware that adoptedCallback is not polyfilled.\n\n**All lifecycle methods need to call the super method.**\n\n*Example*:\n\n```\nconnectedCallback() {\n  super.connectedCallback()\n\n  console.log('connected')\n}\n```\n\n#### Promises and asynchronous functions\n**LitElement uses *Promise* objects to schedule and respond to element updates**.\n\nUsing *async* and *await* makes it easy to work with *Promises*. For example, you can await the **updateComplete** Promise:\n\n```\n// `async` makes the function return a Promise & lets you use `await`\nasync myFunc(data) {\n  // Set a property, triggering an update\n  this.myProp = data;\n\n  // Wait for the updateComplete promise to resolve\n  await this.updateComplete;\n  // ...do stuff...\n  return 'done';\n}\n```\n\nBecause *async* functions return a *Promise*, you can await them, too:\n\n```\nlet result = await myFunc('stuff');\n// `result` is resolved! You can do something with it\n```\nSee the Web Fundamentals primer on Promises for a more in-depth tutorial.\n\n#### Methods and properties\n**In call order, the methods and properties in the update lifecycle are:**\n\n- **someProperty.hasChanged**\n- **requestUpdate**\n- **performUpdate**\n- **shouldUpdate**\n- **update**\n- **render**\n- **firstUpdated**\n- **updated**\n- **updateComplete**\n\n#### someProperty.hasChanged\n\nAll declared properties have a function, *hasChanged*, which is called whenever the property is set; if *hasChanged* returns true, an update is scheduled.\n\nSee the Properties documentation for information on configuring hasChanged to customize what constitutes a property change.\n\n#### requestUpdate\n\n```\n// Manually start an update\nthis.requestUpdate();\n\n// Call from within a custom property setter\nthis.requestUpdate(propertyName, oldValue);\n```\nParams:\n- propertyName: Name of property to be updated.\n- oldValue: Previous property value.\n\nReturns:\n- Promise: Returns the updateComplete Promise, which resolves on completion of the update.\n\nUpdates?:\n - No: Property changes inside this method will not trigger an element update.\n\nIf *hasChanged* returned true, requestUpdate fires, and the update proceeds.\n\n**To manually start an element update, call requestUpdate with no parameters**.\n\nTo implement a custom property setter that supports property options, pass the property name and its previous value as parameters.\n\n*Example*: Manually start an element update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  constructor() {\n    super();\n\n    // Request an update in response to an event\n    this.addEventListener('load-complete', async (e) => {\n      console.log(e.detail.message);\n      console.log(await this.requestUpdate());\n    });\n  }\n  render() {\n    return html`\n      <button @click=\"${this.fire}\">Fire a \"load-complete\" event</button>\n    `;\n  }\n  fire() {\n    let newMessage = new CustomEvent('load-complete', {\n      detail: { message: 'hello. a load-complete happened.' }\n    });\n    this.dispatchEvent(newMessage);\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n*Example*: Call **requestUpdate from a custom property setter**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() { \n    return { prop: { type: Number } };\n  }\n\n  set prop(val) {\n    let oldVal = this._prop;\n    this._prop = Math.floor(val);\n    this.requestUpdate('prop', oldVal);\n  }\n\n  get prop() { return this._prop; }\n\n  constructor() {\n    super();\n    this._prop = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop: ${this.prop}</p>\n      <button @click=\"${() =>  { this.prop = Math.random()*10; }}\">\n        change prop\n      </button>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### performUpdate\n```\n/**\n * Implement to override default behavior.\n */\nperformUpdate() { ... }\n```\nReturns: void or Promise: Performs an update.\nUpdates?: No : Property changes inside this method will not trigger an element update.\n\n**By default, performUpdate is scheduled as a *microtask* after the end of the next execution of the browser event loop**. To schedule *performUpdate*, implement it as an asynchronous method that awaits some state before calling *super.performUpdate()*. For example:\n\n```\nasync performUpdate() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n  super.performUpdate();\n}\n```\n\n#### shouldUpdate\n```\n/**\n * Implement to override default behavior.\n */\nshouldUpdate(changedProperties) { ... }\n```\nParams:\n- *changedProperties*: Map. Keys are the names of changed properties; Values are the corresponding previous values.\n\nReturns: Boolean: If true, update proceeds. Default return value is true.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Controls whether an update should proceed**. Implement shouldUpdate to specify which property changes should cause updates. By default, this method always returns true.\n\n*Example*: Customize which property changes should cause updates\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number },\n      prop2: { type: Number }\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 0;\n    this.prop2 = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n      <button @click=\"${() => this.prop1=this.change()}\">Change prop1</button>\n      <button @click=\"${() => this.prop2=this.change()}\">Change prop2</button>\n    `;\n  }\n\n  /**\n   * Only update element if prop1 changed.\n   */\n  shouldUpdate(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    return changedProperties.has('prop1');\n  }\n\n  change() {\n    return Math.floor(Math.random()*10);\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### update\nParams:\n- changedProperties:Map. Keys are the names of changed properties; Values are the corresponding previous values.\n\nUpdates? : No: Property changes inside this method do not trigger an element update.\n\n**Reflects property values to attributes and calls render to render DOM via lit-html**. Provided here for reference. **You don’t need to override or call this method**.\n\n##### render\n```\n/**\n * Implement to override default behavior.\n */\nrender() { ... }\n```\nReturns: TemplateResult: Must return a lit-html TemplateResult.\nUpdates?: No: Property changes inside this method will not trigger an element update.\n\n**Uses *lit-html* to render the element template**. You must implement render for any component that extends the LitElement base class.\n\n","references":"- [LitElement lifecycle](https://lit-element.polymer-project.org/guide/lifecycle)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-lifecycle","weblink":"https://codersnack.com/webcomponents-litelement-lifecycle/","featured_image_preview":{"id":89,"name":"litelement-icon.png","hash":"4b68f145870a41f2ba23b2775fa2b1b8","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/4b68f145870a41f2ba23b2775fa2b1b8.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:07:00.148Z","updated_at":"2020-04-14T15:07:00.148Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElements Lifecycle 1","created_at":"2020-03-31T19:30:08.056Z","updated_at":"2020-03-31T19:30:08.062Z"},{"id":65,"codersnack":{"id":66,"header":"LitElement Lifecycle 2","created_at":"2020-03-31T19:51:01.653Z","updated_at":"2020-04-14T15:06:42.160Z","explanation":"#### firstUpdated\n```\n/**\n * Implement to override default behavior.\n */\nfirstUpdated(changedProperties) { ... }\n```\nParams: changedProperties: Map. Keys are the names of changed properties; Values are the corresponding previous values.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Called after the element's DOM has been updated the first time, immediately before updated is called**.\n\n> Implement firstUpdated to perform one-time work after the element's template has been created.\n\n*Example*: Focus an input element on first update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      textAreaId: { type: String },\n      startingText: { type: String }\n    };\n  }\n  constructor() {\n    super();\n    this.textAreaId = 'myText';\n    this.startingText = 'Focus me on first update';\n  }\n  render() {\n    return html`\n      <textarea id=\"${this.textAreaId}\">${this.startingText}</textarea>\n    `;\n  }\n  firstUpdated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    const textArea = this.shadowRoot.getElementById(this.textAreaId);\n    textArea.focus();\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### updated\n```\n/**\n * Implement to override default behavior.\n */\nupdated(changedProperties) { ... }\n```\nParams: changedProperties:Map. Keys are the names of changed properties; Values are the corresponding previous values.\nUpdates?: Yes: Property changes inside this method will trigger an element update.\n\n**Called when the element’s DOM has been updated and rendered**. Implement to perform some task after an update.\n\n**Example**: Focus an element after update\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number },\n      prop2: { type: Number }\n    };\n  }\n  constructor() {\n    super();\n    this.prop1 = 0;\n    this.prop2 = 0;\n  }\n  render() {\n    return html`\n      <style>button:focus { background-color: aliceblue; }</style>\n\n      <p>prop1: ${this.prop1}</p>\n      <p>prop2: ${this.prop2}</p>\n\n      <button id=\"a\" @click=\"${() => this.prop1=Math.random()}\">prop1</button>\n      <button id=\"b\" @click=\"${() => this.prop2=Math.random()}\">prop2</button>\n    `;\n  }\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      console.log(`${propName} changed. oldValue: ${oldValue}`);\n    });\n    let b = this.shadowRoot.getElementById('b');\n    b.focus();\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\n#### updateComplete\n```\n// Await Promise property.\nawait this.updateComplete;\n```\nType: Promise: Resolves with a Boolean when the element has finished updating.\nResolves: true if there are no more pending updates.false if this update cycle triggered another update.\n\nThe *updateComplete* Promise resolves when the element has finished updating. **Use updateComplete to wait for an update**:\n```\n  await this.updateComplete;\n  // do stuff\n  this.updateComplete.then(() => { /* do stuff */ });\n```\n**Example**\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get properties() {\n    return {\n      prop1: { type: Number }\n    };\n  }\n\n  constructor() {\n    super();\n    this.prop1 = 0;\n  }\n\n  render() {\n    return html`\n      <p>prop1: ${this.prop1}</p>\n      <button @click=\"${this.changeProp}\">prop1</button>\n    `;\n  }\n\n  async getMoreState() {\n    return;\n  }\n\n  async changeProp() {\n    this.prop1 = Math.random();\n    await Promise.all([this.updateComplete, this.getMoreState()]);\n    console.log('Update complete. Other state completed.');\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Overriding updateComplete\n\nTo await additional state before fulfilling the *updateComplete* promise, override the *_getUpdateComplete* method. For example, it may be useful to await the update of a child element here. First await *super._getUpdateComplete()*, then any subsequent state.\n\n> It’s recommended to override the *_getUpdateComplete* method instead of the *updateComplete* getter to ensure compatibility with users who are using TypeScript’s ES5 output (see TypeScript#338).\n\n```\n  class MyElement extends LitElement {\n    async _getUpdateComplete() {\n      await super._getUpdateComplete();\n      await this._myChild.updateComplete;\n    }\n  }\n```\n### Examples\n#### Control when updates are processed\nImplement **performUpdate**:\n\n```\nasync performUpdate() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve());\n  super.performUpdate();\n}\n```\n\n#### Customize which property changes should cause an update\nImplement **shouldUpdate**:\n\n```\nshouldUpdate(changedProps) {\n  return changedProps.has('prop1');\n}\n```\n\n#### Customize what constitutes a property change\nSpecify *hasChanged* for the property. See the Properties documentation.\n\nManage property changes and updates for object subproperties\n\n> **Mutations** (changes to object subproperties and array items) **are not observable**. Instead, either rewrite the whole object, or call requestUpdate after a mutation.\n\n```\n// Option 1: Rewrite whole object, triggering an update\nthis.prop1 = Object.assign({}, this.prop1, { subProp: 'data' });\n\n// Option 2: Mutate a subproperty, then call requestUpdate\nthis.prop1.subProp = 'data';\nthis.requestUpdate();\n```\n#### Update in response to something that isn’t a property change\nCall **requestUpdate**:\n```\n// Request an update in response to an event\nthis.addEventListener('load-complete', async (e) => {\n  console.log(e.detail.message);\n  console.log(await this.requestUpdate());\n});\n```\n\n#### Request an update regardless of property changes\nCall **requestUpdate()**:\n\n```\nthis.requestUpdate();\n```\n#### Request an update for a specific property\nCall requestUpdate(propName, oldValue):\n\n```\nlet oldValue = this.prop1;\nthis.prop1 = 'new value';\nthis.requestUpdate('prop1', oldValue);\n\n```\n#### Do something after the first update\nImplement **firstUpdated**:\n\n```\nfirstUpdated(changedProps) {\n  console.log(changedProps.get('prop1'));\n}\n```\n\n#### Do something after every update\nImplement updated:\n\n```\nupdated(changedProps) {\n  console.log(changedProps.get('prop1'));\n}\n```\n\n#### Do something when the element next updates\nAwait the updateComplete promise:\n\n```\nawait this.updateComplete;\n// do stuff\nthis.updateComplete.then(() => {\n  // do stuff\n});\n```\n#### Wait for an element to finish updating\nAwait the **updateComplete** promise:\n\n```\nlet done = await updateComplete;\nupdateComplete.then(() => {\n  // finished updating\n});\n```","references":"- [LitElement lifecycle](https://lit-element.polymer-project.org/guide/lifecycle)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-lifecycle-2","weblink":"https://codersnack.com/webcomponents-litelement-lifecycle-2/","featured_image_preview":{"id":88,"name":"litelement-icon.png","hash":"897d28ee02da49f6ab54b64860992121","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/897d28ee02da49f6ab54b64860992121.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:06:42.176Z","updated_at":"2020-04-14T15:06:42.176Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Lifecycle 2","created_at":"2020-03-31T19:51:34.365Z","updated_at":"2020-03-31T19:51:34.369Z"},{"id":66,"codersnack":{"id":67,"header":"StencilJS Introduction","created_at":"2020-04-14T14:12:10.274Z","updated_at":"2020-06-16T15:21:43.792Z","explanation":"**Stencil is a compiler that generates Web Components** (more specifically, Custom Elements). Stencil combines the best concepts of the most popular frameworks into a simple build-time tool.\nStencil takes features such as\n\t- **Virtual DOM**\n\t- **Async rendering (inspired by React Fiber)**\n\t- **Reactive data-binding**\n\t- **TypeScript**\n\t- **JSX**\nand then generates standards-based Web Components with these features baked in.\n\nSince Stencil **generates standards-compliant web components**, they **can work with many popular frameworks right out of the box**, and can be used without a framework because they are just web components. Stencil also enables a number of key **capabilities on top of Web Components,** in particular, **pre-rendering**, and **objects-as-properties** (instead of just strings).\n\n**Compared to using Custom Elements directly, Stencil provides extra APIs** that makes writing fast components simpler. APIs like **Virtual DOM**, **JSX**, and **async rendering** make fast, powerful components easy to create, while still maintaining 100% compatibility with Web Components.\n\nThe developer experience is also tuned, and comes with **live reload** and a **small dev server** baked in to the compiler.\n\n### Why Stencil?\n\nStencil was **created by the Ionic Framework team** to help build faster, more capable components that worked across all major frameworks.\n\nWhile Ionic primarily targeted Cordova apps, the emergence of Progressive Web Apps as a rapidly growing target for web developers demanded a different approach to web app development performance. With Ionic's classic use of traditional frameworks and bundling techniques, **the team was struggling to meet latency and code size demands for Progressive Web Apps** that ran equally well on fast and slow networks, across a diversity of platforms and devices.\n\nAdditionally, **framework fragmentation had created a web development interoperability nightmare**, where components built for one framework didn't work with another framework.\n\n**Web Components offered a solution to both problems**, pushing more work to the browser for better performance, and targeting a standards-based component model that all frameworks could use.\n\nHowever,**Web Components by themselves weren't enough**. Building fast web apps required innovations that were previously locked up inside of traditional web frameworks. **Stencil was built to pull these features out of traditional frameworks and bring them to the fast emerging Web Component standard**\n\n## Stencil Goals And Objectives\nStencil aims to combine the best concepts of the most popular frontend frameworks into a compile-time tool rather than run-time tool. It's important to stress that **Stencil's goal is to not become or be seen as a \"framework\",** but rather our goal is to provide a great developer experience and tooling expected from a framework, while using web-standards within the browser at run-time. In many cases, Stencil can be used as a drop in replacement for traditional frontend frameworks given the capabilities now available in the browser, though using it as such is certainly not required.\n\n#### Web Standards\n**Components generated by Stencil in the end are built on top of web components**, so they work in any major framework or with no framework at all. Additionally, other standards heavily relied on include ES Modules and dynamic imports which have proven to replace traditional bundlers which add unnecessary complexities and run-time JavaScript. By using web-standards, developers can learn and adopt a standard API documented across the world, rather than custom framework APIs that continue to change.\n\n#### Automatic Optimizations\nThere are countless optimizations and tweaks developers must do to improve performance of components and websites. With a compiler, **Stencil is able to analyze component code as an input, and generate optimized components as an output.**\n\n#### Future-Friendly\nAs the world of software development continues to evolve, so too can the compiler. Instead of requiring complete rewrites of components, the compiler can continue to make optimizations using the standard component model as the common input. **The compiler allows developers to create future-friendly components, while still staying up-to-date on the latest optimizations without starting over again and again**. Additionally, if something changes about any API, the compiler is able to make automatic adjustments and notify the developer exactly what needs to be updated.\n\n#### Run-time Performance\nInstead of writing custom client-side JavaScript which every user needs to download and parse for the app to work, **Stencil instead prefers to use the already amazing APIs built directly within the browser**. These APIs include **Custom Elements**\n\n#### Tiny API\n**Stencil purposely does not come with a large custom API which needs to be learned and re-learned, but rather heavily relies on, you guessed it, web-standards**. Again, our goal is to not create yet-another-framework, but rather provide tooling for developers to generate future-friendly components using APIs already baked within the browser. The smaller the API, the easier to learn, and the less that can be broken.\n\n#### Framework Features During Development\nIf you haven't noticed already we think web-standards are great and offer many benefits. While using web-standards without any structure is certainly possible, and there are actually many use-cases where this would be appropriate, we found that **as apps and teams scale it quickly becomes difficult to manage. Developers often gravitate to frameworks because of their great tooling, defined structure, and ability to allow developers to build apps quickly**. One of the largest goals of Stencil is to be that intersection of having great framework features and first-class tooling during development but generating future-proof web-standard code, rather than custom framework specific code.\n\n#### Wide Browser Support\n**For the small minority of browsers that do not support modern browser features and APIs, Stencil will automatically polyfill them on-demand**. What this means is that for browsers that already support the feature natively, they will not have to download and parse any unnecessary JavaScript. The great news is that in today's web landscape, most modern APIs are already shipping for what Stencil requires. Out-of-the-box browser support includes IE11 and up.\n","references":"- [stenciljs.com Introduction](https://stenciljs.com/docs/introduction)\n- [stenciljs.com Goals](https://stenciljs.com/docs/goals-and-objectives)","featured_image_url":"https://codersnack.com/assets/images/stenciljs-icon.png","slug":"stenciljs-introduction","weblink":"https://codersnack.com/stenciljs-introduction/","featured_image_preview":{"id":86,"name":"stenciljs-icon.png","hash":"2772179d41214a189ff99bc2d39657b0","sha256":"mzIt3i4QEDB9hP6wQaYm8PowHkAUxTuOsHw3dx0gd7k","ext":".png","mime":"image/png","size":5.58,"url":"/uploads/2772179d41214a189ff99bc2d39657b0.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:04:06.864Z","updated_at":"2020-04-14T15:04:06.864Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"StencilJS Introduction","created_at":"2020-04-14T14:13:43.754Z","updated_at":"2020-04-14T14:13:43.762Z"},{"id":67,"codersnack":{"id":68,"header":"StencilJS Hello World","created_at":"2020-04-14T15:04:41.891Z","updated_at":"2020-04-14T15:04:41.891Z","explanation":"## Getting Started\n\n#### Starting a new project\nStencil requires a **recent LTS version of NodeJS and npm**. Make sure you've installed and/or updated Node before continuing.\n\n> Note that you will need to use npm 6 or higher.\n\n```\nnpm init stencil\n``` \n\n**Stencil can be used to create standalone components, or entire apps**. After running init you will be provided with a prompt so that you can choose the type of project to start.\n\n```\n? Pick a starter › - Use arrow-keys. Return to submit.\n\n❯  ionic-pwa     Everything you need to build fast, production ready PWAs\n   app           Minimal starter for building a Stencil app or website\n   component     Collection of web components that can be used anywhere\n```\n#### Updating Stencil\nTo get the latest version of @stencil/core you can run:\n\n```\nnpm install @stencil/core@latest --save-exact\n```\n\n## My First Component\n**Stencil components are created by adding a new file with a .tsx extension**, such as my-first-component.tsx, and placing them in the src/components directory. The .tsx extension is required since **Stencil components are built using JSX and TypeScript**.\n\nHere is an example of what a Stencil component looks like:\n\n```\nimport { Component, Prop, h } from '@stencil/core';\n\n@Component({\n  tag: 'my-first-component',\n})\nexport class MyComponent {\n\n  // Indicate that name should be a public property on the component\n  @Prop() name: string;\n\n  render() {\n    return (\n      <p>\n        My name is {this.name}\n      </p>\n    );\n  }\n}\n```\nDon't fully understand what's going on? Don't worry, we'll explain each piece in detail later on.\n\nOnce compiled, this component can be used in HTML just like any other tag.\n\n```\n<my-first-component name=\"Max\"></my-first-component>\n```\n**Web Components must have a - in the tag**. firstComponent would not be a valid tag name.\n\nWhen rendered, the browser will display ```My name is Max```.\n\n## So what is really going on here?\nLet's dive in.\n\nThe first piece we see is the ```@Component``` decorator. This decorator provides **metadata about our component** to the Stencil compiler. Information, such as the **tag** to use, and **external styles**, can be set here and picked up by the compiler.\n\nBelow the @Component() decorator, we have a **standard JavaScript class**. This is where you'll write the bulk of your code to bring your Stencil component to life. **Here is where you'd write functions or provide business logic**.\n\nIn order for the component to render something to the screen, we must declare a ```render``` function that returns JSX.The quick idea is that our render function needs to return a **representation of the HTML we want to push to the DOM.**\n\nThe **name property** on the class also has a decorator applied to it, ```@Prop()```. This decorator tells the compiler that the property is public to the component, and the user should be setting it. We set this property like so:\n\n```\n<my-first-component name=\"Max\"></my-first-component>\n```\nAny property decorated with ```@Prop()``` is also **automatically watched for changes**. If a user of our component were to change the element's name property, our component would fire its render function again, updating the displayed content.\n\n#### Component Generator\n**The Stencil CLI can generate new components** for you. If you used one of the starters, you can simply run the generate npm script in your project, which will start the **interactive generator**.\n\n```\nnpm run generate\n```\nOr you can invoke the **Stencil CLI directly with the generate command** (g for short). If you don't have stencil installed globally, prefix the command with npx.\n\n```\nstencil generate\n```\nYou can optionally pass the component tag name directly to the command. **Remember that the component tag name needs to be lowercase and contain at least one hyphen**. In the second step, the generator will ask you which files to generate. This allows you to bootstrap a stylesheet as well as spec and e2e tests along with the component file.\n\n**All components will be generated within the *src/components* folder**. Within that, a folder will be created with the same name as the component tag name you provided, and within that folder the files will be generated. It is also possible to specify one or multiple sub-folders to generate the component in.\n\nFor example, if you specify ```pages/page-home``` as the component tag name, the files will be generated in ```src/components/pages/page-home```.\n\n```\nstencil generate pages/page-home\n```\n```\nsrc\n |- components\n     |- pages\n         |- page-home\n             |- page-home.css\n             |- page-home.e2e.ts\n             |- page-home.spec.ts\n             |- page-home.tsx\n```\n","references":"- [stenciljs.com Getting started](https://stenciljs.com/docs/getting-started)\n- [stenciljs.com My first component](https://stenciljs.com/docs/my-first-component)","featured_image_url":"https://codersnack.com/assets/images/stenciljs-icon.png","slug":"stenciljs-hello-world","weblink":"https://codersnack.com/stenciljs-hello-world/","featured_image_preview":{"id":87,"name":"stenciljs-icon.png","hash":"582e637d911f4f3f9fa6ae8212053b07","sha256":"mzIt3i4QEDB9hP6wQaYm8PowHkAUxTuOsHw3dx0gd7k","ext":".png","mime":"image/png","size":5.58,"url":"/uploads/582e637d911f4f3f9fa6ae8212053b07.png","provider":"local","provider_metadata":null,"created_at":"2020-04-14T15:04:41.904Z","updated_at":"2020-04-14T15:04:41.904Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"StencilJS Hello World","created_at":"2020-04-14T15:05:05.147Z","updated_at":"2020-04-14T15:05:05.152Z"},{"id":83,"codersnack":{"id":84,"header":"Using the Shadow DOM","created_at":"2020-06-23T12:09:16.576Z","updated_at":"2020-06-23T12:39:11.606Z","explanation":"An important aspect of web components is **encapsulation** , being able to keep the markup structure, style, and behavior hidden and separate from other code on the page so that different parts do not clash, and the code can be kept nice and clean. \n\nThe **Shadow DOM API** is a key part of this, providing a way to **attach a hidden separated DOM to an element**. This article covers the basics of using the Shadow DOM.\n\n\n## High-level view\n\nThis article assumes you are already familiar with the concept of the **DOM (Document Object Model)**, a tree-like structure of connected nodes that represents the different elements and strings of text appearing in a markup document (usually an HTML document in the case of web documents). As an example, consider the following HTML fragment:\n``` \n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Simple DOM example</title>\n  </head>\n  <body>\n      <section>\n        <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\">\n        <p>Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a></p>\n      </section>\n  </body>\n</html>\n``` \nThis fragment produces the following DOM structure:\n![dom screenshot](https://codersnack.com/assets/images/wc-dom-screenshot.png)\n\n\n**Shadow DOM allows hidden DOM trees to be attached to elements in the regular DOM tree** ; this shadow DOM tree starts with a shadow root, underneath which can be attached to any elements you want, in the same way as the normal DOM.\n\n![Shadow dom](https://codersnack.com/assets/images/wc-shadow-dom.png)\n\nThere are some **bits of shadow DOM terminology to be aware of**:\n\n- **Shadow host**: The regular DOM node that the shadow DOM is attached to.\n- **Shadow tree**: The DOM tree inside the shadow DOM.\n- **Shadow boundary**: the place where the shadow DOM ends, and the regular DOM begins.\n- **Shadow root**: The root node of the shadow tree.\n\n**You can affect the nodes in the shadow DOM in exactly the same way as non-shadow nodes** ; for example appending children or setting attributes, styling individual nodes using ```element.style.foo```, or adding style to the entire shadow DOM tree inside a ```<style>``` element. **The difference is that none of the code inside a shadow DOM can affect anything outside it, allowing for handy encapsulation**.\n\nNote that the shadow DOM is not a new thing by any means ; **browsers have used it for a long time to encapsulate the inner structure of an element**. Think for example of a ```<video>``` element, with the default browser controls exposed. All you see in the DOM is the ```<video>``` element, but it contains a series of buttons and other controls inside its shadow DOM. The shadow DOM spec has made it so that you are allowed to actually manipulate the shadow DOM of your own custom elements.\n\n## Basic usage\nYou can attach a shadow root to any element using the **Element.attachShadow()** method. This takes as its parameter an options object that contains one option ; *mode* ; with a value of open or closed:\n```\nlet shadow = elementRef.attachShadow({mode: 'open'});\nlet shadow = elementRef.attachShadow({mode: 'closed'});\n```\n***open* means that you can access the shadow DOM using JavaScript written in the main page context**, for example using the **Element.shadowRoot** property:\n\n```\nlet myShadowDom = myCustomElem.shadowRoot;\n```\n**If you attach a shadow root to a custom element with *mode: closed* set, you won't be able to access the shadow DOM from the outside** ; ``` myCustomElem.shadowRoot``` returns null. This is the case with built in elements that contain shadow DOMs, such as ```<video>```.\n\n> ***Note***: As this blog post shows, it is actually fairly easy to work around closed shadow DOMs, and the hassle to completely hide them is often more than it's worth.\n\nIf you are **attaching a shadow DOM to a custom element as part of its constructor** (by far the most useful application of the shadow DOM), you would use something like this:\n\n```\nlet shadow = this.attachShadow({mode: 'open'});\n```\nWhen you've attached a shadow DOM to an element, manipulating it is a matter of just using the same DOM APIs as you use for the regular DOM manipulation:\n\n```\nvar para = document.createElement('p');\nshadow.appendChild(para);\n// etc.\n```\n\n## Working through a simple example\n\nNow let's walk through a simple example to demonstrate the shadow DOM in action inside a custom element ; ```<popup-info-box>``` (see a live example also). This takes an image icon and a text string, and embeds the icon into the page. When the icon is focused, it displays the text in a pop up information box to provide further in-context information. To begin with, in our JavaScript file we define a class called *PopUpInfo*, which extends HTMLElement:\n\n```\nclass PopUpInfo extends HTMLElement {\n  constructor() {\n    // Always call super first in constructor\n    super();\n\n    // write element functionality in here\n\n    ...\n  }\n}\n```\n\nInside the class definition we define the element's **constructor**, which defines all the **functionality the element will have when an instance of it is instantiated**.\n\n### Creating the shadow root\n\nWe first attach a shadow root to the custom element:\n\n```\n// Create a shadow root\nvar shadow = this.attachShadow({mode: 'open'});\n```\n\n### Creating the shadow DOM structure\n\nNext, we use some DOM manipulation to create the element's internal shadow DOM structure:\n\n```\n// Create spans\nvar wrapper = document.createElement('span');\nwrapper.setAttribute('class','wrapper');\nvar icon = document.createElement('span');\nicon.setAttribute('class','icon');\nicon.setAttribute('tabindex', 0);\nvar info = document.createElement('span');\ninfo.setAttribute('class','info');\n\n// Take attribute content and put it inside the info span\nvar text = this.getAttribute('text');\ninfo.textContent = text;\n\n// Insert icon\nvar imgUrl;\nif(this.hasAttribute('img')) {\n  imgUrl = this.getAttribute('img');\n} else {\n  imgUrl = 'img/default.png';\n}\nvar img = document.createElement('img');\nimg.src = imgUrl;\nicon.appendChild(img);\n```\n\n### Styling the shadow DOM\n\nAfter that we create a ```<style>``` element and populate it with some CSS to style it:\n\n```\n// Create some CSS to apply to the shadow dom\nvar style = document.createElement('style');\n\nstyle.textContent = `\n.wrapper {\n  position: relative;\n}\n\n.info {\n  font-size: 0.8rem;\n  width: 200px;\n  display: inline-block;\n  border: 1px solid black;\n  padding: 10px;\n  background: white;\n  border-radius: 10px;\n  opacity: 0;\n  transition: 0.6s all;\n  position: absolute;\n  bottom: 20px;\n  left: 10px;\n  z-index: 3;\n}\n\nimg {\n  width: 1.2rem;\n}\n\n.icon:hover + .info, .icon:focus + .info {\n  opacity: 1;\n}`;\n```\n\n### Attaching the shadow DOM to the shadow root\n\nThe final step is to attach all the created elements to the shadow root:\n\n```\n// attach the created elements to the shadow dom\nshadow.appendChild(style);\nshadow.appendChild(wrapper);\nwrapper.appendChild(icon);\nwrapper.appendChild(info);\n```\n\n### Using our custom element\n\nOnce the class is defined, using the element is as simple as defining it, and putting it on the page, as explained in Using custom elements:\n\n```\n// Define the new element\ncustomElements.define('popup-info', PopUpInfo);\n```\n\n```\n<popup-info img=\"img/alt.png\" text=\"Your card validation code (CVC) is an extra \n                                    security feature — it is the last 3 or 4\n                                    numbers on the back of your card.\">\n```\n\n### Internal versus external styles\n\nIn the above example we apply style to the Shadow DOM using a ```<style>``` element, but it is perfectly possible to do it by referencing an external stylesheet from a ```<link>``` element instead.\n\nFor example, take a look at this code from our *popup-info-box-external-stylesheet* example (see the source code):\n\n```\n// Apply external styles to the shadow dom\nconst linkElem = document.createElement('link');\nlinkElem.setAttribute('rel', 'stylesheet');\nlinkElem.setAttribute('href', 'style.css');\n\n// Attach the created element to the shadow dom\nshadow.appendChild(linkElem);\n```\n\nNote that ```<link>``` elements **do not block paint of the shadow root, so there may be a flash of unstyled content** (FOUC) while the stylesheet loads.\n\n> Many modern browsers implement an optimization for ```<style>``` tags either cloned from a common node or that have identical text, to allow them to share a single backing stylesheet. With this optimization the performance of external and internal styles should be similar.","references":"- [MDN  - Using the Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM#:~:text=let%20shadow%20%3D%20elementRef.,for%20example%20using%20the%20Element.)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-shadow-dom","weblink":"https://codersnack.com/web-components-shadow-dom/","featured_image_preview":{"id":115,"name":"web-components.png","hash":"5ae94abde1204a748c846f218b77c985","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/5ae94abde1204a748c846f218b77c985.png","provider":"local","provider_metadata":null,"created_at":"2020-06-23T12:09:16.609Z","updated_at":"2020-06-23T12:09:16.609Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - Using the shadow DOM","created_at":"2020-06-23T12:10:27.559Z","updated_at":"2020-06-23T12:10:27.564Z"},{"id":84,"codersnack":{"id":85,"header":"Web Components - Using Templates and Slots","created_at":"2020-06-23T14:13:26.825Z","updated_at":"2020-06-23T14:13:26.825Z","explanation":"This article explains how you can use the ```<template>``` and ```<slot>``` elements to create a flexible template that can then be used to populate the shadow DOM of a web component.\n\n## The truth about templates\n\n**When you have to reuse the same markup structures repeatedly on a web page, it makes sense to use some kind of a template rather than repeating the same structure over and over again**. This was possible before, but it is made a lot easier by the HTML ```<template>``` element (which is well-supported in modern browsers: https://www.w3schools.com/tags/tag_template.asp ). This element and its contents are not rendered in the DOM, but it can still be referenced using JavaScript.\n\nLet's look at a trivial quick example:\n\n```\n<template id=\"my-paragraph\">\n  <p>My paragraph</p>\n</template>\n```\nThis won't appear in your page until you grab a reference to it with JavaScript and then append it to the DOM, using something like the following:\n\n```\nlet template = document.getElementById('my-paragraph');\nlet templateContent = template.content;\ndocument.body.appendChild(templateContent);\n```\n\nAlthough trivial, you can already start to see how this could be useful.\n\n## Using templates with web components\n\nTemplates are useful on their own, but they work even better with web components. Let's define a web component that uses our template as the content of its shadow DOM. We'll call it ```<my-paragraph>```:\n\n```\ncustomElements.define('my-paragraph',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      let template = document.getElementById('my-paragraph');\n      let templateContent = template.content;\n\n      const shadowRoot = this.attachShadow({mode: 'open'})\n        .appendChild(templateContent.cloneNode(true));\n    }\n  }\n);\n```\n\nThe key point to note here is that **we append a clone of the template content to the shadow root**, created using the **Node.cloneNode()** method.\n\nAnd because we are appending its contents to a shadow DOM, **we can include some styling information inside the template** in a ```<style>``` element, which is then encapsulated inside the custom element. This wouldn't work if we just appended it to the standard DOM.\n\nSo for example:\n\n```\n<template id=\"my-paragraph\">\n  <style>\n    p {\n      color: white;\n      background-color: #666;\n      padding: 5px;\n    }\n  </style>\n  <p>My paragraph</p>\n</template>\n```\n\nNow we can use it by just adding it to our HTML document:\n```\n<my-paragraph></my-paragraph>\n```\n> ***Note***: Templates are well-supported in browsers; the Shadow DOM API is supported by default in Firefox (version 63 onwards), Chrome, Opera, Safari, and Edge (starting with version 79).\n\n## Adding flexibility with slots\n\nSo far so good, but the element isn't very flexible. We can only display one bit of text inside it, meaning that at the moment it is even less useful than a regular paragraph! We can make it possible to **display different text in each element instance** in a nice declarative way using the ```<slot>```  element. This has more limited support than ```<template>```,  available since Chrome 53, Opera 40, Safari 10, Firefox 59, and Edge 79.\n\n**Slots are identified by their name attribute**, and **allow you to define *placeholders* in your template that can be filled with any markup fragment** you want when the element is used in the markup.\n\nSo, if we want to add a slot into our trivial example, we could update our template's paragraph element like this:\n\n```\n<p><slot name=\"my-text\">My default text</slot></p>\n```\nIf the slot's content isn't defined when the element is included in the markup, or if the browser doesn't support slots, ```<my-paragraph>```  just contains the **fallback content** ```\"My default text\"```.\n\nTo define the slot's content, we include an HTML structure inside the ```<my-paragraph>``` element with a **slot attribute** whose *value* is equal to the name of the slot we want it to fill. As before, this can be anything you like, for example:\n\n```<my-paragraph>\n  <span slot=\"my-text\">Let's have some different text!</span>\n</my-paragraph>\n```\nor\n\n```\n<my-paragraph>\n  <ul slot=\"my-text\">\n    <li>Let's have some different text!</li>\n    <li>In a list!</li>\n  </ul>\n</my-paragraph>\n```\n> Note: Elements that can be inserted into slots are known as **Slotable**; when an element has been inserted in a slot, it is said to be slotted.\n\n> Note: An **unnamed** ```<slot>``` will be **filled with all of the custom element's top-level child nodes** that do not have the slot attribute. This includes text nodes.\n\nAnd that's it for our trivial example. If you want to play with it some more, you can find it on GitHub (see it running live also).\n\n## A more involved example\n\nTo finish off the article, let's look at something a little less trivial.\n\nThe following set of code snippets show how to use ```<slot>``` together with ```<template>``` and some JavaScript to:\n\n- create a ```<element-details>``` element with named slots in its shadow root\n- design the ```<element-details>``` element in such a way that, when used in documents, it is rendered from composing the element’s content together with content from its shadow root; that is, pieces of the element’s content are used to fill in named slots in its shadow root\n\nNote that it is technically possible to use ```<slot>``` element without a ```<template>``` element, e.g., within say a regular ```<div>``` element, and still take advantage of the place-holder features of  ```<slot>``` for Shadow DOM content, and doing so may indeed avoid the small trouble of needing to first access the template element's content property (and clone it). However, it is generally more practical to add slots within a ```<template>``` element, since you are unlikely to need to define a pattern based on an already-rendered element.\n\nIn addition, even if it is not already rendered, the purpose of the container as a template should be more semantically clear when using the ```<template>```. In addition, ```<template>``` can have items directly added to it, like ```<td>```, which would disappear when added to a ```<div>```.\n\n### Creating a template with some slots\n\nFirst of all, we use the ```<slot>``` element within a ```<template>``` element to create a new \"element-details-template\" document fragment containing some named slots:\n\n```\n<template id=\"element-details-template\">\n  <style>\n  details {font-family: \"Open Sans Light\",Helvetica,Arial}\n  .name {font-weight: bold; color: #217ac0; font-size: 120%}\n  h4 { margin: 10px 0 -8px 0; }\n  h4 span { background: #217ac0; padding: 2px 6px 2px 6px }\n  h4 span { border: 1px solid #cee9f9; border-radius: 4px }\n  h4 span { color: white }\n  .attributes { margin-left: 22px; font-size: 90% }\n  .attributes p { margin-left: 16px; font-style: italic }\n  </style>\n  <details>\n    <summary>\n      <span>\n        <code class=\"name\">&lt;<slot name=\"element-name\">NEED NAME</slot>&gt;</code>\n        <i class=\"desc\"><slot name=\"description\">NEED DESCRIPTION</slot></i>\n      </span>\n    </summary>\n    <div class=\"attributes\">\n      <h4><span>Attributes</span></h4>\n      <slot name=\"attributes\"><p>None</p></slot>\n    </div>\n  </details>\n  <hr>\n</template>\n```\nThat ```<template>``` element has several features:\n\nThe ```<template>``` has a ```<style>``` element with a **set of CSS styles that are scoped just to the document fragment** the  ```<template>``` creates.\nThe ```<template>``` uses ```<slot>``` and its *name* attribute to make three *named slots*:\n- ```<slot name=\"element-name\">```\n- ```<slot name=\"description\">```\n- ```<slot name=\"attributes\">```\n\nThe ```<template>``` wraps the named slots in a ```<details>``` element.\n\n### Creating a new ```<element-details>``` element from the ```<template>```\n\nNext, let’s create a new custom element named ```<element-details>``` and use **Element.attachShadow** to attach to it, as its shadow root, that document fragment we created with our ```<template>``` element above. This uses exactly the same pattern as we saw in our earlier trivial example.\n\n```\ncustomElements.define('element-details',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      var template = document\n        .getElementById('element-details-template')\n        .content;\n      const shadowRoot = this.attachShadow({mode: 'open'})\n        .appendChild(template.cloneNode(true));\n    }\n  }\n);\n```\n\n### Using the ```<element-details>``` custom element with named slots\n\nNow let’s take that ```<element-details>``` element and actually use it in our document:\n\n```\n<element-details>\n  <span slot=\"element-name\">slot</span>\n  <span slot=\"description\">A placeholder inside a web\n    component that users can fill with their own markup,\n    with the effect of composing different DOM trees\n    together.</span>\n  <dl slot=\"attributes\">\n    <dt>name</dt>\n    <dd>The name of the slot.</dd>\n  </dl>\n</element-details>\n```\n\n```\n<element-details>\n  <span slot=\"element-name\">template</span>\n  <span slot=\"description\">A mechanism for holding client-\n    side content that is not to be rendered when a page is\n    loaded but may subsequently be instantiated during\n    runtime using JavaScript.</span>\n</element-details> \n```\n\nAbout that snippet, notice these points:\n\n- The snippet has two instances of ```<element-details>``` elements which both use the *slot* attribute to reference the named slots \"element-name\" and \"description\" we put in the ```<element-details>``` shadow root .\n\n- Only the first of those two ```<element-details>``` elements references the \"attributes\" named slot. The second ```<element-details>``` element lacks any reference to the \"attributes\" named slot.\n\n- The first ```<element-details>``` element references the \"attributes\" named slot using a ```<dl>``` element with ```<dt>``` and ```<dd>``` children.\n\n### Adding a final bit of style\n\nAs a finishing touch, we'll add a tiny bit more CSS for the ```<dl>```, ```<dt>```, and ```<dd>``` elements in our doc:\n\n ```\n dl { margin-left: 6px; }\n  dt { font-weight: bold; color: #217ac0; font-size: 110% }\n  dt { font-family: Consolas, \"Liberation Mono\", Courier }\n  dd { margin-left: 16px }\n```\nResult\nFinally let’s put all the snippets together and see what the rendered result looks like.\n\t\nNotice the following points about this rendered result:\n\n- Even though the instances of the ```<element-details>``` element in the document do not directly use the ```<details>``` element, they get rendered using ```<details>``` because the shadow root causes them to get populated with that.\n- Within the rendered ```<details>``` output, the content in the ```<element-details>``` elements fills the named slots from the shadow root. In other words, the DOM tree from the ```<element-details>``` elements get composed together with the content of the shadow root.\n- For both ```<element-details>``` elements, an *Attributes* heading gets automatically added from the shadow root before the position of the \"attributes\" named slot.\n- Because the first ```<element-details>``` has a ```<dl>``` element which explicitly references the \"attributes\" named slot from its shadow root, the contents of that ```<dl>``` replace the \"attributes\" named slot from the shadow root.\n- Because the second ```<element-details>``` doesn’t explicitly reference the \"attributes\" named slot from its shadow root, its content for that named slot gets filled with the default content for it from the shadow root.","references":"- [MDN - Using Templates and Slots](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)","featured_image_url":"https://codersnack.com/assets/images/web-components.png","slug":"web-components-templates-slots","weblink":"https://codersnack.com/web-components-templates-slots/","featured_image_preview":{"id":116,"name":"web-components.png","hash":"3b6d136b6dbf483185b25055e533b752","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/3b6d136b6dbf483185b25055e533b752.png","provider":"local","provider_metadata":null,"created_at":"2020-06-23T14:13:26.868Z","updated_at":"2020-06-23T14:13:26.868Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"Web component - Using templates and slots","created_at":"2020-06-23T14:13:54.695Z","updated_at":"2020-06-23T14:13:54.719Z"},{"id":85,"codersnack":{"id":86,"header":"LitElement Styles 1","created_at":"2020-08-20T21:31:57.650Z","updated_at":"2020-08-20T21:31:57.650Z","explanation":"This page describes how to add styles to your component.\n\nYour component’s template is rendered to its shadow DOM tree. **The styles you add to your component are automatically scoped to the shadow tree, so they don’t leak out and affect other elements**.\n\n### Add styles to your component\n\nFor optimal performance, define **scoped styles in a static ```styles``` property**.\n\nDefine styles in a tagged template literal, using the **css tag function**:\n\n```\nimport { LitElement, css, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return css`\n      div { color: red; }\n    `;\n  }\n  render() { \n    return html`\n      <div>I'm styled!</div> \n    `;\n  }\n}\n```\n\nThe styles you add to your component are scoped using **shadow DOM**. For a quick overview of shadow DOM styling, see Shadow DOM styling overview.\n\nThe value of the static styles property can be:\n\nA **single** tagged template literal.\n\n```\nstatic get styles() {\n  return css`...`;\n} \n```\nAn **array** of tagged template literals.\n\n```\nstatic get styles() {\n  return [ css`...`, css`...`];\n}\n```\nThe static styles property is usually the best way to add styles to your component, but there are some use cases you can’t handle this way ; for example, linking to an external style sheet. For alternate ways to add styles, see Define scoped styles in the template.\n\n#### Expressions in static styles\n\n**Static styles apply to all instances of a component**. Any expressions in CSS are evaluated once, then reused for all instances.\n\n> To allow for theming or per-instance style customization, use CSS variables and custom properties to create configurable styles.\n\nTo prevent LitElement-based components from evaluating potentially malicious code, **the css tag only allows nested expressions that are themselves css tagged strings or numbers.**\n\n```\nimport { LitElement, html, css } from 'lit-element';\n\nconst mainColor = css`red`;\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return css`\n      div { color: ${mainColor} }\n    `;\n  }\n  render() {\n    return html`<div>Some content in a div</div>`;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\nThis restriction exists to protect applications from security vulnerabilities whereby malicious styles, or even malicious code, can be injected from untrusted sources such as URL parameters or database values.\n\nIf you must use an expression in a css literal that is not itself a css literal, and **you are confident that the expression is from a fully trusted source** such as a constant defined in your own code, then you can wrap the expression with the **unsafeCSS** function:\n\n```\nimport { LitElement, html, css, unsafeCSS } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    const mainColor = 'red';\n\n    return css`\n      div { color: ${unsafeCSS(mainColor)} }\n    `;\n  }\n  render() {\n    return html`<div>Some content in a div</div>`;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n**Only use the unsafeCSS tag with trusted input**. Injecting unsanitized CSS is a security risk. For example, malicious CSS can “phone home” by adding an image URL that points to a third-party server.\n\n#### Inheriting styles\n\nUsing an array of tagged template literals, a component can **inherit the styles from a LitElement superclass,** and add its own styles:\n\n```\nclass MyElement extends SuperElement {\n  static get styles() {\n    return [\n      super.styles,\n      css`...`\n    ];\n  }\n}\n```\n\n#### Sharing styles\n\nYou can share styles between components by **creating a module that exports tagged styles**:\n\n```\nimport { css } from 'lit-element';\n\nexport const buttonStyles = css`\n  .blue-button {\n    color: white;\n    background-color: blue;\n  }\n  .blue-button:disabled {\n    background-color: grey;\n  }`;\n```\n\nYour element can then import the styles and add them to its static styles property:\n\n```\nimport { buttonStyles } from './button-styles.js';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return [\n      buttonStyles,\n      css`\n        :host { display: block;\n          border: 1px solid black;\n        }`\n    ]\n  }\n  ...\n}\n```\nYou can also **import an external style sheet** by adding a ```<link>```  element to your template, but this has a number of limitations. For details, see Import an external stylesheet.\n\n### Shadow DOM styling overview\n\nThis section gives a brief overview of shadow DOM styling.\n\nStyles you add to a component can affect:\n\n- The shadow tree (your component’s rendered template).\n- The component itself.\n- The component’s children.\n\n#### Style the shadow tree\n\nLitElement templates are rendered into a shadow tree by default. Styles scoped to an element’s shadow tree don’t affect the main document or other shadow trees. Similarly, with the exception of inherited CSS properties, **document-level styles don’t affect the contents of a shadow tree**.\n\n**When you use standard CSS selectors, they only match elements in your component’s shadow tree.**\n\n```\nclass MyElement extends LitElement {\n  static get styles() {\n    // Write styles in standard CSS\n    return css`\n      * { color: red; }\n      p { font-family: sans-serif; }\n      .myclass { margin: 100px; }\n      #main { padding: 30px; }\n      h1 { font-size: 4em; }\n    `;\n  }\n  render() {\n    return html`\n      <p>Hello World</p>\n      <p class=\"myclass\">Hello World</p>\n      <p id=\"main\">Hello World</p>\n      <h1>Hello World</h1>\n    `;\n  }\n}\n```\n\n#### Style the component itself\n\nYou can style the component itself using special ```:host selectors```. (The element that owns, or “hosts” a shadow tree is called the host element.)\n\nTo create default styles for the host element, use the ```:host``` CSS **pseudo-class** and ```:host()``` CSS **pseudo-class function**.\n\n```:host``` **selects the host element**.\n\n```:host(selector)``` selects the host element, but **only if the host element matches selector**.\n\n```\nstatic get styles() {\n  return css`\n    /* Selects the host element */\n    :host { \n      display: block; \n    }\n\n    /* Selects the host element if it is hidden */\n    :host([hidden]) { \n      display: none; \n    }\n  `;\n}\n```\nNote that the host element can be affected by styles from outside the shadow tree, as well, so you should consider the styles **you set in :host and :host() rules as default styles that can be overridden by the user**. For example:\n\n```\nmy-element {\n  display: inline-block;\n}\n```\n\n#### Style the component’s children\n\nYour component may accept children (like a ```<ul>``` element can have ```<li>``` children). To render children, **your template needs to include one or more ```<slot>``` elements**, as described in Render children with the slot element.\n\nThe ```<slot>``` element acts as a **placeholder in a shadow tree where the host element’s children are displayed**. For example:\n\n```\nclass MyElement extends LitElement {\n  render() {\n    return html`<slot></slot>`;\n  }\n}\n<my-element><p>Slotted content</p></my-element>\n```\n\nUse the ```::slotted()``` **CSS pseudo-element** to select children that are included in your template via ```<slot>```s.\n\n```::slotted(*)``` matches all slotted elements.\n\n```::slotted(p)``` matches slotted paragraphs.\n\n```p ::slotted(*)``` matches slotted elements where the <slot> is a descendant of a paragraph element.\n\n```\n<p>\n  <slot></slot>\n</p>\n```\n```\nimport { LitElement, html, css } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() {\n    return css`\n      ::slotted(*) { font-family: Roboto; }\n      ::slotted(p) { color: blue; }\n      div ::slotted(*) { color: red; }\n    `;\n  }\n  render() {\n    return html`\n      <slot></slot>\n      <div><slot name=\"hi\"></slot></div>\n    `;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```\n\nNote that only direct slotted children can be styled with ```::slotted()```.\n\n```\n<my-element>\n  <div>Stylable with ::slotted()</div>\n</my-element>\n\n<my-element>\n  <div><p>Not stylable with ::slotted()</p></div>\n</my-element>\n```\nAlso, **children can be styled from outside the shadow tree**, so you should regard your ```::slotted()``` **styles as default styles that can be overridden**.\n\n```\nmy-element div {\n  // Outside style targetting a slotted child can override ::slotted() styles\n}\n```\nWatch out for limitations in the Shady CSS polyfill around slotted content! See the Shady CSS limitations for details on how to use the ```::slotted()``` syntax in a polyfill-friendly way.\n\n#### Configurable styles with custom properties\n\n**Static styles are evaluated once per class. Use CSS variables and custom properties to make styles that can be configured at runtime**:\n\n```\nstatic get styles() {\n  return css`\n    :host { color: var(--themeColor); }\n  `;\n} \n<style>\n  html { \n    --themeColor: #123456;\n  }\n</style>\n<my-element></my-element>\n```\nSee the section on CSS custom properties for more information.\n\n","references":"- [LitElement styles](https://lit-element.polymer-project.org/guide/styles)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-styles","weblink":"https://codersnack.com/webcomponents-litelement-styles/","featured_image_preview":{"id":117,"name":"litelement-icon.png","hash":"605483703faa4a01b95975da4c744050","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/605483703faa4a01b95975da4c744050.png","provider":"local","provider_metadata":null,"created_at":"2020-08-20T21:31:57.669Z","updated_at":"2020-08-20T21:31:57.669Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElement Styles","created_at":"2020-08-20T21:32:29.613Z","updated_at":"2020-08-20T21:32:29.617Z"},{"id":86,"codersnack":{"id":87,"header":"LitElement Styles 2","created_at":"2020-08-21T14:02:13.403Z","updated_at":"2020-08-21T14:02:13.403Z","explanation":"### Define scoped styles in the template\n\n> We recommend using static styles for optimal performance. However, sometimes you may want to define styles in the LitElement template. \n\nThere are two ways to add scoped styles in the template:\n\n- Add styles using a ```<style>``` element.\n- Add styles using an **external style sheet**.\n\nEach of these techniques has its own set of **advantages and drawbacks**.\n\n#### In a style element\n\nWe recommend using static styles for optimal performance. However, **static styles are evaluated once per class. Sometimes, you might need to evaluate styles per instance.**\n\nWe recommend using CSS properties to create customizable styles. However, you can also include ```<style>``` elements in a LitElement template. These are **updated per instance**.\n\n```\nrender() {\n  return html`\n    <style>\n      /* updated per instance */\n    </style>\n    <div>template content</div>\n  `;\n}\n```\n\n### Expressions and style elements\n\nThe most intuitive way to evaluate per-instance styles has some important limitations and performance issues. We consider the example below to be an **anti-pattern**:\n\n```\n// Anti-pattern!\nrender() {\n  return html`\n    <style>\n      :host {\n        /* Warning: this approach has limitations & performance issues! */\n        color: ${myColor}\n      } \n    </style>\n    <div>template content</div>\n  `;\n}\n```\n> Expressions inside a ```<style>``` element won’t update per instance in ShadyCSS, due to limitations of the ShadyCSS polyfill. See the ShadyCSS readme for more information.\n\nAdditionally, evaluating an expression inside a ```<style>``` element is inefficient. When any text inside a ```<style>``` element changes, the **browser must re-parse the whole** ```<style>``` element, resulting in unnecessary work.\n\nIf you need to evaluate expressions inside a ```<style>``` element, use the following strategy to avoid creating performance problems:\n\n- **Separate styles that require per-instance evaluation from those that don’t**.\n\n- Evaluate per-instance CSS properties by **creating an expression that captures that property inside a complete** ```<style>``` block. Include it in your template.\n\nExample\n\n```\nimport { LitElement, html } from 'lit-element';\n\nconst perClassStyle = html`\n  <style>\n    :host {\n      display: block;\n      font-family: Roboto;\n      font-size: 14px; \n    }\n  </style>\n`;\n\nconst blueText = html`\n  <style> :host { color: blue; } </style>\n`;\n\nconst redText = html`\n  <style> :host { color: red; } </style>\n`;\n\nclass MyElement extends LitElement {\n  constructor() {\n    super();\n    this.perInstanceStyle = redText;\n  }\n  render() {\n    return html`\n      ${perClassStyle}\n      ${this.perInstanceStyle}\n      <div>Hello World</div>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\n#### Import an external stylesheet\n\nWe recommend placing your styles in a static styles property for optimal performance. However, **you can include an external style sheet in your template with a** ```<link>```:\n\n```\nimport { LitElement, html } from 'lit-element';\n\nclass MyElement extends LitElement {\n  render() {\n    return html`\n      <link rel=\"stylesheet\" href=\"./app-styles.css\">\n      <button>a button</button>\n      <div>a div</div>\n    `;\n  }\n}\n\ncustomElements.define('my-element', MyElement);\n```\n\nThere are some important caveats though:\n\n- The ShadyCSS polyfill doesn’t support external style sheets.\n\n- External styles can cause a **flash-of-unstyled-content (FOUC) ** while they load.\n\n- The URL in the **href attribute is relative to the main document**. This is okay if you’re building an app and your asset URLs are well-known, but **avoid using external style sheets when building a reusable element**.\n\n### Dynamic classes and styles\n\n**One way to make styles dynamic is to add bindings to the class or style attributes in your template.**\n\nThe **lit-html** library offers two **directives**, **classMap** and **styleMap**, to conveniently **apply classes and styles in HTML templates**.\n\nFor more information on these and other lit-html directives, see the documentation on lit-html built-in directives.\n\nTo use styleMap and/or classMap:\n\n- Import classMap and/or styleMap:\n\n```\nimport { classMap } from 'lit-html/directives/class-map';\nimport { styleMap } from 'lit-html/directives/style-map';\n```\n\n- Use **classMap** and/or **styleMap** in your element template:\n\n```\nconstructor() {\n  super();\n  this.classes = { mydiv: true, someclass: true };\n  this.styles = { color: 'green', fontFamily: 'Roboto' };\n}\nrender() {\n  return html`\n    <div class=${classMap(this.classes)} style=${styleMap(this.styles)}>\n      Some content\n    </div>\n  `;\n}\n```\n\n#### classMap syntax\n\nclassMap applies a set of classes to an HTML element:\n\n```\n<div class=${classMap({alert:true,info:true})}>Content.</div>\n<!-- Equivalent: <div class=\"alert info\">Content.</div> -->\n```\n\n#### styleMap syntax\n\nstyleMap applies a set of CSS rules to an HTML element:\n\n```\n<button style=${styleMap({\n  backgroundColor: 'blue',\n  border: '1px solid black'\n})}>A button</button>\n\n<!-- Equivalent: \n  <button style=\"\n    background-color:blue;\n    border: 1px solid black;\n  \">A button</button>\n-->\n```\n\nTo refer to hyphenated properties such as ```font-family```, use the camelCase equivalent (**fontFamily**) or place the hyphenated property name in quotes ('font-family').\n\nTo refer to custom CSS properties such as ```--custom-color```, place the whole property name in quotes ('--custom-color').\n\n**Inline style or CSS\t|     styleMap equivalent**\n\nbackground-color: blue; | backgroundColor: 'blue' or 'background-color': 'blue'\n\nfont-family: Roboto, Arial, sans-serif;\t|    fontFamily: 'Roboto, Arial, sans-serif' or 'font-family': 'Roboto, Arial, sans-serif'\n```--custom-color: #FFFABC;```\t|   \t'--custom-color': '#FFFABC;'\n```--otherCustomColor: #FFFABC;```\t|   \t'--otherCustomColor': '#FFFABC;'\n```color: var(--customprop, blue);```\t|   \tcolor: 'var(--customprop, blue)'\n\nExamples\n\n*Inline style syntax:*\n\n```\n<div style=\"\n  background-color:blue;\n  font-family:Roboto;\n  --custom-color:#e26dd2;\n  --otherCustomColor:#77e26d;\">\n</div>\n```\n*Equivalent CSS syntax:*\n\n```\ndiv {\n  background-color: blue;\n  font-family: Roboto;\n  --custom-color: #e26dd2;\n  --otherCustomColor: #77e26d;\n}\n```\n\n*Equivalent styleMap syntax:*\n\n```\nhtml`\n  <div style=${styleMap({\n    'background-color': 'blue',\n    fontFamily: 'Roboto',\n    '--custom-color': '#e26dd2',\n    '--otherCustomColor': '#77e26d'\n  })}></div>\n`\n```\n\n### Theming\n\nUse **CSS inheritance to propagate style information to LitElement** components and their rendered templates.\n\n```\n<style>\n  html {\n    --themeColor: #123456;\n    font-family: Roboto;\n  }\n</style>\n\n<!-- host inherits `--themeColor` and `font-family` and\n     passes these properties to its rendered template -->\n<my-element></my-element>\n```\n\n**Use CSS variables and custom properties to configure styles per-instance**.\n\n```\n<style>\n  html {\n    --my-element-background-color: /* some color */;\n  }\n  .stuff {\n    --my-element-background-color: /* some other color */;\n  }\n</style>\n\n<my-element></my-element>\n\n<my-element class=\"stuff\"></my-element>\n\n// MyElement's static styles\nstatic get styles() {\n  return css`\n    :host {\n      background-color: var(--my-element-background-color);\n    }\n  `;\n}\n```\n\n#### CSS inheritance\n\nCSS inheritance lets parent and host elements propagate certain CSS properties to their descendents.\n\n**Not all CSS properties inherit. Inherited CSS properties include**:\n\n- color\n- font-family and other font-* properties\n- All CSS custom properties (--*)\n\nSee CSS Inheritance on MDN for more information.\n\nYou can use CSS inheritance to set styles on an ancestor element that are inherited by its descendents:\n\n```\n<style>\nhtml { \n  font-family: Roboto;\n}\n</style>\n\n<div>\n  <p>Uses Roboto</p>\n</div>\n```\nSimilarly, **host elements pass down inheritable CSS properties to their shadow trees**.\n\nYou can use the **host element's type selector to style it**:\n\n```\n<style>\n  my-element { font-family: Roboto; }\n</style>\n\n<my-element></my-element>\n\nclass MyElement extends LitElement {\n  render() { \n    return html`<p>Uses Roboto</p>`; \n  }\n}\n```\n\nYou can also use the ```:host``` **CSS pseudo-class** to **style the host from inside** its own template:\n\n```\nstatic get styles() {\n  return css`\n    :host {\n      font-family: Roboto;\n    }\n  `;\n}\nrender() {\n  return html`\n    <p>Uses Roboto</p>\n  `;\n}\n```\n\n> Type selectors have higher specificity than ```:host```.\n\nAn element type selector has higher specificity than the ```:host``` pseudo-class selector. Styles set for a custom element tag will override styles set with :host and :host():\n\n```\n<style>\n  my-element { font-family: Courier; }\n</style>\n\n<my-element></my-element>\n\nclass MyElement extends LitElement {\n  static get styles() { \n    return css`:host { font-family: Roboto; }`\n  }\n  render() {\n    return html`<p>Will use courier</p>`;\n  }\n}\n```\n\n#### CSS custom properties\n\n**All CSS custom properties (--custom-property-name) inherit**. You can use this to make your component’s styles configurable from outside.\n\nThe following component sets its background color to a CSS variable. The CSS variable uses the value of --my-background if it’s available, and otherwise defaults to yellow:\n\n```\nclass MyElement extends LitElement {\n  static get styles() { \n    return css`\n      :host { \n        background-color: var(--my-background, yellow); \n      }\n    `;\n  }\n  render() {\n    return html`<p>Hello world</p>`;\n  }\n}\n```\n\nUsers of this component can set the value of --my-background, using the my-element tag as a CSS selector:\n\n```\n<style>\n  my-element {\n    --my-background: rgb(67, 156, 144);\n  }\n</style>\n\n<my-element></my-element>\n```\n```--my-background``` is configurable per instance of my-element:\n\n```\n<style>\n  my-element {\n    --my-background: rgb(67, 156, 144);\n  }\n  my-element.stuff {\n    --my-background: #111111;\n  }\n</style>\n<my-element></my-element>\n<my-element class=\"stuff\"></my-element>\n```\n\nIf a component user has an existing app theme, they can easily set the host’s configurable properties to use theme properties:\n\n```\n<html>\n  <head>\n    <title>lit-element code sample</title>\n    <script type=\"module\" src=\"./my-element.js\"></script>\n    <style>\n      html { --themeColor1: rgb(67, 156, 144); }\n      my-element {\n        --myBackground: var(--themeColor1);\n        --myColor: rgb(156, 67, 152);\n      }\n    </style>\n  </head>\n  <body>\n    <my-element></my-element>\n  </body>\n</html>\n```\nSee CSS Custom Properties on MDN for more information.\n\n*A simple example theme*\n**index.html**\n\n```\n<html>\n  <head>\n    <script type=\"module\" src=\"./my-element.js\"></script>\n    <title>lit-element code sample</title>\n    <style>\n      html {\n        --theme-primary: green;\n        --theme-secondary: aliceblue;\n        --theme-warning: red;\n        --theme-font-family: Roboto;\n      }\n      my-element { \n        --my-element-text-color: var(--theme-primary); \n        --my-element-background-color: var(--theme-secondary); \n        --my-element-font-family: var(--theme-font-family);\n      } \n      .warning {\n        --my-element-text-color: var(--theme-warning); \n      }\n    </style>\n  </head>\n  <body>\n    <my-element></my-element>\n    <my-element class=\"warning\"></my-element>\n  </body>\n</html>\n```\n\n**my-element.js**\n\n```\nimport { LitElement, html, css } from 'lit-element';\n\nclass MyElement extends LitElement {\n  static get styles() { \n    return css`\n      :host { \n        display: block;\n        color: var(--my-element-text-color, black); \n        background: var(--my-element-background-color, white);  \n        font-family: var(--my-element-font-family, Roboto);\n      }\n      :host([hidden]) {\n        display: none;\n      }\n    `;\n  }\n  render() {\n    return html`<div>Hello World</div>`;\n  }\n}\ncustomElements.define('my-element', MyElement);\n```","references":"- [LitElement styles](https://lit-element.polymer-project.org/guide/styles)","featured_image_url":"https://codersnack.com/assets/images/litelement-icon.png","slug":"webcomponents-litelement-styles-ii","weblink":"https://codersnack.com/webcomponents-litelement-styles-ii/","featured_image_preview":{"id":118,"name":"litelement-icon.png","hash":"140e68e8867c4ae288bd9d4f4ce7e29f","sha256":"-aHl0Bik6YlRAZjeF_3e2fKkddHq3GlbCgQmgbQJtV4","ext":".png","mime":"image/png","size":42.89,"url":"/uploads/140e68e8867c4ae288bd9d4f4ce7e29f.png","provider":"local","provider_metadata":null,"created_at":"2020-08-21T14:02:13.443Z","updated_at":"2020-08-21T14:02:13.443Z"}},"codersnacks_category":{"id":12,"header":"Web Components","description":"A suite of different technologies allowing you to create reusable custom elements","snacks_by_cat_json_filename":"web-components.snacks.json","key":"web-components","image_url":"https://codersnack.com/assets/images/web-components.png","created_at":"2020-02-29T10:42:15.051Z","updated_at":"2020-02-29T10:42:15.051Z","image_preview":{"id":69,"name":"web-components.png","hash":"a95cfe0b4c79426e962dcbbc966295af","sha256":"93NexSi0bgOKCGBXbSzV0GZdf--UheqoweWQ1Lpe4sw","ext":".png","mime":"image/png","size":14.14,"url":"/uploads/a95cfe0b4c79426e962dcbbc966295af.png","provider":"local","provider_metadata":null,"created_at":"2020-02-29T10:42:15.067Z","updated_at":"2020-02-29T10:42:15.067Z"}},"title":"LitElements Style 2","created_at":"2020-08-21T14:02:45.364Z","updated_at":"2020-08-21T14:02:45.369Z"}]