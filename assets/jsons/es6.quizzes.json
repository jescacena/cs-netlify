[{"id":1,"codersnack":{"id":1,"header":"ES6 let and closures","created_at":"2019-12-30T18:56:27.814Z","updated_at":"2021-10-29T10:32:21.011Z","explanation":"Functions can be nested inside other functions. \nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){ \n       console.log(x); \n    }\n    log();\n})();\n```\nlog() is a nested function inside the autorun() function.log() accesses the variable x from its outer function. The log() function is a closure.\n\n> **Closures** are inner functions. Closures can be created by defining a function inside another function or inside a block.\n> **Lexical scope** is the ability of the inner function to access the outer scope in which it is defined.\nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){\n      console.log(x);\n    };\n    \n    function run(fn){\n      let x = 100;\n      fn();\n    }\n    \n    run(log);//1\n})();\n```\n\nThe log function is a closure. It refers the x variable from its parent function autorun() , not the one from the run() function.\n> The closure function has access to the scope in which it was created, not the scope in which it is executed.\n\nThe local function scope of autorun() is the lexical scope of the log() function.\n\n> Closures store references of outer variables, they do not copy the actual values.\n\nThe for loop statement, with the let declaration, creates a new variable local to the block scope, for each iteration. The next loop creates five closures over five different i variables.\n\n```\n(function run(){\n  for(let i=0; i<5; i++){\n    setTimeout(function log(){\n      console.log(i); //0 1 2 3 4\n    }, 100);\n  }\n})();\n```\nWriting the same code with var will create five closures, over the same variable, so all closures will display the last value of i . The log() function is a closure\n\n","references":"- [[Medium] Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)\n- [[Medium] These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)","featured_image_url":"https://codersnack.com/assets/images/es6-let-closure.png","slug":"es6-let-closures","weblink":"https://codersnack.com/es6-let-closures/","featured_image_preview":{"id":1,"name":"es6-let-closure.png","hash":"fbc6a364da1748bea449d8b8c1f818bd","sha256":"T_ihZTRaAcE59QoXy89nBis36SNKXYyNZ2x8-5yYvBw","ext":".png","mime":"image/png","size":9.35,"url":"/uploads/fbc6a364da1748bea449d8b8c1f818bd.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T18:58:50.917Z","updated_at":"2019-12-30T18:58:50.917Z"}},"codersnacks_quiz":{"id":1,"question":"What is the scope of a variable?","response_valid":"It defines the lifetime and visibility of a variable. Variables are not visible outside the scope in which they are declared","response_invalid1":"The amount of space reserved in memory","response_invalid2":"The type of the variable","created_at":"2019-12-31T16:43:12.240Z","updated_at":"2019-12-31T16:43:12.240Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6 - es6 let and closures - what is the scope...","created_at":"2019-12-31T16:47:52.604Z","updated_at":"2019-12-31T20:30:25.033Z"},{"id":2,"codersnack":{"id":1,"header":"ES6 let and closures","created_at":"2019-12-30T18:56:27.814Z","updated_at":"2021-10-29T10:32:21.011Z","explanation":"Functions can be nested inside other functions. \nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){ \n       console.log(x); \n    }\n    log();\n})();\n```\nlog() is a nested function inside the autorun() function.log() accesses the variable x from its outer function. The log() function is a closure.\n\n> **Closures** are inner functions. Closures can be created by defining a function inside another function or inside a block.\n> **Lexical scope** is the ability of the inner function to access the outer scope in which it is defined.\nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){\n      console.log(x);\n    };\n    \n    function run(fn){\n      let x = 100;\n      fn();\n    }\n    \n    run(log);//1\n})();\n```\n\nThe log function is a closure. It refers the x variable from its parent function autorun() , not the one from the run() function.\n> The closure function has access to the scope in which it was created, not the scope in which it is executed.\n\nThe local function scope of autorun() is the lexical scope of the log() function.\n\n> Closures store references of outer variables, they do not copy the actual values.\n\nThe for loop statement, with the let declaration, creates a new variable local to the block scope, for each iteration. The next loop creates five closures over five different i variables.\n\n```\n(function run(){\n  for(let i=0; i<5; i++){\n    setTimeout(function log(){\n      console.log(i); //0 1 2 3 4\n    }, 100);\n  }\n})();\n```\nWriting the same code with var will create five closures, over the same variable, so all closures will display the last value of i . The log() function is a closure\n\n","references":"- [[Medium] Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)\n- [[Medium] These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)","featured_image_url":"https://codersnack.com/assets/images/es6-let-closure.png","slug":"es6-let-closures","weblink":"https://codersnack.com/es6-let-closures/","featured_image_preview":{"id":1,"name":"es6-let-closure.png","hash":"fbc6a364da1748bea449d8b8c1f818bd","sha256":"T_ihZTRaAcE59QoXy89nBis36SNKXYyNZ2x8-5yYvBw","ext":".png","mime":"image/png","size":9.35,"url":"/uploads/fbc6a364da1748bea449d8b8c1f818bd.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T18:58:50.917Z","updated_at":"2019-12-30T18:58:50.917Z"}},"codersnacks_quiz":{"id":2,"question":"In which way let variables are affecting javascript closures?","response_valid":"As a let variable allow defining block scope variables , we can fix some var problems in ES5","response_invalid1":"in any way","response_invalid2":"you can change the scope of a variable to accessing other scopes","created_at":"2019-12-31T16:44:06.861Z","updated_at":"2019-12-31T16:44:06.861Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6 - es6 let and closures - in which way let ...","created_at":"2019-12-31T16:49:11.726Z","updated_at":"2019-12-31T20:30:44.928Z"},{"id":4,"codersnack":{"id":2,"header":"ES6 let and const","created_at":"2019-12-31T16:35:45.883Z","updated_at":"2020-04-20T19:03:20.605Z","explanation":"There are two ways for declaring a variable (let and const) plus one that has become obsolete (var).\n\n## let\n\n**let declares and optionally initializes a variable in the current scope**. The current scope can be either a module, a function or a block. The value of a variable that is not initialized is undefined.\nScope defines the lifetime and visibility of a variable. Variables are not visible outside the scope in which they are declared.\nConsider the next code that emphasizes let block scope:\n```\nlet x = 1;\n{ \n  let x = 2;\n}\nconsole.log(x); //1\n```\nIn contrast, the var declaration had no block scope:\n```\nvar x = 1;\n{ \n  var x = 2;\n}\nconsole.log(x); //2\n```\n\n## const\n\n**const declares a variable that cannot be reassigned**. It becomes a constant only when the assigned value is immutable.\nAn immutable value is a value that, once created, cannot be changed. \n\n> Primitive values are immutable, objects are mutable.\n\n**```const``` freezes the variable, ```Object.freeze()```  freezes the object.**\n\n**The initialization of the ```const``` variable is mandatory.**\n","references":"- [Medium - These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)\n- [Medium - Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)","featured_image_url":"https://codersnack.com/assets/images/es6-let-const.png","slug":"es6-let-const","weblink":"https://codersnack.com/es6-let-const/","featured_image_preview":{"id":3,"name":"es6-let-const.png","hash":"948e28b024e349818929b0c12c071613","sha256":"2zlsGi4zWiNhlovCU5Vj5PG7oZbokWm2d-9p_RNCB-g","ext":".png","mime":"image/png","size":36.12,"url":"/uploads/948e28b024e349818929b0c12c071613.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T16:35:45.896Z","updated_at":"2019-12-31T16:35:45.896Z"}},"codersnacks_quiz":{"id":3,"question":"is it mandatory initialize a const variable?","response_valid":"Always","response_invalid1":"It depends on being a variable or an object","response_invalid2":"Never","created_at":"2019-12-31T20:25:41.602Z","updated_at":"2019-12-31T20:25:41.602Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6 - es6 let and const - it is mandatory initialize ...","created_at":"2019-12-31T20:32:24.682Z","updated_at":"2019-12-31T20:33:46.897Z"},{"id":8,"codersnack":{"id":7,"header":"ES6 modules","created_at":"2020-01-06T18:32:38.545Z","updated_at":"2020-02-23T00:27:01.866Z","explanation":"Before modules, a variable declared outside any function was a global variable.\n\n**With modules, a variable declared outside any function is hidden and not available to other modules unless it is explicitly exported**.\n\n*Exporting makes a function or object available to other modules*. In the next example, I export functions from different modules:\n\n```\n//module \"./TodoStore.js\"\nexport default function TodoStore(){}\n\n//module \"./UserStore.js\"\nexport default function UserStore(){}\n```\n\n*Importing makes a function or object, from other modules, available to the current module*.\n\n```\nimport TodoStore from \"./TodoStore\";\nimport UserStore from \"./UserStore\";\n\nconst todoStore = TodoStore();\nconst userStore = UserStore();\n```","references":"- [These are the features in es6 that you should know](https://www.freecodecamp.org/news/these-are-the-features-in-es6-that-you-should-know-1411194c71cb/)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-modules","weblink":"https://codersnack.com/es6-modules/","featured_image_preview":{"id":10,"name":"ECMAScript-01.png","hash":"ec1784864262409a869888331ef51b2b","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/ec1784864262409a869888331ef51b2b.png","provider":"local","provider_metadata":null,"created_at":"2020-01-06T18:32:38.559Z","updated_at":"2020-01-06T18:32:38.559Z"}},"codersnacks_quiz":{"id":8,"question":"Es6 modules - Check the valid sentence","response_valid":"Importing makes a function or object, from other modules, available to the current module","response_invalid1":"Export a functions makes that function available to the whole app","response_invalid2":"Modules are only for organize functions","created_at":"2020-01-06T18:35:42.763Z","updated_at":"2020-01-06T18:35:42.763Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6-modules-true-sentence","created_at":"2020-01-06T18:36:11.778Z","updated_at":"2020-01-06T18:36:11.781Z"},{"id":59,"codersnack":{"id":71,"header":"ES6 classes","created_at":"2020-04-22T19:15:11.222Z","updated_at":"2020-04-22T19:15:11.222Z","explanation":"JavaScript classes, introduced in ECMAScript 2015, are primarily **syntactical sugar over JavaScript's existing prototype-based inheritance**. The class syntax *does not introduce a new object-oriented inheritance model* to JavaScript.\n\n### Defining classes\n**Classes are in fact \"special functions\",** and just as you can define function expressions and function declarations, the class syntax has two components: class expressions and class declarations.\n\n#### Class declarations\nOne way to define a class is using a class declaration. To declare a class, you use the ```class``` keyword with the name of the class (\"Rectangle\" here).\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n```\n#### Hoisting\nAn important difference between function declarations and class declarations is that function declarations are hoisted and class declarations are not. **You first need to declare your class and then access it**, otherwise code like the following will throw a **ReferenceError**:\n\n```\nconst p = new Rectangle(); // ReferenceError\n\nclass Rectangle {}\n```\n\n#### Class expressions\n**A class expression is another way to define a class**. Class expressions can be **named** or **unnamed**. The name given to a named class expression is local to the class's body. (it can be retrieved through the class's (not an instance's) name property, though).\n\n```\n// unnamed\nlet Rectangle = class {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle\"\n\n// named\nlet Rectangle = class Rectangle2 {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle2\"\n```\n\n> Note: Class expressions are subject to the same hoisting restrictions as described in the Class declarations section.\n\n### Class body and method definitions\n**The body of a class is the part that is in curly brackets {}**. This is where you define **class members,** such as methods or **constructor**.\n\n#### Strict mode\n**The body of a class is executed in strict mode**, i.e., **code written here is subject to stricter syntax for increased performance**, some otherwise silent errors will be thrown, and certain keywords are reserved for future versions of ECMAScript.\n\n#### Constructor\n**The constructor method is a special method for creating and initializing an object created with a class**. There can only be one special method with the name \"constructor\" in a class. A SyntaxError will be thrown if the class contains more than one occurrence of a constructor method.\n\nA constructor can use the ```super``` keyword **to call the constructor of the super class**.\n\n#### Prototype methods\nSee also method definitions.\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n  // Getter\n  get area() {\n    return this.calcArea();\n  }\n  // Method\n  calcArea() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Rectangle(10, 10);\n\nconsole.log(square.area); // 100\n```\n\n#### Static methods\nThe ```static``` keyword **defines a static method for a class.** Static methods **are called without instantiating their class and cannot be called through a class instance**. Static methods are often used to create utility functions for an application.\n\n```\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  static distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n\n    return Math.hypot(dx, dy);\n  }\n}\n\nconst p1 = new Point(5, 5);\nconst p2 = new Point(10, 10);\np1.distance; //undefined\np2.distance; //undefined\n\nconsole.log(Point.distance(p1, p2)); // 7.0710678118654755\n```\n#### Boxing with prototype and static methods\n**When a static or prototype method is called without a value for this, the this value will be undefined inside the method**. This behavior will be the same even if the \"use strict\" directive isn't present, because code within the class body's syntactic boundary is always executed in strict mode.\n\n```\nclass Animal { \n  speak() {\n    return this;\n  }\n  static eat() {\n    return this;\n  }\n}\n\nlet obj = new Animal();\nobj.speak(); // the Animal object\nlet speak = obj.speak;\nspeak(); // undefined\n\nAnimal.eat() // class Animal\nlet eat = Animal.eat;\neat(); // undefined\n```\n\n**If the above is written using traditional function-based syntax, then autoboxing in method calls will happen in non–strict mode based on the initial this value**. If the initial value is undefined, this will be set to the global object.\n\nAutoboxing will not happen in strict mode, the this value remains as passed.\n\n```\nfunction Animal() { }\n\nAnimal.prototype.speak = function() {\n  return this;\n}\n\nAnimal.eat = function() {\n  return this;\n}\n\nlet obj = new Animal();\nlet speak = obj.speak;\nspeak(); // global object\n\nlet eat = Animal.eat;\neat(); // global object\n```\n\n#### Instance properties\nInstance properties must be defined inside of class methods:\n\n```\nclass Rectangle {\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\n\nStatic (class-side) data properties and prototype data properties must be defined outside of the ClassBody declaration:\n\n```\nRectangle.staticWidth = 20;\nRectangle.prototype.prototypeWidth = 25;\n```\n#### Field declarations\n> **Public and private field declarations are an experimental feature (stage 3) proposed at TC39**, the JavaScript standards committee. Support in browsers is limited, but the feature can be used through a build step with systems like Babel.\n\n#### Public field declarations\nWith the JavaScript field declaration syntax, the above example can be written as:\n\n```\nclass Rectangle {\n  height = 0;\n  width;\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\nBy declaring fields up-front, **class definitions become more self-documenting**, and the fields are always present.\n\nAs seen above, the fields can be declared with or without a default value.\n\n#### Private field declarations\nUsing private fields, the definition can be refined as below.\n\n```\nclass Rectangle {\n  #height = 0;\n  #width;\n  constructor(height, width) {    \n    this.#height = height;\n    this.#width = width;\n  }\n}\n```\nIt's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things which are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change version to version.\n\nPrivate fields can only be declared up-front in a field declaration.\n\nPrivate fields cannot be created later through assigning to them, the way that normal properties can.\n\n\n### Sub classing with extends\nThe ```extends``` keyword is used in class declarations or class expressions to create a class as a child of another class.\n\n```\nclass Animal { \n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name); // call the super class constructor and pass in the name parameter\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n```\nIf there is a constructor present in the subclass, it needs to first call super() before using \"this\".\n\nOne may also extend traditional function-based \"classes\":\n\n```\nfunction Animal (name) {\n  this.name = name;  \n}\n\nAnimal.prototype.speak = function () {\n  console.log(`${this.name} makes a noise.`);\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n\n//NB: For similar methods, the child's method takes precedence over parent's method\n```\n\n**Note that classes cannot extend regular (non-constructible) objects**. If you want to inherit from a regular object, you can instead use **Object.setPrototypeOf()**:\n\n```\nconst Animal = {\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n};\n\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// If you do not do this you will get a TypeError when you invoke speak\nObject.setPrototypeOf(Dog.prototype, Animal);\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie makes a noise.\n```\n","references":"- [MDN classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-classes","weblink":"https://codersnack.com/es6-classes/","featured_image_preview":{"id":98,"name":"ECMAScript-01.png","hash":"d3322ef305414d6c9c3e83734a95b650","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/d3322ef305414d6c9c3e83734a95b650.png","provider":"local","provider_metadata":null,"created_at":"2020-04-22T19:15:11.249Z","updated_at":"2020-04-22T19:15:11.249Z"}},"codersnacks_quiz":{"id":59,"question":"ES6 classes - Instance properties must be defined ...","response_valid":"inside of class methods","response_invalid1":"at the top of the class body","response_invalid2":"inside of constructor method","created_at":"2020-04-22T19:17:54.543Z","updated_at":"2020-04-22T19:17:54.543Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"Es6 classes - instance properties","created_at":"2020-04-22T19:18:29.721Z","updated_at":"2020-04-22T19:18:29.730Z"}]