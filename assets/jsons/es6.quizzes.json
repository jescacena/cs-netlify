[{"id":1,"codersnack":{"id":1,"header":"ES6 let and closures","created_at":"2019-12-30T18:56:27.814Z","updated_at":"2021-10-29T10:32:21.011Z","explanation":"Functions can be nested inside other functions. \nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){ \n       console.log(x); \n    }\n    log();\n})();\n```\nlog() is a nested function inside the autorun() function.log() accesses the variable x from its outer function. The log() function is a closure.\n\n> **Closures** are inner functions. Closures can be created by defining a function inside another function or inside a block.\n> **Lexical scope** is the ability of the inner function to access the outer scope in which it is defined.\nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){\n      console.log(x);\n    };\n    \n    function run(fn){\n      let x = 100;\n      fn();\n    }\n    \n    run(log);//1\n})();\n```\n\nThe log function is a closure. It refers the x variable from its parent function autorun() , not the one from the run() function.\n> The closure function has access to the scope in which it was created, not the scope in which it is executed.\n\nThe local function scope of autorun() is the lexical scope of the log() function.\n\n> Closures store references of outer variables, they do not copy the actual values.\n\nThe for loop statement, with the let declaration, creates a new variable local to the block scope, for each iteration. The next loop creates five closures over five different i variables.\n\n```\n(function run(){\n  for(let i=0; i<5; i++){\n    setTimeout(function log(){\n      console.log(i); //0 1 2 3 4\n    }, 100);\n  }\n})();\n```\nWriting the same code with var will create five closures, over the same variable, so all closures will display the last value of i . The log() function is a closure\n\n","references":"- [[Medium] Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)\n- [[Medium] These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)","featured_image_url":"https://codersnack.com/assets/images/es6-let-closure.png","slug":"es6-let-closures","weblink":"https://codersnack.com/es6-let-closures/","featured_image_preview":{"id":1,"name":"es6-let-closure.png","hash":"fbc6a364da1748bea449d8b8c1f818bd","sha256":"T_ihZTRaAcE59QoXy89nBis36SNKXYyNZ2x8-5yYvBw","ext":".png","mime":"image/png","size":9.35,"url":"/uploads/fbc6a364da1748bea449d8b8c1f818bd.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T18:58:50.917Z","updated_at":"2019-12-30T18:58:50.917Z"}},"codersnacks_quiz":{"id":1,"question":"What is the scope of a variable?","response_valid":"It defines the lifetime and visibility of a variable. Variables are not visible outside the scope in which they are declared","response_invalid1":"The amount of space reserved in memory","response_invalid2":"The type of the variable","created_at":"2019-12-31T16:43:12.240Z","updated_at":"2019-12-31T16:43:12.240Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6 - es6 let and closures - what is the scope...","created_at":"2019-12-31T16:47:52.604Z","updated_at":"2019-12-31T20:30:25.033Z"},{"id":2,"codersnack":{"id":1,"header":"ES6 let and closures","created_at":"2019-12-30T18:56:27.814Z","updated_at":"2021-10-29T10:32:21.011Z","explanation":"Functions can be nested inside other functions. \nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){ \n       console.log(x); \n    }\n    log();\n})();\n```\nlog() is a nested function inside the autorun() function.log() accesses the variable x from its outer function. The log() function is a closure.\n\n> **Closures** are inner functions. Closures can be created by defining a function inside another function or inside a block.\n> **Lexical scope** is the ability of the inner function to access the outer scope in which it is defined.\nConsider the next code:\n\n```\n(function autorun(){\n    let x = 1;\n    function log(){\n      console.log(x);\n    };\n    \n    function run(fn){\n      let x = 100;\n      fn();\n    }\n    \n    run(log);//1\n})();\n```\n\nThe log function is a closure. It refers the x variable from its parent function autorun() , not the one from the run() function.\n> The closure function has access to the scope in which it was created, not the scope in which it is executed.\n\nThe local function scope of autorun() is the lexical scope of the log() function.\n\n> Closures store references of outer variables, they do not copy the actual values.\n\nThe for loop statement, with the let declaration, creates a new variable local to the block scope, for each iteration. The next loop creates five closures over five different i variables.\n\n```\n(function run(){\n  for(let i=0; i<5; i++){\n    setTimeout(function log(){\n      console.log(i); //0 1 2 3 4\n    }, 100);\n  }\n})();\n```\nWriting the same code with var will create five closures, over the same variable, so all closures will display the last value of i . The log() function is a closure\n\n","references":"- [[Medium] Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)\n- [[Medium] These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)","featured_image_url":"https://codersnack.com/assets/images/es6-let-closure.png","slug":"es6-let-closures","weblink":"https://codersnack.com/es6-let-closures/","featured_image_preview":{"id":1,"name":"es6-let-closure.png","hash":"fbc6a364da1748bea449d8b8c1f818bd","sha256":"T_ihZTRaAcE59QoXy89nBis36SNKXYyNZ2x8-5yYvBw","ext":".png","mime":"image/png","size":9.35,"url":"/uploads/fbc6a364da1748bea449d8b8c1f818bd.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T18:58:50.917Z","updated_at":"2019-12-30T18:58:50.917Z"}},"codersnacks_quiz":{"id":2,"question":"In which way let variables are affecting javascript closures?","response_valid":"As a let variable allow defining block scope variables , we can fix some var problems in ES5","response_invalid1":"in any way","response_invalid2":"you can change the scope of a variable to accessing other scopes","created_at":"2019-12-31T16:44:06.861Z","updated_at":"2019-12-31T16:44:06.861Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6 - es6 let and closures - in which way let ...","created_at":"2019-12-31T16:49:11.726Z","updated_at":"2019-12-31T20:30:44.928Z"},{"id":4,"codersnack":{"id":2,"header":"ES6 let and const","created_at":"2019-12-31T16:35:45.883Z","updated_at":"2020-04-20T19:03:20.605Z","explanation":"There are two ways for declaring a variable (let and const) plus one that has become obsolete (var).\n\n## let\n\n**let declares and optionally initializes a variable in the current scope**. The current scope can be either a module, a function or a block. The value of a variable that is not initialized is undefined.\nScope defines the lifetime and visibility of a variable. Variables are not visible outside the scope in which they are declared.\nConsider the next code that emphasizes let block scope:\n```\nlet x = 1;\n{ \n  let x = 2;\n}\nconsole.log(x); //1\n```\nIn contrast, the var declaration had no block scope:\n```\nvar x = 1;\n{ \n  var x = 2;\n}\nconsole.log(x); //2\n```\n\n## const\n\n**const declares a variable that cannot be reassigned**. It becomes a constant only when the assigned value is immutable.\nAn immutable value is a value that, once created, cannot be changed. \n\n> Primitive values are immutable, objects are mutable.\n\n**```const``` freezes the variable, ```Object.freeze()```  freezes the object.**\n\n**The initialization of the ```const``` variable is mandatory.**\n","references":"- [Medium - These are the features in es6 that you should know](https://medium.freecodecamp.org/these-are-the-features-in-es6-that-you-should-know-1411194c71cb)\n- [Medium - Discover the power of closures in javascript](https://medium.freecodecamp.org/discover-the-power-of-closures-in-javascript-5c472a7765d7)","featured_image_url":"https://codersnack.com/assets/images/es6-let-const.png","slug":"es6-let-const","weblink":"https://codersnack.com/es6-let-const/","featured_image_preview":{"id":3,"name":"es6-let-const.png","hash":"948e28b024e349818929b0c12c071613","sha256":"2zlsGi4zWiNhlovCU5Vj5PG7oZbokWm2d-9p_RNCB-g","ext":".png","mime":"image/png","size":36.12,"url":"/uploads/948e28b024e349818929b0c12c071613.png","provider":"local","provider_metadata":null,"created_at":"2019-12-31T16:35:45.896Z","updated_at":"2019-12-31T16:35:45.896Z"}},"codersnacks_quiz":{"id":3,"question":"is it mandatory initialize a const variable?","response_valid":"Always","response_invalid1":"It depends on being a variable or an object","response_invalid2":"Never","created_at":"2019-12-31T20:25:41.602Z","updated_at":"2019-12-31T20:25:41.602Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6 - es6 let and const - it is mandatory initialize ...","created_at":"2019-12-31T20:32:24.682Z","updated_at":"2019-12-31T20:33:46.897Z"},{"id":8,"codersnack":{"id":7,"header":"ES6 modules","created_at":"2020-01-06T18:32:38.545Z","updated_at":"2020-02-23T00:27:01.866Z","explanation":"Before modules, a variable declared outside any function was a global variable.\n\n**With modules, a variable declared outside any function is hidden and not available to other modules unless it is explicitly exported**.\n\n*Exporting makes a function or object available to other modules*. In the next example, I export functions from different modules:\n\n```\n//module \"./TodoStore.js\"\nexport default function TodoStore(){}\n\n//module \"./UserStore.js\"\nexport default function UserStore(){}\n```\n\n*Importing makes a function or object, from other modules, available to the current module*.\n\n```\nimport TodoStore from \"./TodoStore\";\nimport UserStore from \"./UserStore\";\n\nconst todoStore = TodoStore();\nconst userStore = UserStore();\n```","references":"- [These are the features in es6 that you should know](https://www.freecodecamp.org/news/these-are-the-features-in-es6-that-you-should-know-1411194c71cb/)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-modules","weblink":"https://codersnack.com/es6-modules/","featured_image_preview":{"id":10,"name":"ECMAScript-01.png","hash":"ec1784864262409a869888331ef51b2b","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/ec1784864262409a869888331ef51b2b.png","provider":"local","provider_metadata":null,"created_at":"2020-01-06T18:32:38.559Z","updated_at":"2020-01-06T18:32:38.559Z"}},"codersnacks_quiz":{"id":8,"question":"Es6 modules - Check the valid sentence","response_valid":"Importing makes a function or object, from other modules, available to the current module","response_invalid1":"Export a functions makes that function available to the whole app","response_invalid2":"Modules are only for organize functions","created_at":"2020-01-06T18:35:42.763Z","updated_at":"2020-01-06T18:35:42.763Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"es6-modules-true-sentence","created_at":"2020-01-06T18:36:11.778Z","updated_at":"2020-01-06T18:36:11.781Z"},{"id":59,"codersnack":{"id":71,"header":"ES6 classes","created_at":"2020-04-22T19:15:11.222Z","updated_at":"2020-04-22T19:15:11.222Z","explanation":"JavaScript classes, introduced in ECMAScript 2015, are primarily **syntactical sugar over JavaScript's existing prototype-based inheritance**. The class syntax *does not introduce a new object-oriented inheritance model* to JavaScript.\n\n### Defining classes\n**Classes are in fact \"special functions\",** and just as you can define function expressions and function declarations, the class syntax has two components: class expressions and class declarations.\n\n#### Class declarations\nOne way to define a class is using a class declaration. To declare a class, you use the ```class``` keyword with the name of the class (\"Rectangle\" here).\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n```\n#### Hoisting\nAn important difference between function declarations and class declarations is that function declarations are hoisted and class declarations are not. **You first need to declare your class and then access it**, otherwise code like the following will throw a **ReferenceError**:\n\n```\nconst p = new Rectangle(); // ReferenceError\n\nclass Rectangle {}\n```\n\n#### Class expressions\n**A class expression is another way to define a class**. Class expressions can be **named** or **unnamed**. The name given to a named class expression is local to the class's body. (it can be retrieved through the class's (not an instance's) name property, though).\n\n```\n// unnamed\nlet Rectangle = class {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle\"\n\n// named\nlet Rectangle = class Rectangle2 {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle2\"\n```\n\n> Note: Class expressions are subject to the same hoisting restrictions as described in the Class declarations section.\n\n### Class body and method definitions\n**The body of a class is the part that is in curly brackets {}**. This is where you define **class members,** such as methods or **constructor**.\n\n#### Strict mode\n**The body of a class is executed in strict mode**, i.e., **code written here is subject to stricter syntax for increased performance**, some otherwise silent errors will be thrown, and certain keywords are reserved for future versions of ECMAScript.\n\n#### Constructor\n**The constructor method is a special method for creating and initializing an object created with a class**. There can only be one special method with the name \"constructor\" in a class. A SyntaxError will be thrown if the class contains more than one occurrence of a constructor method.\n\nA constructor can use the ```super``` keyword **to call the constructor of the super class**.\n\n#### Prototype methods\nSee also method definitions.\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n  // Getter\n  get area() {\n    return this.calcArea();\n  }\n  // Method\n  calcArea() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Rectangle(10, 10);\n\nconsole.log(square.area); // 100\n```\n\n#### Static methods\nThe ```static``` keyword **defines a static method for a class.** Static methods **are called without instantiating their class and cannot be called through a class instance**. Static methods are often used to create utility functions for an application.\n\n```\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  static distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n\n    return Math.hypot(dx, dy);\n  }\n}\n\nconst p1 = new Point(5, 5);\nconst p2 = new Point(10, 10);\np1.distance; //undefined\np2.distance; //undefined\n\nconsole.log(Point.distance(p1, p2)); // 7.0710678118654755\n```\n#### Boxing with prototype and static methods\n**When a static or prototype method is called without a value for this, the this value will be undefined inside the method**. This behavior will be the same even if the \"use strict\" directive isn't present, because code within the class body's syntactic boundary is always executed in strict mode.\n\n```\nclass Animal { \n  speak() {\n    return this;\n  }\n  static eat() {\n    return this;\n  }\n}\n\nlet obj = new Animal();\nobj.speak(); // the Animal object\nlet speak = obj.speak;\nspeak(); // undefined\n\nAnimal.eat() // class Animal\nlet eat = Animal.eat;\neat(); // undefined\n```\n\n**If the above is written using traditional function-based syntax, then autoboxing in method calls will happen in non–strict mode based on the initial this value**. If the initial value is undefined, this will be set to the global object.\n\nAutoboxing will not happen in strict mode, the this value remains as passed.\n\n```\nfunction Animal() { }\n\nAnimal.prototype.speak = function() {\n  return this;\n}\n\nAnimal.eat = function() {\n  return this;\n}\n\nlet obj = new Animal();\nlet speak = obj.speak;\nspeak(); // global object\n\nlet eat = Animal.eat;\neat(); // global object\n```\n\n#### Instance properties\nInstance properties must be defined inside of class methods:\n\n```\nclass Rectangle {\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\n\nStatic (class-side) data properties and prototype data properties must be defined outside of the ClassBody declaration:\n\n```\nRectangle.staticWidth = 20;\nRectangle.prototype.prototypeWidth = 25;\n```\n#### Field declarations\n> **Public and private field declarations are an experimental feature (stage 3) proposed at TC39**, the JavaScript standards committee. Support in browsers is limited, but the feature can be used through a build step with systems like Babel.\n\n#### Public field declarations\nWith the JavaScript field declaration syntax, the above example can be written as:\n\n```\nclass Rectangle {\n  height = 0;\n  width;\n  constructor(height, width) {    \n    this.height = height;\n    this.width = width;\n  }\n}\n```\nBy declaring fields up-front, **class definitions become more self-documenting**, and the fields are always present.\n\nAs seen above, the fields can be declared with or without a default value.\n\n#### Private field declarations\nUsing private fields, the definition can be refined as below.\n\n```\nclass Rectangle {\n  #height = 0;\n  #width;\n  constructor(height, width) {    \n    this.#height = height;\n    this.#width = width;\n  }\n}\n```\nIt's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things which are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change version to version.\n\nPrivate fields can only be declared up-front in a field declaration.\n\nPrivate fields cannot be created later through assigning to them, the way that normal properties can.\n\n\n### Sub classing with extends\nThe ```extends``` keyword is used in class declarations or class expressions to create a class as a child of another class.\n\n```\nclass Animal { \n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name); // call the super class constructor and pass in the name parameter\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n```\nIf there is a constructor present in the subclass, it needs to first call super() before using \"this\".\n\nOne may also extend traditional function-based \"classes\":\n\n```\nfunction Animal (name) {\n  this.name = name;  \n}\n\nAnimal.prototype.speak = function () {\n  console.log(`${this.name} makes a noise.`);\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n\n//NB: For similar methods, the child's method takes precedence over parent's method\n```\n\n**Note that classes cannot extend regular (non-constructible) objects**. If you want to inherit from a regular object, you can instead use **Object.setPrototypeOf()**:\n\n```\nconst Animal = {\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n};\n\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// If you do not do this you will get a TypeError when you invoke speak\nObject.setPrototypeOf(Dog.prototype, Animal);\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie makes a noise.\n```\n","references":"- [MDN classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-classes","weblink":"https://codersnack.com/es6-classes/","featured_image_preview":{"id":98,"name":"ECMAScript-01.png","hash":"d3322ef305414d6c9c3e83734a95b650","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/d3322ef305414d6c9c3e83734a95b650.png","provider":"local","provider_metadata":null,"created_at":"2020-04-22T19:15:11.249Z","updated_at":"2020-04-22T19:15:11.249Z"}},"codersnacks_quiz":{"id":59,"question":"ES6 classes - Instance properties must be defined ...","response_valid":"inside of class methods","response_invalid1":"at the top of the class body","response_invalid2":"inside of constructor method","created_at":"2020-04-22T19:17:54.543Z","updated_at":"2020-04-22T19:17:54.543Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"Es6 classes - instance properties","created_at":"2020-04-22T19:18:29.721Z","updated_at":"2020-04-22T19:18:29.730Z"},{"id":71,"codersnack":{"id":125,"header":"ES modules: A cartoon deep-dive","created_at":"2021-12-09T14:37:17.748Z","updated_at":"2021-12-09T14:37:17.748Z","explanation":"**ES modules bring an official, standardized module system to JavaScript**. It took a while to get here, though — **nearly 10 years of standardization work**.\n\nBut **the wait is almost over**. With the release of Firefox 60 in May (currently in beta), all major browsers will support ES modules, and the Node modules working group is currently working on adding ES module support to Node.js. And ES module integration for WebAssembly is underway as well.\n\nMany JavaScript developers know that ES modules have been controversial. But few actually understand how ES modules work.\n\nLet’s take a look at what problem ES modules solve and how they are different from modules in other module systems.\n\n\n## What problem do modules solve?\n\nWhen you think about it, **coding in JavaScript is all about managing variables**. It’s all about assigning values to variables, or adding numbers to variables, or combining two variables together and putting them into another variable.\n\n![Code showing variables being manipulated](https://codersnack.com/assets/images/es-modules-deep-1.png)\n*Code showing variables being manipulated*\n\nBecause so much of your code is just about changing variables, **how you organize these variables is going to have a big impact on how well you can code… and how well you can maintain that code.**\n\n**Having just a few variables to think about at one time makes things easier. JavaScript has a way of helping you do this, called *scope***. Because of how scopes work in JavaScript, **functions can’t access variables that are defined in other functions**.\n\n![Two function scopes with one trying to reach into another but failing](https://codersnack.com/assets/images/es-modules-deep-functions.png)\n*Two function scopes with one trying to reach into another but failing*\n\nThis is good. It means that when you’re working on one function, you can just think about that one function. You don’t have to worry about what other functions might be doing to your variables.\n\nIt also has a downside, though. **It does make it hard to share variables between different functions.**\n\nWhat if you do want to share your variable outside of a scope? **A common way to handle this is to put it on a scope above you… for example, on the *global scope***.\n\n> You probably remember this from the **jQuery days**. Before you could load any jQuery plug-ins, you had to make sure that jQuery was in the global scope.\n\n![Two function scopes in a global, with one putting jQuery into the global](https://codersnack.com/assets/images/es-modules-deep-jquery.png)\n*Two function scopes in a global, with one putting jQuery into the global*\n\nThis works, but **they are some annoying problems that result**.\n\nFirst, all of **your script tags need to be in the right order**. Then you have to be careful to make sure that no one messes up that order.\n\nIf you do mess up that order, then in the middle of running, your app will throw an error. When the function goes looking for jQuery where it expects it — on the global — and doesn’t find it, it will throw an error and stop executing.\n\n![The top function scope has been removed and now the second function scope can’t find jQuery on the global](https://codersnack.com/assets/images/es-modules-deep-jquery-2.png)\n*The top function scope has been removed and now the second function scope can’t find jQuery on the global*\n\n**This makes maintaining code tricky**. It makes removing old code or script tags a game of roulette. **You don’t know what might break**. The dependencies between these different parts of your code are implicit. Any function can grab anything on the global, so you don’t know which functions depend on which scripts.\n\n**A second problem is that because these variables are on the global scope**, every part of the code that’s inside of that global scope can change the variable. **Malicious code can change that variable on purpose to make your code do something you didn’t mean for it to, or non-malicious code could just accidentally clobber your variable.**\n\n\n## How do modules help?\n\n**Modules give you a better way to organize these variables and functions. With modules, you group the variables and functions that make sense to go together.**\n\nThis puts these functions and variables into a **module scope**. The module scope can be used to share variables between the functions in the module.\n\nBut unlike function scopes, module scopes have a way of making their variables available to other modules as well. **They can say explicitly which of the variables, classes, or functions in the module should be available**.\n\n**When something is made available to other modules, it’s called an *export***. Once you have an export, other modules can explicitly say that they depend on that variable, class or function.\n\n![Two module scopes, with one reaching into the other to grab an export](https://codersnack.com/assets/images/es-modules-deep-export.png)\n*Two module scopes, with one reaching into the other to grab an export*\n\n**Because this is an explicit relationship, you can tell which modules will break if you remove another one.**\n\n**Once you have the ability to export and import variables between modules, it makes it a lot easier to break up your code into small chunks that can work independently of each other**. Then you can combine and recombine these chunks, kind of like **Lego blocks**, to create all different kinds of applications from the same set of modules.\n\nSince modules are so useful, **there have been multiple attempts to add module functionality to JavaScript**. Today there are two module systems that are actively being used:\n- **CommonJS (CJS)** is what **Node.js** has used historically.\n- **ESM (EcmaScript modules)** is a newer system which has been added to the JavaScript specification. Browsers already support ES modules, and Node is adding support.\n\n\nLet’s take an in-depth look at how this new module system works. (in part II)\n\n\n","references":"- [ES modules: A cartoon deep-dive - By Lin Clark](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)","featured_image_url":"https://codersnack.com/assets/images/es6.png","slug":"es6-modules-deep-dive","weblink":"https://codersnack.com/es6-modules-deep-dive","featured_image_preview":{"id":161,"name":"es6.png","hash":"77c7790356ab48d2b0da7390321941d2","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/77c7790356ab48d2b0da7390321941d2.png","provider":"local","provider_metadata":null,"created_at":"2021-12-09T14:37:17.769Z","updated_at":"2021-12-09T14:37:17.769Z"}},"codersnacks_quiz":{"id":71,"question":"What problems Javascript Modules does resolve?","response_valid":"Because in the import/exports there is an explicit relationship, you can tell which modules will break if you remove another one. And as you can combine and recombine these modules, kind of like Lego blocks, to create all different kinds of applications from the same set of modules.","response_invalid1":"It doesnt resolve nothing, it is just a way of better organizing your code","response_invalid2":" You can prepare your code for integration in module oriented frameworks such as Angular","created_at":"2021-12-09T14:44:51.596Z","updated_at":"2021-12-09T14:44:51.596Z"},"codersnacks_category":{"id":1,"header":"ES6","description":"Ecmascript 6","snacks_by_cat_json_filename":"es6.snacks.json","key":"es6","image_url":"http://codersnack.com/assets/images/es6.png","created_at":"2019-12-30T19:00:08.620Z","updated_at":"2020-01-04T11:09:02.347Z","image_preview":{"id":2,"name":"es6.png","hash":"fc475317b566444dbcb2605b9918cf87","sha256":"HwqWhJDjM92fduJqKeNaJhM1z41h36J-K2-8YaHK_Dg","ext":".png","mime":"image/png","size":2.08,"url":"/uploads/fc475317b566444dbcb2605b9918cf87.png","provider":"local","provider_metadata":null,"created_at":"2019-12-30T19:00:08.639Z","updated_at":"2019-12-30T19:00:08.639Z"}},"title":"ES modules - What problems resolve","created_at":"2021-12-09T14:45:26.423Z","updated_at":"2021-12-09T14:45:26.428Z"}]