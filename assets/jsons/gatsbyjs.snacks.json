[{"id":97,"codersnack":{"id":98,"header":"GatsbyJS - Introduction","created_at":"2021-11-03T17:19:05.447Z","updated_at":"2021-11-03T17:46:52.760Z","explanation":"\n## What is Gatsby?\n\nIt's **another static site generator** like Hugo, Jekyll and so on. So what makes it special? Why are we talking specifically about it?\n\nGatsby can be used to build static sites that are **Progressive Web Apps**, follow the latest web standards, and are **optimized to be highly performant.** It makes use of the latest and popular technologies including **ReactJS**, Webpack, **GraphQL**, modern ES6+ JavaScript and CSS.\n\n![ReactJS + GraphQL + Webpack = i'm loving it](https://codersnack.com/assets/images/gatsbyjs-reactjs-graphql-webpack.png)\n*ReactJS + GraphQL + Webpack = i'm loving it*\n\nThis means **a lot of developers can jump in without much of a learning curve** as they already know or have at least used one piece of this tech stack Gatsby is built on.\n\n## Approach to development\n\nOn one side, we have users expecting an app-like smooth experience on the web. The other side is **developers, used to sites having pages with each being HTML files** or maybe using some templating ‚Äî at the very base ‚Äî sites as pages with internal linking.\n\nIf you‚Äôre getting started with any of the latest frameworks, let‚Äôs take the case of React. You could have an app up and running with minimal configuration with *create-react-app*. But if you take a look at the project structure it may not make much sense to a newbie or even some developers coming in from other tech stacks. *The pattern is pretty different from what you‚Äôve ever seen before.* It‚Äôs because without additional setup they aim at building Single-Page Applications, SPAs. To add routing, pages or optimizing for SEO, it will require more tools and configuration.\n\nThat doesn‚Äôt seem very convenient when you want static sites, does it? So here we have **Gatsby, optimized for this specific use case**. This could be **more intuitive for developers**, as there are pages created from components that follow the root idea that sites are pages with internal linking.\n\n## Webpack bundling and latest tooling\n\nWebpack creates optimized, minified bundles of HTML, JavaScript, and CSS. When it‚Äôs pre-configured with Babel and more plugins, it allows you to use the latest ES6+ JavaScript and GraphQL.\n\n*Icing on the cake*: we‚Äôve got hot reloading and code splitting built-in, giving a better development experience and better site performance. This is aimed at making the developer write minimal tooling configuration and focus more on the actual site development.\n\n## Gatsby plugins, starters and React packages\n\nYou can use any of the packages you‚Äôve already been using with NPM, particularly the React ones as it‚Äôs built on the same thing. But that‚Äôs not all: there‚Äôs a **large number of ever-growing plugins, starters, and transformers by the Gatsby community**. You almost never come to the point where you actually have to build on your own tool or module, the community already offers a huge number to suit every need.\n\nUsing these, Gatsby **can be extended with additional functionality**. For instance, a couple of examples include *responsive images*, *offline functionality*, *source data from CMS* and *data markup formats*, adding third-party services (Google analytics etc), and so on.\n\n## Responsive Images\n\nResizing images for responsiveness on different devices, lazy-loading, using srcsets and picture‚Ä¶Already sounds tedious when it is to be done manually.\n\n![Different versions of the same image for responsiveness](https://codersnack.com/assets/images/gatsbyjs-responsive-images.png)\n*Different versions of the same image for responsiveness*\n\nAlthough it is a requirement for performance and app-like optimized interfaces these days, we don‚Äôt see many tools that we can directly jump into and use.\n\nMeanwhile, in Gatsby with just a plugin, particularly the **gatsby-plugin-sharp**, you can directly generate **fluid images, add filters, change formats**, blur up on load and a lot more. This saves a lot of work and time manually resizing images and writing explicit boilerplate code for responsive images. It also gives you way better performance along with a smoother user experience.\n\n## App-like experience\n\nWith the performance boost and features to add to the **smoothness of the user experience**, Gatsby aims at a full app-like experience borrowing from full PWAs. There are **no reloads between pages** when using **gatsby-link** instead of hyperlinks, and the app still appears smooth and performant thanks to **lazy-loading images and code-splitting**.\n\nFor sites following standards that you also want to be performant, we‚Äôve got tons of things to do and guides to follow: minification and bundling, browser caching and async loading scripts or files, and so on. When working with a framework like React, you have more things to worry about even though it solves a couple of problems: **code-splitting, SEO, routing if required, responsive images**, and the list goes on.\n\n**Gatsby aims to solve all these problems**, with less time spent on tooling, configuration, and the environment and more time to actually design and develop the site.\n\n## Plugins\n\nGatsby was **built to be extensible and flexible ‚Äî using plugins is one way to make it so**. They can be directly installed and be used for a variety of functionality including making the site offline, adding Google analytics, adding support for inline SVGs, you name it ‚Äî the list is almost endless.\n\nOf the different types of Gatsby plugins, the **gatsby-source plugins in particular fetch data from a local or remote source and allow it to be usable via GraphQL**. These sources could be CMSs such as *Wordpress*, Drupal, Plone, *local markdown*, XML or such files, databases, APIs and *data formats as JSON*, CSV.\n\nThis implies that almost anything at all can be used as a source to work with Gatsby and generate static sites.\n\n***Note***: GraphQL is a query language for APIs that works on the philosophy of just asking for exactly what you require. Unlike REST APIs, you don‚Äôt look for endpoints to provide your data and process them from the structure that‚Äôs given from it, but rather ask for what you want and directly use this data. Read more about how it works and how to use it in their docs.\nAfter installation, some plugins can be used straight away by just listing them in *gatsby-config.js* and the others configured with an options object.\n\nGo check out the Gatsby plugin library, it‚Äôs already got quite a large number of plugins and more are being added still by the active community.\n\n## Starters\n\nThese are basically boilerplate Gatsby sites which help you kick-start development quickly depending on what kind of site it is. They help you directly get onto working on the development of a site, configuration and basic features you need already taken care of. Which means, less time on the tooling, more time for development.\n\nGatsby plugins often have their corresponding starters which show or serve a quick way to get started with using it. They also act as a reference covering all the features and showcase configurations of the plugin in use.\n\n[https://www.gatsbyjs.com/starters/](https://www.gatsbyjs.com/starters/)\n\n## Static Sites\n\nFirstly, let‚Äôs take a look at **how Gatsby works internally**. Unlike the SPAs that make API requests as you run the app, **Gatsby does all the data fetching, including data sourcing from local files, during build time**. All this data is then used to generate static HTML, JavaScript, and CSS files. This static rendering is what makes things work faster.\n\n![How GastbyJS works](https://codersnack.com/assets/images/gatsbyjs-how-it-works.png)\n*How GastbyJS works*\n\nThat was a lot about Gatsby, its ecosystem and how it helps you create amazing static sites. **But why would we want static sites? Doesn‚Äôt it sound like a step back from dynamic ones?**\n\n- They **do not require complex server setup with databases, maintenance, and don‚Äôt have any scaling issues**.\n- Data is **fully secure**. CMSs and APIs have private features but the data is still present in the server which can be exploited. Gatsby only takes the required data to display from the source and the private or secured data is not even present in the final build. Which is the safest it can possibly get.\n- Rather than relying on servers to generate pages dynamically, **pre-render all of them on build and use CDNs for a blazing fast** and smooth experience for users all around the globe.\n- Gatsby does static rendering. Which makes content available as HTML, and **search engine optimized, no long initial load time**.\n","references":"- [Why you should use GatsbyJS to build static sites](https://www.freecodecamp.org/news/why-you-should-use-gatsbyjs-to-build-static-sites-4f90eb6d1a7b/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-introduction","weblink":"https://codersnack.com/gatsbyjs-introduction","featured_image_preview":{"id":134,"name":"gatsbyjs-logo.png","hash":"88d8647b64d746bfa0e26e30739956a5","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/88d8647b64d746bfa0e26e30739956a5.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T17:19:05.459Z","updated_at":"2021-11-03T17:19:05.459Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"Gatsbyjs - Introduction","created_at":"2021-11-03T17:19:52.479Z","updated_at":"2021-11-03T17:19:52.483Z"},{"id":98,"codersnack":{"id":99,"header":"GatsbyJS - Use and Style React Components","created_at":"2021-11-03T20:02:39.083Z","updated_at":"2021-11-03T20:02:39.083Z","explanation":"To build out the basic page structure for your blog site, you‚Äôll need to know about React components and how Gatsby uses them.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Create page components to add new pages to your site.\n- Import and use a pre-built component from another package.\n- Create your own reusable ‚Äúbuilding block‚Äù component.\n- Use component props to change the way a component renders.\n- Use the children prop to create a wrapper component.\n \n## What is React?\n\n**React is the JavaScript library that Gatsby uses under the hood to create user interfaces (UIs)**. With React, you can **break down your UI into smaller, reusable pieces called components**.\n\nFor example, imagine the UI for an online store‚Äôs Products page:\n\n![gatsbyjs-ui-built-from-componentst](https://codersnack.com/assets/images/gatsbyjs-ui-built-from-components.png)\n\nTo build this page in React, you might have a ```<Navbar>``` component for the navigation menu, a ```<Sidebar>``` component for extra information displayed to the side of the main content, and a ```<ProductGrid>``` component to display all of the products for sale.\n\nYou can also create components from other components. For example, you might decide to break down the ```<ProductGrid>``` component into a list of multiple ```<ProductCard>``` components, which each display the details about a single product. This pattern is called composition, since your larger ```<ProductGrid>``` component is composed of smaller ```<ProductCard>``` components.\n\n##¬†What is a React component?\n\nUnder the hood, **a React component is a function that returns a React element**. A **React element is an object that React uses to render DOM elements**.\n\n**A component is a function that outputs a React component, written in JSX**.\n\nThe simplest way to write React elements is with JSX. JSX is a JavaScript syntax extension that describes the DOM structure for your component. It looks a bit like having HTML in your JavaScript files:\n\n```\nconst hello = <h1>Hello world!</h1>\n```\n\nSo a simple React component might look something like this:\n\n```\nconst Greeting = () => {\n  return (\n    <h1>Hello world!</h1>\n  )\n}\n```\n\n\n### Create a page component\n\nThere are two main types of components in a Gatsby site. The first type you‚Äôll create are page components. **A page component contains all the UI elements for a specific page of your site.**\n\nIn this section, you‚Äôll create two new page components: one for the Home page and one for an About page.\n\nThe Home Page content is in ```src/index.js```.\n\n### Task: Create a new page component for an About page\n\nNow that you‚Äôve updated the existing Home page, try creating a new page from scratch. Make an About page, so that you can tell people a little about yourself.\n\nCreate a new file: src/pages/about.js. Use the code below as a starting point for your About page. \n\n*src/pages/about.js*\n```\n// Step 1: Import React\nimport * as React from 'react'\n// Step 2: Define your component\nconst AboutPage = () => {\n  return (\n    <main>\n      <title>About Me</title>\n      <h1>About Me</h1>\n      <p>Hi there! I'm the proud creator of this site, which I built with Gatsby.</p>\n    </main>\n  )\n}\n// Step 3: Export your component\nexport default AboutPage\n```\n\n## Use the ```<Link>``` component\n\nSo far, your blog site has two separate pages (Home and About), but the only way to get from one page to the other is to update the URL manually. It would be nice to add links to make it easier to switch between pages on your site.\n\nThe **Link** component is an example of a **pre-built component** that you can use in your site. In other words, the Link component is defined and maintained by another package (in this case, the Gatsby package). That means you can import it and use it in your own components without knowing too much about how it works under the hood.\n\n**The Link component lets you add a link to another page in your Gatsby site**. It‚Äôs similar to an HTML ```<a>``` tag, but with some extra **performance benefits**. The Link component takes a **prop called to**, which is similar to the ```<a>``` tag's href attribute. The value should be the URL path to the page on your site you want to link to.\n\n*-- Key Gatsby Concept --* üí°\n\nThe Gatsby Link component provides a **performance feature called preloading**. **This means that the resources for the linked page are requested when the link scrolls into view or when the mouse hovers on it. That way, when the user actually clicks on the link, the new page can load super quickly**.\n\nUse the Link component for linking between pages within your site. For external links to pages not created by your Gatsby site, use the regular HTML ```<a>``` tag.\n\n*--*\n\nFollow the steps below to add Link components to your Home and About pages.\n\nOn the Home page, import the Link component from the Gatsby package and add a link to your About page.\n\n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nconst IndexPage = () => {\n  return (\n    <main>\n      <title>Home Page</title>\n      <h1>Welcome to my Gatsby site!</h1>\n      <Link to=\"/about\">About</Link>\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n    </main>\n  )\n}\nexport default IndexPage\n```\n\nOn the About page, import the Link component from the Gatsby package and add a link to your Home page.\n\n*src/pages/about.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nconst AboutPage = () => {\n  return (\n    <main>\n      <title>About Me</title>\n      <h1>About Me</h1>\n      <Link to=\"/\">Back to Home</Link>\n      <p>Hi there! I'm the proud creator of this site, which I built with Gatsby.</p>\n    </main>\n  )\n}\nexport default AboutPage\n```\n\n## Create a reusable layout component\n\nIf you take another look at the finished example blog, you might notice that there are some repeated parts of the UI across each page, like the site title and the navigation menu.\n\nYou could copy those elements into each page of your site separately. But imagine your site had dozens (or even thousands) of pages. If you wanted to make a change to the structure of your navigation menu, you‚Äôd have to go and update every one of those files separately. Yuck.\n\nInstead, it would be better to create one common **Layout component** that groups all the shared elements to **reuse across multiple pages**. That way, when you need to make updates to the layout, you can make the change in one place and it will automatically be applied to all the pages using that component.\n\nIn this section, you‚Äôll create your first custom building-block component: Layout. To do that, you‚Äôll need to use a special React prop called children.\n\nFollow the steps below to create a Layout component and add it to your Home and About pages.\n\nCreate a new file called **src/components/layout.js**. Insert the following code to define your Layout component. This component will render a dynamic page title and heading (from the **pageTitle prop**), a list of navigation links, and the contents passed in with the children prop. To improve accessibility, there's also a ```<main>``` element wrapping the page-specific elements (the ```<h1>``` heading and the contents from children).\n\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    <div>\n      <title>{pageTitle}</title>\n      <nav>\n        <ul>\n          <li><Link to=\"/\">Home</Link></li>\n          <li><Link to=\"/about\">About</Link></li>\n        </ul>\n      </nav>\n      <main>\n        <h1>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\n*Syntax Hint*: You might have noticed that the Layout component uses a slightly different syntax for its props.\n\nNow instead of looking like this:\n\n```\nconst Layout = (props) => {\n  ...\n}\n```\n‚Ä¶it looks like this:\n\n```\nconst Layout = ({ pageTitle, children }) => {\n  ...\n}\n```\n\nThis is a JavaScript technique called **destructuring**.\n\n\nUpdate your Home page component to use the Layout component instead of the hard-coded Link component you added in the previous section.\n\n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst IndexPage = () => {\n  return (\n    <Layout pageTitle=\"Home Page\">\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n    </Layout>\n  )\n}\nexport default IndexPage\n```\nUpdate your About page component to use the Layout component as well.\n*src/pages/about.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst AboutPage = () => {\n  return (\n    <Layout pageTitle=\"About Me\">\n      <p>Hi there! I'm the proud creator of this site, which I built with Gatsby.</p>\n    </Layout>\n  )\n}\nexport default AboutPage\n```\n\n## Style components with CSS Modules\n\nNow that you‚Äôve got your page structure set up, it‚Äôs time to add some style and make it cute!\n\n**Gatsby isn‚Äôt strict about what styling approach you use.** You can pick whatever system you‚Äôre most comfortable with.\n\nIn this Tutorial, you‚Äôll use **CSS Modules to style your components**. This means that **styles will be scoped to components, which helps avoid class naming collisions between components**. **Gatsby is automatically configured to handle CSS Modules** - no extra setup necessary!\n\nFollow the steps below to style your Layout component using CSS Modules.\n\nCreate a new file: *src/components/layout.module.css*. (**The .module.css part at the end is important!** That‚Äôs what tells Gatsby that these styles are using CSS Modules.)\n\nStart by adding a single **.container class**:\n\n*src/components/layout.module.css*\n```\n.container {\n  margin: auto;\n  max-width: 500px;\n  font-family: sans-serif;\n}\n```\n\nThen **import that class into your Layout component .js file**, and use the **className prop** to assign it to the top-level ```<div>``` element:\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nimport { container } from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    <div className={container}>\n      <title>{pageTitle}</title>\n      <nav>\n        <ul>\n          <li><Link to=\"/\">Home</Link></li>\n          <li><Link to=\"/about\">About</Link></li>\n        </ul>\n      </nav>\n      <main>\n        <h1>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n\n```\nSyntax Hint: To apply classes to React components, use the className prop. (This is another example of a built-in prop that React automatically knows how to handle.)\n\nThis might be confusing if you‚Äôre used to using the class attribute on HTML elements. Do your best to not mix them up!\n\nNow that you‚Äôve seen how to style a single element for your component, add some more styles to apply to the other elements in your Layout component.\n*src/components/layout.module.css*\n```\n.container {\n  margin: auto;\n  max-width: 500px;\n  font-family: sans-serif;\n}\n.heading {\n  color: rebeccapurple;\n}\n.nav-links {\n  display: flex;\n  list-style: none;\n  padding-left: 0;\n}\n.nav-link-item {\n  padding-right: 2rem;\n}\n.nav-link-text {\n  color: black;\n}\n```\n\nImport the new classes into your Layout component, and apply each class to the corresponding element.\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    <div className={container}>\n      <title>{pageTitle}</title>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\n*Syntax Hint*: In CSS, the convention is to name classes using kebab case (like .nav-links). But in JavaScript, the convention is to name variables using camel case (like navLinks).\n\nLuckily, when you use CSS Modules with Gatsby, you can have both! **Your kebab-case class names in your .module.css files will automatically be converted to camel-case variables that you can import in your .js files.**\n\n## Key takeaways\n\n- React is a library that helps you break down your UI into smaller pieces called components. A component is a function that returns a React element. React elements can be written in JSX.\n- **Page components** contain all the UI elements for a specific page of your site. Gatsby automatically creates pages for components that are the default exports of files in the src/pages directory. The name of the file will be used as the route for the page.\n- **Building-block components** are smaller reusable parts of your UI. They can be imported into page components or other building block components.\n- You **can import pre-built components (like Link) **from other packages, or you can write your own custom components from scratch (like Layout).\n- You can use **props to change how a component renders**. You can define your own props when you build a component. **React also has some built-in props, like *children* and *className***.\n- Gatsby isn‚Äôt opinionated about what styling approach you want to use, but it works with CSS Modules by default.\n\n","references":"- [Use and Style React Components](https://www.gatsbyjs.com/docs/tutorial/part-2/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-use-react-components","weblink":"https://codersnack.com/gatsbyjs-use-react-components","featured_image_preview":{"id":135,"name":"gatsbyjs-logo.png","hash":"ea8f1f34862a4e29a0e2a777accbaa3e","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/ea8f1f34862a4e29a0e2a777accbaa3e.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T20:02:39.096Z","updated_at":"2021-11-03T20:02:39.096Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - use react components","created_at":"2021-11-03T20:03:14.305Z","updated_at":"2021-11-03T20:03:14.310Z"},{"id":99,"codersnack":{"id":100,"header":"GatsbyJS - Add Features with Plugins","created_at":"2021-11-03T20:33:43.718Z","updated_at":"2021-11-03T20:40:12.105Z","explanation":"It can be a lot of work to build new features for a website. Luckily, **by using Gatsby plugins, you can quickly add new functionality to your site without needing to build it from scratch yourself**. Gatsby‚Äôs plugin ecosystem has thousands of prebuilt packages for you to choose from.\n\nIn this part of the Tutorial, you‚Äôll learn what Gatsby plugins are and how to use them in your site.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Use the Gatsby Plugin Library to browse all the available plugins.\n- Add a plugin to your Gatsby site.\n- Configure your plugins in your gatsby-config.js file.\n\n \n## What is a plugin?\n\nIn Gatsby terms, **a plugin is a separate npm package that you install to add extra features to your site.**\n\nThere are a variety of plugins that each have different use cases. Some plugins provide pre-built components, others add analytics, others let you pull data into your site. **Some plugins are built by Gatsby employees, while other plugins are built and maintained by community members**. So far, there are more than 2,600 plugins to choose from. You can look through all the available plugins using the [Gatsby Plugin Library](https://www.gatsbyjs.com/plugins).\n\nYou can think of a plugin as an accessory for your site. **You don‚Äôt need to use plugins - you could build out the same functionality from scratch yourself - but they save you time**. They‚Äôre like those fancy single-purpose cooking gadgets that peel apples or crush garlic. You could accomplish the same task using a regular knife, but it‚Äôs often faster to use a tool that‚Äôs built to do that one specific job really well.\n\n**You will likely use plugins in almost every Gatsby site you build**. While working through the rest of the Tutorial, you‚Äôll have many opportunities to practice installing and using plugins.\n\n## Add a plugin to your site\n\nTo add a plugin to your site, you‚Äôll use the following process:\n\n- Install the plugin using npm.\n- Configure the plugin in your site‚Äôs **gatsby-config.js** file.\n- Use the plugin features in your site, as needed.\n\n![gatsbyj-plugin-process](https://codersnack.com/assets/images/gatsbyj-plugin-process.png)\n\nThe next few sections will walk you through the process of adding a plugin to your site. You‚Äôll use the **gatsby-plugin-image** plugin to **add performant images to your site**.\n\n### Task: Use gatsby-plugin-image to add a static image to your home page\n\nYou can use the gatsby-plugin-image plugin to **add responsive images to your site** while maintaining high performance scores. **gatsby-plugin-image exports a component called *StaticImage***, which you can **use to load images from a remote URL or your local filesystem**.\n\nFollow the steps below to use the *StaticImage* component to add an image from a URL to your home page.\n\nIn the terminal, run the following command to install gatsby-plugin-image and its dependencies.\n```\nnpm install gatsby-plugin-image gatsby-plugin-sharp gatsby-source-filesystem\n```\n\nThe *StaticImage* component requires a few additional plugins to work. These extra plugins are called peer dependencies, and you‚Äôll need to install them along with the gatsby-plugin-image package:\n\n- **gatsby-plugin-sharp**: **Handles the actual image processing** that is used by gatsby-plugin-image.\n- **gatsby-source-filesystem**: Lets you **pull in data from your computer‚Äôs filesystem**. (You‚Äôll learn more about this plugin later. Just install it for now.)\n*Tip*: When adding a new plugin to your site, check the plugin README in the Gatsby Plugin Library to see if there are any special setup instructions.\n\nNext, add the gatsby-plugin-image and gatsby-plugin-sharp plugins to your gatsby-config.js file. (Don‚Äôt worry about gatsby-source-filesystem just yet. You‚Äôll come back to it later.)\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    \"gatsby-plugin-image\",\n    \"gatsby-plugin-sharp\",\n  ],\n};\n```\n\n*-- Key Gatsby Concept üí° --*\n\nThe **gatsby-config.js** file is a special file that **Gatsby recognizes automatically**. It‚Äôs **where you add plugins and other site configuration**.\n\n**After you update your gatsby-config.js file, your local development server has to restart in order to pick up the new changes**. Sometimes it will restart itself automatically, but if you‚Äôre seeing unexpected behavior, try stopping and restarting it yourself.\n*--.--*\n\nNow that your plugins have been installed and configured, you can use the *StaticImage* component in your Gatsby site! You can use the StaticImage component similarly to the way you‚Äôd use an HTML ```<img>`` tag.\n\nThe StaticImage component expects the following props:\n\n- **src** (string): The URL to the image you want to load. (This is the same as what you put in the src attribute of an <img> HTML element.)\n- **alt** (string): The alt text to describe the image. This gets used by screen readers or if there‚Äôs a problem loading the image.\n\nFind an image URL online, and then use the StaticImage component to add that image to your home page:\n\n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nimport { StaticImage } from 'gatsby-plugin-image'\nconst IndexPage = () => {\n  return (\n    <Layout pageTitle=\"Home Page\">\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n      <StaticImage\n        alt=\"Clifford, a reddish-brown pitbull, posing on a couch and looking stoically at the camera\"\n        src=\"https://pbs.twimg.com/media/E1oMV3QVgAIr1NT?format=jpg&name=large\"\n      />\n    </Layout>\n  )\n}\nexport default IndexPage\n```\n\n\n### Task: Update the static image to use a photo from your local filesystem\n\nSo far, you‚Äôve used the StaticImage component to add an image from an external URL. But what happens if you want to use a photo that isn‚Äôt on the internet yet?\n\nYou can also use the **StaticImage component to render images from your local filesystem**.\n\nDownload a photo to your computer, and move it into your project folder. To keep things organized, put it in the **src/images directory**.\nUpdate the src prop in your home page to be a relative path to your file instead of a URL. \n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nimport { StaticImage } from 'gatsby-plugin-image'\nconst IndexPage = () => {\n  return (\n    <Layout pageTitle=\"Home Page\">\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n      <StaticImage\n        alt=\"Clifford, a reddish-brown pitbull, dozing in a bean bag chair\"\n        src=\"../images/clifford.jpg\"\n      />\n    </Layout>\n  )\n}\nexport default IndexPage\n```\n\n## Key takeaways\n\n- A plugin is a package that lets you add new features to your site.\n- Using plugins saves you development time, since it‚Äôs faster to install and configure a plugin than it is to recreate the same functionality from scratch.\n- The general process for using a plugin is to install it, configure it in your gatsby-config.js file, and then use it in your site as needed.\n- You can use the Gatsby Plugin Library to browse all the available plugins and learn more about how each one works.\n","references":"- [Add Features with Plugins](https://www.gatsbyjs.com/docs/tutorial/part-3/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-add-features-plugin","weblink":"https://codersnack.com/gatsbyjs-add-features-plugin","featured_image_preview":{"id":136,"name":"gatsbyjs-logo.png","hash":"d5c7695a7e414e2092c1fa04adade080","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/d5c7695a7e414e2092c1fa04adade080.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T20:33:43.733Z","updated_at":"2021-11-03T20:33:43.733Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - add new features with plugins","created_at":"2021-11-03T20:34:14.631Z","updated_at":"2021-11-03T20:34:14.639Z"},{"id":100,"codersnack":{"id":101,"header":"GatsbyJS - Query for Data with GraphQL","created_at":"2021-11-03T22:21:47.461Z","updated_at":"2021-11-03T22:29:18.918Z","explanation":"So far, you‚Äôve been writing text and adding images directly in your React components. That‚Äôs an excellent way to build many websites! **But often it‚Äôs easier to create and maintain data somewhere else - like a folder of Markdown files or a content management system (CMS) - and then pull it into your components as needed**. That way, you can make updates to your content without affecting the code for your site.\n\nConveniently, **Gatsby has a powerful feature called the data layer** that you can use to pull data into your site from anywhere. Want to keep your blog posts in WordPress, your store products in Shopify, and your user data in Airtable? No problem! With **Gatsby‚Äôs data layer, you can combine data from multiple sources**, which lets you choose the best platform for each type of data.\n\n**Gatsby‚Äôs data layer is powered by a technology called *GraphQL***. **GraphQL is a query language with a special syntax that lets you ask for the data you need inside a component**.\n\nIn this Tutorial, we‚Äôll teach you all the GraphQL you‚Äôll need to know to build your first Gatsby site. Interested in learning more? How To GraphQL is a free tutorial that teaches you the fundamentals.\n\nIn this part of the Tutorial, you‚Äôll learn about how to add data to Gatsby‚Äôs data layer and how to pull that data into your React components.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Use GraphiQL to explore the data in the data layer and build your own **GraphQL queries**.\n- Use the **useStaticQuery** hook to pull data into a ‚Äúbuilding-block‚Äù component.\n- Use the gatsby-source-filesystem plugin to pull data into your site from your computer‚Äôs filesystem.\n- Create a **page query** to pull data into a page component.\n\n## Meet Gatsby‚Äôs GraphQL data layer\n\n**Gatsby has its own GraphQL data layer where it keeps all the data for your site**. But how does it work under the hood?\n\nFirst, **your data is stored in one or more source**s. That source might be a folder on your computer‚Äôs filesystem, a content management system (CMS) like WordPress, or a database. You might even have multiple data sources!\n\nHow do you get data from its source into the data layer? By adding a type of plugin to your site called a source plugin. **Each source plugin is designed to communicate with a specific source**. **When you build your site, each source plugin pulls data from its particular source and adds it to your site‚Äôs GraphQL data layer**.\n\n*Tip*: Curious what source plugins are in the Plugin Library? You can identify source plugins by their name: they typically start with gatsby-source-.For example, a few popular source plugins are gatsby-source-filesystem and gatsby-source-contentful.\n\nHow do you get data back out of the data layer? **You can write GraphQL queries inside of your components to pull out the data you want to use in your site**. When you build your site, Gatsby will find all the GraphQL queries in your components, run them, and put the resulting data in your component.\n\n![gatsbyjs-data-layert](https://codersnack.com/assets/images/gatsbyjs-data-layer.png)\n\n## Use GraphiQL to explore the data layer and write GraphQL queries\n\nHow do you know what data is in your site‚Äôs GraphQL data layer? **When you start the local development server for your site, Gatsby automatically creates a special endpoint that lets you use an in-browser tool called GraphiQL**. With GraphiQL, you can explore your site‚Äôs data and build GraphQL queries.\n\nFollow the steps below to open the GraphiQL interface:\n\nStart up your local development server by running gatsby develop.\nIn a web browser, go to *http://localhost:8000/___graphql*. (That‚Äôs three underscores in the URL.)\n\n![gatsbyjs-graphiql](https://codersnack.com/assets/images/gatsbyjs-graphiql.png)\n\n###¬†A closer look at the GraphiQL interface\n\nThere are three main sections of the GraphiQL interface:\n\n- **Explorer**: This is the section on the left, which shows you **all the different kinds of data you can request in a GraphQL query**.You can toggle the dropdowns to expand the different fields and see what kinds of data are available in the data layer. The blue items correspond to the different data fields you can query for. The purple items accept additional arguments that you can use to filter down the data returned in the response.\n- **Query Editor**: This is the middle section, which you can use to **write out a query to test**. You can add fields to your query by checking the boxes for different fields in the Explorer pane. Or, if you‚Äôd prefer, you can type the fields directly into the Query Editor. (Pro Tip: You can press **Ctrl + Space on your keyboard to bring up an autocompletion** box that shows what fields are available to you.). To execute the query in the Query Editor, click the ‚ÄúExecute Query‚Äù button (it looks like a ‚Äúplay‚Äù triangle button) at the top of the page.\n- **Result Window**: This is the section on the right, which shows you **the result of running the query in the Query Editor**.\n\n**GraphiQL** is a **helpful tool for testing out your GraphQL queries** before you add them to your code. That way, you can make sure your queries always respond with the data you expect.\n\nTry creating and running a few queries by doing the following:\n\n- Check a few of the blue fields in the Explorer pane. Note how checking the box for a field adds it to the query in the Query Editor.\n\n- Click the button at the top of the page (that looks like a ‚Äúplay‚Äù button) to execute the query. Look at the data returned in the Result window.\n\nIn the next section, you‚Äôll learn more about how to use specific fields. For now, take a minute or two to explore the different fields. What kinds of data are already available to you in the data layer?\n\n### Queries in building-block components: Pull the site title into the Layout component\n\nNow that you‚Äôve seen the general process for how data works in your Gatsby site, it‚Äôs time to try it out yourself.\n\n**The process for using GraphQL queries in your components looks slightly different depending on whether it‚Äôs a page component or a building-block component**.\n\nIn this first section, **you‚Äôll start by pulling data into a building-block component**. To do that, you‚Äôll **update your Layout component to pull in the title of your site**.\n\n#### Task: Use GraphiQL to build the query\n\nLook in your **gatsby-config.js** file. There‚Äôs already some information there about your site, in the **siteMetadata** object.\n\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    // ...\n  ],\n};\n```\n\n**This data was added to your gatsby-config.js file automatically when you used the gatsby** new command in Part 1. It also gets pulled into the GraphQL data layer automatically, so **you don‚Äôt need a source plugin for this first section**.\n\nSince you don‚Äôt need to set up a source plugin, you can jump straight into GraphiQL to build your GraphQL query:\n\nIn your web browser, go to localhost:8000/___graphiql to see the GraphiQL interface.\nIn the Explorer pane, open the dropdown for the site field.\nWithin the site field, open the second dropdown for the siteMetadata field (the blue one). This corresponds to the siteMetadata object in your gatsby-config.js file.\n\n*-- Seeing Double? --*\n\nYou might have noticed that there are two different dropdowns for siteMetadata (and for every field under the site dropdown).\n\nThe first one (the purple one with a colon, siteMetadata:) is actually an argument attached to the site field. **You can use the purple dropdowns to filter which pieces of data from the data layer get returned in the response**. (You‚Äôll see an example of this later on.)\n\nThe second one (**the blue one** without a colon, siteMetadata) is what you‚Äôll use more frequently. **This one adds the actual siteMetadata field to your query**, which tells GraphQL to include that field in your response data.\n\nTry toggling each of the dropdowns in the Explorer and see how the query in the Query Editor pane changes. What differences do you notice?\n*--.--*\n\nWithin **siteMetadata**, check the box next to the title field. The query in your query editor should look like this:\n```\nquery MyQuery {\n  site {\n    siteMetadata {\n      title\n    }\n  }\n}\n```\n\nClick the Execute Query button (the ‚Äúplay‚Äù triangle at the top of the page) to run the query. The response in the Result Window should look something like the object below. Notice **how the structure of the data object in the response matches the structure of the fields in the query.**\n```\n{\n  \"data\": {\n    \"site\": {\n      \"siteMetadata\": {\n        \"title\": \"My First Gatsby Site\"\n      }\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nTry changing the value of the title property in your **gatsby-config.js file**. When you save the file, your site should rebuild, and when it‚Äôs finished you can re-run the query in GraphiQL and see your updated data.\n\n### Task: Use useStaticQuery to pull the site title into the Layout component\n\nNow that you have a GraphQL query that returns the data you‚Äôre looking for, how do you use that query in your React components?\n\n**To pull data into a building-block component, you‚Äôll use a pre-defined function from Gatsby called *useStaticQuery*.**\n\n**-- Key Gatsby Concept --**  :  **Pulling data into building-block components with *useStaticQuery***\nThe Gatsby package has a special pre-defined hook that lets you add GraphQL queries to your building-block components: **useStaticQuery**.\n\n**useStaticQuery takes one parameter: a templated string of the GraphQL query you want to run**. It returns the requested data, which you can store in a variable and then use throughout your component.\n\nHere‚Äôs a brief outline of the process for adding useStaticQuery to pull data into your building-block components:\n\n - **Import the useStaticQuery hook and the *graphql* tag from the gatsby package**. The **graphql tag is something called a tagged template literal**. Basically, the graphql tag tells Gatsby that the string following it is a GraphQL query, so then Gatsby can parse and run it.\n```\nimport { useStaticQuery, graphql } from 'gatsby'\n```\n\nInside your component, call useStaticQuery using the graphql template tag and your query from GraphiQL. Store the results in a new variable so that you can use it later in your component.\n```\nconst data = useStaticQuery(graphql`\n  // Copy-paste your query from GraphiQL here, and delete the query name \"MyQuery\"\n`)\n```\n\n**Use the data in your component** by using the dot operator (.) to access the appropriate field off the response.\nHere‚Äôs a small example to show what this process looks like in practice:\n\n*src/components/header.js*\n```\nimport * as React from 'react'\n// Step 1: Import the useStaticQuery hook and graphql tag\nimport { useStaticQuery, graphql } from 'gatsby'\nconst Header = () => {\n  /* Step 2: Use the useStaticQuery hook and\n    graphql tag to query for data\n    (The query gets run at build time) */\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <header>\n      {/* Step 3: Use the data in your component */}\n      <h1>{ data.site.siteMetadata.title }</h1>\n    </header>\n  )\n}\nexport default Header\n```\n\n*Note*: **You can only call useStaticQuery once per file**. If you need multiple fields, you can add them all into a single query.For example, if you need data from both the site field and the siteBuildMetadata field, you could make the following call to useStaticQuery:\n\n```\nconst data = useStaticQuery(graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    siteBuildMetadata {\n      buildTime\n    }\n  }\n`)\n```\n\n* --.-- *\n\nFollow the steps below to use useStaticQuery to pull in the site title from your site metadata into your Layout component.\n\nImport the useStaticQuery function and the graphql tag from the Gatsby package.\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    // ...\n  )\n}\nexport default Layout\n```\nCall useStaticQuery and pass it the query you created in GraphiQL. Be sure to use the graphql tag so Gatsby knows that the string you‚Äôre passing in is a GraphQL query. Store the return value from useStaticQuery in a variable.\n\n*Note*: By default, the query you build in GraphiQL will have a query name, like MyQuery. You may see an error if you have more than one query with the same name, so after you copy your query over from GraphiQL to your component, delete the name (as in the code example below).\n\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    // ...\n  )\n}\nexport default Layout\n```\n\n*Note*: If you add a line to print out the value of your data variable to the console, you‚Äôll see that the response has a slightly different structure from what it looked like in GraphiQL‚Äôs Result Window. Specifically, your data variable will only contain the object that matches the data field in the Result Window.\n\nSo if your GraphiQL Result Window showed this:\n\n```\n{\n  \"data\": {\n    \"site\": {\n      \"siteMetadata\": {\n        \"title\": \"My First Gatsby Site\"\n      }\n    }\n  },\n  \"extensions\": {}\n}\n``` \n\nthen your data variable will have the following structure:\n\n```\n{\n  \"site\": {\n    \"siteMetadata\": {\n      \"title\": \"My First Gatsby Site\"\n    }\n  }\n}\n```\n\nNow that you have a variable with the results of your query, you can render the title of your site in the JSX for your Layout component. To access the site title, use the JavaScript dot operator (.) to get the value of data.site.siteMetadata.title. Add it so it appears in both the browser tab and at the top of your page content.\n\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <div className={container}>\n      <title>{pageTitle} | {data.site.siteMetadata.title}</title>\n      <header>{data.site.siteMetadata.title}</header>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\nNow that the site title is showing up on the page, it‚Äôs time to add some style! Define some styles for the site title below the existing styles in your layout.module.css file.\n*src/components/layout.module.css*\n```\n/* ... your existing styles */\n.site-title {\n  font-size: 3rem;\n  color: gray;\n  font-weight: 700;\n  margin: 3rem 0;\n}\n```\n\nImport your new styles into your Layout component and apply them to the site title paragraph you added.\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText,\n  siteTitle,\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <div className={container}>\n      <title>{pageTitle} | {data.site.siteMetadata.title}</title>\n      <header className={siteTitle}>{data.site.siteMetadata.title}</header>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\nCongratulations, you‚Äôve just used **GraphQL** to pull data into your site! Try changing the site title in your gatsby-config.js file and see your site update in the browser.\n\n### Queries in page components: Create a blog page with a list of post filenames\n\nSo far, your site has a few static landing pages: the Home page and the About page. The next step is to build out the actual blog page!\n\nEventually, **your blog page will link to separate pages for each of your posts**. But there‚Äôs a lot to learn to achieve that, so you‚Äôll be working up to that goal over the next few parts of the Tutorial (Parts 4, 5, and 6).\n\nIn this part, **you‚Äôll create a blog page that lists the filenames for your posts.**\n\n### Task: Create a new blog page\n\nStart by setting up the skeleton for your new blog page component.\n\nCreate a **new file: src/pages/blog.js**. Define and export a new page component for your blog page. Use your existing Layout component to add some basic structure.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst BlogPage = () => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <p>My cool posts will go in here</p>\n    </Layout>\n  )\n}\nexport default BlogPage\n```\n\nAdd a link to your new blog page to the navigation bar in your Layout component:\n*src/components/layout.js*\n```\n// ... import statements\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <div className={container}>\n      <title>{pageTitle} | {data.site.siteMetadata.title}</title>\n      <header className={siteTitle}>{data.site.siteMetadata.title}</header>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/blog\" className={navLinkText}>\n              Blog\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\nNow, if you go to *localhost:8000/blog* in your web browser, you should see your new blog page skeleton, and there should be a link to the blog page in your navigation bar.\n\n### Task: Create some MDX blog posts\nNow that you have a blog page, it‚Äôs time to create some blog posts! For your site, you‚Äôll store each blog post as a separate file inside of a folder in your project.\n\nCreate a **new directory called blog at the top level of your project folder.**\n\n**Create three new files in the blog directory: one for each post**. It doesn‚Äôt matter what you name them, as long as **they end with the .mdx extension**. (You‚Äôll learn more about the powers of MDX in Part 5.) You can leave the files empty for now.\n\n### Task: Use GraphiQL to build the query\nNow that **you have some posts saved to your local filesystem**, it‚Äôs time to **pull those files into the Gatsby data layer**. To do that, you‚Äôll use a **plugin called *gatsby-source-filesystem***.\n\n*Note*: Remember the process for adding a plugin to your site from Part 3? The first step was to install the plugin.\n\nIf you‚Äôve been following along from the beginning, you should already have installed gatsby-source-filesystem in Part 3 (because you needed it for adding static images with gatsby-plugin-image).\n\nOtherwise, you can install the plugin by running the following command from the command line:\n\n```\nnpm install gatsby-source-filesystem\n```\n\nConfigure gatsby-source-filesystem in your gatsby-config.js file. Since gatsby-source-filesystem requires some additional configuration options, you‚Äôll use a configuration object instead of a string. The code example below shows **how to ‚Äúsource‚Äù files from your blog directory** (in other words, how to add them to the data layer).\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    \"gatsby-plugin-image\",\n    \"gatsby-plugin-sharp\",\n    {\n      resolve: \"gatsby-source-filesystem\",\n      options: {\n        name: `blog`,\n        path: `${__dirname}/blog`,\n      }\n    },\n  ],\n};\n```\n\nA closer look at the configuration options:\n\n**When your site builds, gatsby-source-filesystem adds all the files in the folder specified by the path option to the data layer**.\n- **__dirname**: is a variable from Node.js that stores the absolute path for the directory that contains the file currently being run.)\n\n- The **name** option in the configuration object gets set to the **sourceInstanceName** field for each file. This comes in handy when you want to source files from multiple folders. **By giving each folder a different name option, you can build GraphQL queries that filter down to only a particular folder**.\n\nRestart your local development server to make sure it picks up the configuration changes and adds your files to the data layer.\n\nYou can use the **allFile** field to **request data about multiple files at once**. In GraphiQL, try exploring the different fields within allFile to see what sorts of data you get back. Then build a query using the allFile field to get the name of all the files in your blog folder:\n\n```\nquery MyQuery {\n  allFile {\n    nodes {\n      name\n    }\n  }\n}\n```\n\nRun the query in GraphiQL. Your response in the Result Window should look something like the object below:\n```\n{\n  \"data\": {\n    \"allFile\": {\n      \"nodes\": [\n        {\n          \"name\": \"my-first-post\"\n        },\n        {\n          \"name\": \"another-post\"\n        },\n        {\n          \"name\": \"yet-another-post\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\n**-- Seeing more nodes than expected? --**\nIf you‚Äôre still using a StaticImage from an external URL (like https://some-site/image.jpg) on your home page, you‚Äôll see an extra node for that image show up in your GraphQL response. That‚Äôs because StaticImage uses \n**createRemoteFileNode**\n under the hood which **creates a File node for each image it downloads**. **If you‚Äôre only using images from your filesystem, you won‚Äôt see the extra node**.\n\nTo get rid of it, **you can update your GraphQL query to filter the File nodes using the sourceInstanceName field** (which corresponds to the value of the name option you set for gatsby-source-filesystem in your gatsby-config.js file).\n\n*src/pages/blog.js*\n```\nquery {\n  allFile(filter: {sourceInstanceName: {eq: \"blog\"}}) {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n***filter* is an argument that gets passed into the allFile field**. Some fields take arguments, which you can use to change the way that nodes get returned in your final GraphQL response.\n\n### Task: Use a page query to pull the list of post filenames into your blog page\n\nNow that you‚Äôve built a GraphQL query that returns a list of your post filenames, it‚Äôs time to render that data in your blog page!\n\n**Using GraphQL queries in page components uses a slightly different syntax from queries in building-block components**. In page components, you use page queries.\n\n**-- Key Gatsby Concept --** :  Pulling data into page components with page queries\nThe process for making a query in a page component looks slightly different from useStaticQuery:\n\n- **Import the graphql tag** from the Gatsby package.\n- **Export a variable that stores a templated string with the GraphQL query you want to run**. When your site gets built, **Gatsby will run your page query and pass the resulting data into your page component as a prop called *data***. **Your page query needs to be defined outside of your page component**. (With useStaticQuery, your query was defined inside your component.)\n- Use the data prop in your page component, as needed. You can use the JavaScript dot operator (.) to choose fields off of the data prop.\n\nHere‚Äôs a small example to show what this process looks like in practice:\n\n```\nimport * as React from 'react'\n// Step 1: Import the graphql tag\nimport { graphql } from 'gatsby'\nconst HomePage = ({ data }) => {\n  return (\n    <p>\n      { /* Step 3: Use the data in your component*/ }\n      { data.site.siteMetadata.description }\n    </p>\n  )\n}\n// Step 2: Export a page query\nexport const query = graphql`\n  query {\n    site {\n      siteMetadata {\n        description\n      }\n    }\n  }\n`\nexport default HomePage\n```\n\n\n**--.--**\n\nFollow the steps below to add a list of post filenames to your blog page.\n\nImport the graphql tag from the Gatsby package.\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = () => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <p>My cool posts will go in here</p>\n    </Layout>\n  )\n}\nexport default BlogPage\n```\nDefine and export your page query. Copy over the query you built in GraphiQL.\nNote: By default, the query you build in GraphiQL will have a query name, like MyQuery. You may see an error if you have more than one query with the same name, so after you copy your query over from GraphiQL to your component, delete the name (as in the code example below).\n\nAlternatively, you can give each of your queries a unique name. Query names can be useful for debugging errors that show up in your console when Gatsby executes your queries at build time.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = () => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <p>My cool posts will go in here</p>\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allFile {\n      nodes {\n        name\n      }\n    }\n  }\n`\nexport default BlogPage\n``` \n\nAdd in the data prop to the function definition. Then replace the placeholder ```<p>``` element with a list of the filenames for your posts. Use the ```JavaScript array .map()``` method to iterate over the nodes array and render the filename for each post.\n\n.map() takes in a function, which it runs on each element in the array. In the code block below, you‚Äôre using .map() to loop over each of the nodes in data.allFile.nodes and return a React element that wraps the node‚Äôs name in an ```<li>``` element.\n\nIn React, when you use the .map() method to render a list of elements, you should give **each element in the list a unique key prop**. This helps React keep track of what values have changed and need to be rerendered. For more on rendering lists in React, check out the React Docs: Lists and Keys.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <ul>\n      {\n        data.allFile.nodes.map(node => (\n          <li key={node.name}>\n            {node.name}\n          </li>\n        ))\n      }\n      </ul>\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allFile(filter: {sourceInstanceName: {eq: \"blog\"}}) {\n      nodes {\n        name\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nGood job! You‚Äôve finished the first step of your new blog page.\n\nYou won‚Äôt be able to render the contents of your posts just yet, since your site doesn‚Äôt know how to process MDX. You‚Äôll fix that in the next part of the Tutorial!\n\n## Summary\n\nTake a moment to think back on what you‚Äôve learned so far. Challenge yourself to answer the following questions from memory:\n\n- How do you get data into the data layer?\n- How can you see what data is in the data layer?\n- How do you get data out of the data layer?\n- What are the differences between a page query and useStaticQuery? How would you decide which one to use?\n\n## Key takeaways\n\n- Source plugins pull data from their original location into the Gatsby GraphQL data layer.\n- You can use the GraphiQL endpoint (localhost:8000/___graphql) to explore the data in the data layer and design GraphQL queries.\n- You can write GraphQL queries to pull data out of the data layer and into your React components.\n- To pull data into a ‚Äúbuilding block‚Äù component, use the useStaticQuery hook.\n- To pull data into a page component, use a page query.\n\n**-- Key Gatsby Concept --** : General process for using data in your site\n- Add a source plugin to add data into the GraphQL data layer.\n- Use GraphiQL to design a query that responds with the data you want from the data layer.\n- Add the query into your component.\n- Use page queries for page components.\n- Use useStaticQuery for ‚Äúbuilding block‚Äù components.\n- Use the data from the response in your component.\n**--.--**","references":"- [Query for Data with GraphQL](https://www.gatsbyjs.com/docs/tutorial/part-4/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-graphql","weblink":"https://codersnack.com/gatsbyjs-graphql","featured_image_preview":{"id":137,"name":"gatsbyjs-logo.png","hash":"c658d1c9999840f8ac797906ee5d5773","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/c658d1c9999840f8ac797906ee5d5773.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T22:21:47.480Z","updated_at":"2021-11-03T22:21:47.480Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - query for data with GraphQL","created_at":"2021-11-03T22:22:43.365Z","updated_at":"2021-11-03T22:22:43.374Z"},{"id":101,"codersnack":{"id":102,"header":"GatsbyJS - Transform Data to Use MDX","created_at":"2021-11-04T12:40:44.462Z","updated_at":"2021-11-04T13:47:51.504Z","explanation":"In Part 4, you used the gatsby-source-filesystem source plugin to build a Blog page that lists the names of your blog post files. But **you weren‚Äôt able to actually render the contents of your post files**, because gatsby-source-filesystem doesn‚Äôt provide a field for it. To do that,**you‚Äôll need another type of plugin called a *transformer* plugin**.\n\nSometimes, the format of the data you get from source plugins isn‚Äôt exactly what you want to use to build your website. For example, the filesystem source plugin lets you query data about files, but it doesn‚Äôt let you use the data inside the files themselves. To make this possible, **Gatsby supports transformer plugins, which take the raw content from source plugins and transform it into something more usable**.\n\nIn this part of the Tutorial, you‚Äôll learn about one particular transformer plugin, **gatsby-plugin-mdx**, which **lets you use MDX, a file format that allows Markdown and JSX alongside your text content**. (Fun fact: this Tutorial is actually written in MDX!) You‚Äôll use MDX to add some content to your blog post files, and then you‚Äôll use gatsby-plugin-mdx to render the contents of your posts on your Blog page.\n\n> ***Note***: Usually, transformer plugin names start with **gatsby-transformer-**. (*gatsby-plugin-mdx is one exception* to this convention.) To see a list of other transformer plugins, try searching for gatsby-transformer- in the Gatsby Plugin Library.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Write an MDX file with Markdown formatting and frontmatter.\n- Use the gatsby-plugin-mdx plugin to render the contents of your MDX files on your Blog page.\n- Use the sort field to control the order of results in your GraphQL queries.\n\n##¬†A closer look at Gatsby‚Äôs GraphQL data layer\n\nTo understand how gatsby-plugin-mdx and other transformer plugins work, you need to know a bit more about how Gatsby‚Äôs GraphQL data layer works.\n\n**Inside the data layer, information is stored in objects called *nodes***. A **node is the smallest form unit of data in the data layer**. **Different source plugins create different types of nodes, each of which have their own properties**. For example, gatsby-source-filesystem creates File nodes.\n\n**A transformer plugin converts nodes from one type to another**. For example, **the gatsby-plugin-mdx plugin transforms File nodes that have the .mdx extension into MDX nodes**, which have a different set of fields that you can query using GraphQL. **Transformer plugins let you manipulate the raw data in the nodes created by source plugins, so that you can get it into the structure or format you need.**\n\n![Gatsby data layer](https://codersnack.com/assets/images/gatsbyjs-data-layer-with-nodes.png)\n\n> ***Note***: Even though it‚Äôs called a transformer plugin, it‚Äôs not actually changing the original nodes created by the source plugins. Each transformer plugin creates new nodes based on the data from the sourced nodes, but it doesn‚Äôt actually change the source nodes themselves. So even though gatsby-plugin-mdx creates new MDX nodes in the data layer, you can still access the original File nodes created by gatsby-source-filesystem.\n\n##¬†Add some MDX content to your blog posts\n\nIn Part 4, you created empty files for your blog posts. Now, it‚Äôs time to fill them in!\n\n> **-- Using Markdown formatting in MDX --**\nMDX files let you format text using Markdown, a markup language that uses a special syntax to add special formatting to your text elements. For example, you can make text appear strong by wrapping it in **double asterisks**, or you can create a link by using a syntax like [text to link](url).\nOnce you get used to what all the different symbols mean, **Markdown can be easier to read than HTML**, which makes it a popular format for written content like blog posts.\nNew to Markdown? The **MDX documentation includes a table of components** that shows the different formatting options available. It includes things like *headings*, *blockquotes*, *lists*, and *code blocks*.\n**Frontmatter**\n**With gatsby-plugin-mdx, you can also add frontmatter to your MDX files.** Frontmatter is **additional metadata about your file**. It won‚Äôt be rendered on your page, but **it‚Äôs a way for you to add some extra details about your content**. For example, you might store your post title or the date it was published.\nTo add frontmatter to your post, put it between an opening and closing set of **three hyphens (---) at the top of your MDX file**. Within the opening and closing hyphens, you can create **key-value pairs for any kind of data you want to store about your file**.\nHere‚Äôs an example: \n```\n---\nname: \"Fun Facts about Red Pandas\"\ndatePublished: \"2021-07-12\"\nauthor: \"#1 Red Panda Fan\"\n---\n```\n\nAdd some Markdown content to each of the .mdx files you created in your /blog directory in Part 4. Include frontmatter with fields for the title of each post and the date it was published. (Give each post a different date, to make it easier to add sorting later on.) After the frontmatter, write some post content using some Markdown syntax.\n\nHere are some example posts that you can use for inspiration:\n\n*blog/my-first-post.mdx*\n```\n---\ntitle: \"My First Post\"\ndate: \"2021-07-23\"\n---\nThis is my first blog post! Isn't it *great*?\nSome of my **favorite** things are:\n* Petting dogs\n* Singing\n* Eating potato-based foods\n```\n\n*blog/another-post.mdx*\n```\n---\ntitle: \"Another Post\"\ndate: \"2021-07-24\"\n---\nHere's another post! It's even better than the first one!\n```\n\n*blog/yet-another-post.mdx*\n```\n---\ntitle: \"Yet Another Post\"\ndate: \"2021-07-25\"\n---\n```\n\nWow look at all this content. How do they do it?\n\n###¬†Render each post‚Äôs contents on the Blog page\nNow that you have some MDX content inside your blog posts, it‚Äôs time set up the gatsby-plugin-mdx transformer plugin.\n\n> ***Quick Refresher***: Remember the process for adding a plugin to your site (from Part 3)? See if you can remember the three steps from memory before checking your answer. (Science has shown that the act of trying to actively recall information helps you retain it better!)\n\nThe **gatsby-plugin-mdx plugin provides some new tools for you to use** in your site:\n\n- The **allMdx** and **mdx** fields (for your GraphQL queries)\n- An **MDXRenderer component** (for processing and displaying MDX content)\n\nTo render your posts on the Blog page, you‚Äôll complete a few different steps:\n\n- Install and configure the gatsby-plugin-mdx transformer plugin and its dependencies.\n- **Update the Blog page query to use the allMdx field from gatsby-plugin-mdx instead of allFile**.\n- **Use the MDXRenderer component from gatsby-plugin-mdx to render your post‚Äôs MDX contents in the JSX for your Blog page.**\n\n#### Task: Install and configure the MDX transformer plugin (and dependencies)\nThe gatsby-plugin-mdx package requires a few **additional dependencies to run**: **@mdx-js/mdx** (which implements MDX) and **@mdx-js/react** (which maps the MDX implementation to React components).\n\nIn your terminal, run the command below to install gatsby-plugin-mdx and its dependencies. (This adds all three packages to the dependencies object in your package.json file and to your node_modules directory.)\n\n```\nnpm install gatsby-plugin-mdx @mdx-js/mdx @mdx-js/react\n```\n\nAdd gatsby-plugin-mdx to the plugins array in your gatsby-config.js file, so that Gatsby knows to use the plugin when building your site.\n\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My Super Cool Blog\",\n  },\n  plugins: [\n    \"gatsby-plugin-image\",\n    \"gatsby-plugin-sharp\",\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `blog`,\n        path: `${__dirname}/blog/`,\n      },\n    },\n    \"gatsby-plugin-mdx\",\n  ],\n};\n```\n> *Tip*: There are a variety of remark plugins that you can use to add extra features to your Markdown. You can configure them using the **gatsbyRemarkPlugins** option when you configure gatsby-plugin-mdx in your gatsby-config.js file.\nHere are some popular remark plugins:\n1.- **gatsby-remark-images**: Use this if you want to **generate responsive images when using the Markdown image syntax** (which looks like this: ![alt](image url)). To use this plugin, you‚Äôll also **need gatsby-plugin-sharp**, which you installed already in Part 3.\n2.- **gatsby-remark-prismjs**: Add syntax highlighting to your code blocks.\n3.- **gatsby-remark-autolink-headers**: **Automatically create links for all the headers in your Markdown content.**\nTry searching for gatsby-remark- in the Gatsby Plugin Library for a full list.\n\n#### Task: Update the Blog page query to use the allMdx field instead of allFile\nThe gatsby-plugin-mdx plugin makes two new fields available for you to use in your GraphQL queries: **allMdx** and **mdx**. In this part of the Tutorial, you‚Äôll use allMdx to add the contents of each blog post to your Blog page. (You‚Äôll use the mdx field later on, in Part 6.)\n\n**You can use the allMdx field to request data for multiple MDX nodes at once** (similar to the way allFile worked with File nodes). Open GraphiQL and explore what fields are available on MDX nodes. Try running a few queries to see what kind of information you get back.\n\n> *Quick Refresher*: Remember how to access GraphiQL? See if you can remember the steps before checking for the answer in Part 4. (Check the section called ‚ÄúUse GraphiQL to explore the data layer and write GraphQL queries‚Äù).\n\n**Use GraphiQL to create a new query that gets data about your blog posts using the allMdx field instead of the allFile field**.\n\nUnder allMdx, open the nodes dropdown. Inside the frontmatter dropdown, you should see fields for all the keys you created in the frontmatter of your MDX files. Select the title and date fields. You can use the formatString argument on the date field to change the way your dates are displayed (see Syntax Hint below).\n```\nquery MyQuery {\n  allMdx {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n    }\n  }\n}\n```\n\n> Syntax Hint: When it comes to using dates in your frontmatter, the **formatString argument** is a helpful tool for changing the way the date is displayed.\nImagine you have a key in your frontmatter with a value that uses a date format like \"YYYY-MM-DD\". (It doesn‚Äôt matter what you name the key, as long as the value has the required format.) GraphiQL will automatically detect that your value is a date, and when you select the corresponding frontmatter field in the Explorer pane, GraphiQL will automatically show a few arguments that you can pass to that field. One of those arguments is called formatString, which you can pass a **Moment.js formatting token** to change the way the date displays.\nFor example, if your MDX frontmatter looks like this:\n```\n---\ndate: \"2021-07-23\"\n---\n```\n\n‚Ä¶and your GraphQL query looks like this:\n\n```\nquery MyQuery {\n  allMdx {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n      }\n    }\n  }\n}\n```\n‚Ä¶then the dates in your response will look like this: \"July 23, 2021\".\n\n------\n\nWhile you‚Äôre at it, **add the id field, which is a unique string that Gatsby automatically adds to every node in the data layer**. (You‚Äôll use this as a **React key** later on, when you iterate over your list of posts.)\n\n```\nquery MyQuery {\n  allMdx {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n      id\n    }\n  }\n}\n``` \n\nExecute your query by clicking the triangle button. Your response object should look something like this:\n\n```\n{\n  \"data\": {\n    \"allMdx\": {\n      \"nodes\": [\n        {\n          \"frontmatter\": {\n            \"date\": \"July 25, 2021\",\n            \"title\": \"Yet Another Post\"\n          },\n          \"id\": \"c4b5ae6d-f3ad-5ea4-ab54-b08a72badea1\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 23, 2021\",\n            \"title\": \"My First Post\"\n          },\n          \"id\": \"11b3a825-30c5-551d-a713-dd748e7d554a\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 24, 2021\",\n            \"title\": \"Another Post\"\n          },\n          \"id\": \"560896e4-0148-59b8-9a2b-bf79bee68fba\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nYou might notice that your posts aren‚Äôt listed in order. Most blog sites **list their posts in reverse-chronological order,** so that the newest posts are listed first. **You can sort the data nodes in your response by using the sort argument on the allMdx field**.\n\n- In the Explorer pane, toggle the **sort dropdown underneath the allMdx **field.\n- Under sort, check the fields argument, and use the dropdown to select which field you want to sort your data nodes by. In this case, that would be **frontmatter___date** (with three underscores).\n- Check the order argument, and use the dropdown to select DESC. This will sort the nodes in descending order, so that the newest posts come first.\n```\nquery MyQuery {\n  allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n      id\n    }\n  }\n}\n```\n\nRun your query again to verify that the posts come back in the correct order. Your response should look something like this:\n\n```\n{\n  \"data\": {\n    \"allMdx\": {\n      \"nodes\": [\n        {\n          \"frontmatter\": {\n            \"date\": \"July 25, 2021\",\n            \"title\": \"Yet Another Post\"\n          },\n          \"id\": \"c4b5ae6d-f3ad-5ea4-ab54-b08a72badea1\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 24, 2021\",\n            \"title\": \"Another Post\"\n          },\n          \"id\": \"560896e4-0148-59b8-9a2b-bf79bee68fba\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 23, 2021\",\n            \"title\": \"My First Post\"\n          },\n          \"id\": \"11b3a825-30c5-551d-a713-dd748e7d554a\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nThe last thing you need to add to your query is the contents of each post! To do that, add the body field to your query.\n\n```\nquery MyQuery {\n  allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n      id\n      body\n    }\n  }\n}\n```\n\nWhen you run your query, the body field for each node should look something like the data shown below. That‚Äôs a lot of information! The body field actually contains the compiled MDX content for your file. It might not be readable for humans, but it‚Äôs the format that the MDXRenderer component understands. (You‚Äôll get to MDXRenderer in a moment.)\n\nNow that you have your GraphQL query all set up, it‚Äôs time to tackle the last piece of the puzzle: rendering your posts in the Blog page.\n\n> *Pro Tip*: When transformer plugins create a new node, they add a parent field that references back to the original source node it was created from. For example, when gatsby-plugin-mdx creates new MDX nodes, **it adds a parent field which you can use to access data from the original File node**.\nUsing the parent node can come in handy if you want to use data from the transformed nodes along with data from the original source nodes. For example, the query below gives you back the time a file was changed, which you could use to display when a post was last updated.\nquery MyQuery {\n  allMdx {\n    nodes {\n      parent {\n        ... on File {\n          modifiedTime(formatString: \"MMMM D, YYYY\")\n        }\n      }\n    }\n  }\n}\n\n####¬†Task: Use the MDXRenderer component to render your post‚Äôs contents in your Blog page\nNow that your GraphQL query is all set up, it‚Äôs time to replace the page query in your Blog page component.\n\n**Start by swapping out the allFile page query in your Blog page for the one you just created using allMdx**. (Don‚Äôt forget to delete the query name!) And if you haven‚Äôt already from completing the task in Part 4, you‚Äôll need to import the graphql tag from the gatsby package.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    // ...\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          date(formatString: \"MMMM D, YYYY\")\n          title\n        }\n        id\n        body\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nNext, **update the JSX for your Blog page to use the data fields of your response**. Start by rendering just the title and date for each post.\n\nNow that you‚Äôre rendering more than just a filename, it makes more sense to use the ```<article>```  semantic HTML element instead of a ```<ul>``` and nested ```<li>``` elements.\nYou can also use the **id field as your unique key prop for each post**. (React uses the key prop to keep track of what elements need to be re-rendered. If you don‚Äôt include it, you‚Äôll get a warning in your browser console. For more on the key prop, check out the React Docs: List and Keys.)\n\n*src/pages/blog.js*\n```\n// imports\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      {\n        data.allMdx.nodes.map((node) => (\n          <article key={node.id}>\n            <h2>{node.frontmatter.title}</h2>\n            <p>Posted: {node.frontmatter.date}</p>\n          </article>\n        ))\n      }\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          title\n          date(formatString: \"MMMM DD, YYYY\")\n        }\n        id\n        body\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nThe final step in this part of the Tutorial is to **render the actual contents of your MDX blog posts**. To do that, you‚Äôll need to use a component from gatsby-plugin-mdx called **MDXRenderer**. Start by importing the component into your Blog page:\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport Layout from '../components/layout'\n// ...\n```\n\n**-- The MDXRenderer component --**\nMDXRenderer is a component included in the gatsby-plugin-mdx plugin that you can use to render the contents of a .mdx file.\n\nThe MDXRenderer uses the children prop, similar to the Layout component you created in Part 2. It expects to receive compiled MDX between its opening and closing tags. You can pass in the body field from an MDX node.\n\n> Quick Refresher: Need a reminder of how the children prop works? Refer back to the ‚ÄúCreate a reusable layout component‚Äù section in Part 2.\n\nHere‚Äôs a quick example of how to import and use the MDXRenderer component:\n\n```\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\n// Use this in the JSX for your component\n<MDXRenderer>\n  { node.body }\n</MDXRenderer>\n```\n**--.--**\n\nIn the JSX for your Blog page, use the MDXRenderer component to wrap the contents of the body field for each node:\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport Layout from '../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      {\n        data.allMdx.nodes.map((node) => (\n          <article key={node.id}>\n            <h2>{node.frontmatter.title}</h2>\n            <p>Posted: {node.frontmatter.date}</p>\n            <MDXRenderer>\n              {node.body}\n            </MDXRenderer>\n          </article>\n        ))\n      }\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          title\n          date(formatString: \"MMMM DD, YYYY\")\n        }\n        id\n        body\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n![gatsbyjs-blog-page-with-full-posts](https://codersnack.com/assets/images/gatsbyjs-blog-page-with-full-posts.png)\n\n## Key takeaways\n- Data in Gatsby‚Äôs GraphQL data layer is stored in **nodes**.\n- **Each source plugin creates a different type of node** with different fields.\n- **Transformer plugins create new types of nodes**, using data from existing source nodes as a starting point. Transformer plugins don‚Äôt actually change the original source nodes.\n**gatsby-plugin-mdx is a transformer plugin that lets you use MDX in your site**. With MDX, you can create text content with **Markdown formatting and embedded React components**.\n\n\n","references":"- [Transform Data to Use MDX](https://www.gatsbyjs.com/docs/tutorial/part-5/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-transform-data-mdx","weblink":"https://codersnack.com/gatsbyjs-transform-data-mdx","featured_image_preview":{"id":138,"name":"gatsbyjs-logo.png","hash":"de131704198e492784094b1c5404791f","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/de131704198e492784094b1c5404791f.png","provider":"local","provider_metadata":null,"created_at":"2021-11-04T12:40:44.488Z","updated_at":"2021-11-04T12:40:44.488Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - transform data to use MDX","created_at":"2021-11-04T12:41:22.709Z","updated_at":"2021-11-04T13:09:54.725Z"},{"id":102,"codersnack":{"id":104,"header":"GatsbyJS - Create Pages Programmatically","created_at":"2021-11-04T17:12:40.498Z","updated_at":"2021-11-04T17:30:09.099Z","explanation":"In Part 5, you added all of your blog posts to your Blog page. But that means that your Blog page will get longer and longer as you add more posts to your site. **It would be better if each post lived on its own page, and then your Blog page could link out to all the different posts.**\n\nSo far, the way you‚Äôve created new pages for your Gatsby site is by creating a new file in the src/pages directory and hard-coding the page‚Äôs contents in JSX. But manually creating a new page for each post would be quite repetitive, especially since each page has the same structure: render the frontmatter and contents of an MDX file.\n\nIn this part of the Tutorial, **you‚Äôll learn how to create new pages dynamically using Gatsby‚Äôs Filesystem Route API.**\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- **Use Gatsby‚Äôs Filesystem Route API to dynamically create new pages for your blog posts**.\n- **Add a query variable to a page query.**\n\n## Create new routes dynamically with Gatsby‚Äôs File System Route API\n\nWhen you build your Gatsby site, **Gatsby creates a new route for each page component in your src/pages directory**. So far, you‚Äôve only been building one page per file: the index.js file creates the Home page, the about.js file creates the About page, and the blog.js file creates the Blog page.\n\nBut **you can also use one page component to create multiple pages**. Instead of hard-coding all the contents, **you‚Äôll create a template to outline the basic structure of your page, and then Gatsby can dynamically add in the specific data for each page at build time.** To do that, you‚Äôll use **Gatsby‚Äôs File System Route API**, which lets you create routes dynamically by naming your page files with a special syntax.\n\n**-- Key Gatsby Concept: File System Route API --**\n**Gatsby‚Äôs File System Route API defines a special syntax for naming the files in your *src/pages* directory**, which lets you dynamically create new pages for your site based on a collection of nodes in the data layer.\n\nFor example, imagine your site had a bunch of Product nodes in the data layer. You could use the File System Route API to create one product page template component. Then, when you built your site, Gatsby would combine that page template with the data for each Product node and generate a new page for each product. And if you decided you needed to make changes to your product page, you‚Äôd only have to edit the template component, and Gatsby would update all your product pages the next time it rebuilt the site.\n\nTo create a collection route:\n\n- **Decide what type of node** you want to create pages from.\n- Choose **which field on that node to use in the route (the URL) **for your pages.\n- Create a **new page component in your src/pages directory using the following naming convention: *{nodeType.field}.js*.**\n- **Don‚Äôt forget to include the curly braces ({}) in your filenames to indicate the dynamic part of the route!**\n\nFor example, if you wanted to create a separate page for each Product node, and you wanted to use the product‚Äôs name field in the URL, you‚Äôd create a new file at src/pages/{Product.name}.js. Then Gatsby would create those pages at routes like /water-bottle or /sweatshirt or /notebook.\n\n**--.--**\n\nIn this part of the Tutorial, you‚Äôll use Gatsby‚Äôs File System Route API to dynamically create new pages for each of your blog posts.\n\nAccording to the API, you need to decide on two things before creating a collection route:\n\n- Which **type of nod**e to create pages from.\n- Which **field from that node type to use in the URL.**\n\n**Since your blog posts are written in MDX, you‚Äôll use MDX as the node type to create pages from**. But which field on the MDX nodes should you use?\n\ngatsby-plugin-mdx automatically adds a **slug field to each MDX node**, which contains a string of the filename for the .mdx file (with the .mdx extension removed). You can see the slug field‚Äôs value for each MDX node in GraphiQL. If you run the following query:\n\n```\n{\n  allMdx {\n    nodes {\n      slug\n    }\n  }\n}\n```\n\n‚Ä¶you should get back something like the result below:\n\n```\n{\n  \"data\": {\n    \"allMdx\": {\n      \"nodes\": [\n        {\n          \"slug\": \"my-first-post\"\n        },\n        {\n          \"slug\": \"yet-another-post\"\n        },\n        {\n          \"slug\": \"another-post\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nThat looks like a good format for a URL!\n\n> *Note*: In this case, the slug field is a good choice because it‚Äôs human readable, which means the URLs for your blog posts will be easier for users to understand. But you can use any field in your routes, even if it contains special characters or whitespace, as **Gatsby will \"slugify\" every route**. For example, I ‚ô• Dogs will be converted to i-love-dogs.\n\n### Task: Create blog post page template\n\nNow that you know what node type and field to use, you can plug them into the File System Routes naming convention. To create new pages from the slug field of your MDX nodes, you should make **a new file at src/pages/{mdx.slug}.js**.\n\nThe diagram below shows the different routes that Gatsby will create when it builds your site:\n![gatsbyjs-file-system-routes](https://codersnack.com/assets/images/gatsbyjs-file-system-routes.png)\n\n\nA diagram showing how **files in the \"src/pages\" directory get turned into routes for the site**. Extended description below.\n\n> When you build your site, Gatsby looks at the page components in your src/pages directory and creates new pages for your site.\n- src/pages/index.js lives at the / route.\n- src/pages/blog.js lives at the /blog route.\n- **src/pages/{mdx.slug}.js gets turned into multiple routes** - one for each MDX node in the data layer. \n\nCreate a new file in your src/pages directory called {mdx.slug}.js. This will be the file for your blog post page template.\n\nCreate a basic page component in your new {mdx.slug}.js file. For now, add in the Layout component, but hard code the page title and page contents. (You‚Äôll make those dynamic later on.)\n\n*src/pages/{mdx.slug}.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst BlogPost = () => {\n  return (\n    <Layout pageTitle=\"Super Cool Blog Posts\">\n      <p>My blog post contents will go here (eventually).</p>\n    </Layout>\n  )\n}\nexport default BlogPost\n```\n\nIn a web browser, go to *localhost:8000/my-first-post* and you should see your hard-coded content. You can update your URL with the slugs for your other posts to check that identical pages were created for them too.\n\n> **Pro Tip**: Not sure which pages were created? Check out the 404 page when you run gatsby develop. (You can get to it by trying to access the URL for a page that doesn‚Äôt exist.) The bottom of the page lists the routes for all the pages Gatsby created for your site. (If you‚Äôre making changes to your routes, you‚Äôll have to stop and restart your local development server for the list of pages on the 404 page to update.)\n\n![gatsbyjs-404-page-with-routes](https://codersnack.com/assets/images/gatsbyjs-404-page-with-routes.png)\n\n### Task: Update route to include a /blog path parameter\n\nSo far, all of your pages have been created off the root domain of your site (localhost:8000). **But it would be better (both for search engine optimization and for general organization) if you grouped all your blog posts under a /blog path parameter**. That way, the URLs for all your blog posts would start with localhost:8000/blog/.\n\n**Since Gatsby builds page routes based on the folder structure inside the src/pages directory, you can add new path parameters to a page by creating subdirectories inside of src/pages**.\n\nThe following diagram shows an overview of the updates you‚Äôll have to make in order to add a /blog path parameter to the routes for your blog posts. The process is also outlined in more detail below.\n\n\n![gatsbyjs-file-system-routes-with-blog-subdirectory](https://codersnack.com/assets/images/gatsbyjs-file-system-routes-with-blog-subdirectory.png)\n\n> When Gatsby builds the pages for your site, it creates routes based on the folder structure of the src/pages directory. So if your src/pages directory contains subdirectories with page components, the name of the subdirectory will get added as a path parameter for those pages.\nsrc/pages/index.js still lives at the / route.\nsrc/pages/blog/index.js lives at the /blog route.\nsrc/pages/blog/{mdx.slug}.js gets turned into multiple routes - one for each MDX node in the data layer.\nGatsby uses the MDX node with slug my-first-post to build a page that lives at the blog/my-first-post route.\nGatsby uses the MDX node with slug another-post to build a page that lives at the blog/another-post route.\nGatsby uses the MDX node with slug yet-another-post to build a page that lives at the blog/yet-another-post route.\n\nCreate a **new folder in your src/pages directory, and call it blog**.\n\n**Move the src/pages/{mdx.slug}.js file into the new blog subdirectory**. Update the import for your Layout component to reflect the new folder structure:\n\n*src/pages/blog/{mdx.slug}.js*\n```\nimport * as React from 'react'\nimport Layout from '../../components/layout'\n// ...\n```\n\nOnce your **local development server rebuilds your site**, check in a web browser that the paths to your blog posts have updated.\n\nFor example, you should now have a page at localhost:8000/blog/my-first-post, and trying to access localhost:8000/my-first-post (without the blog path parameter) should send you to the 404 page.\n\n> **Pro Tip**: **Gatsby caches information about your site as it builds it, to make subsequent builds faster**. But sometimes, when you make changes to your site, you‚Äôll need to empty the cache for your changes to show up.\nIf you‚Äôre seeing unexpected behavior (like maybe your local development server isn‚Äôt picking up your new changes), you can run **gatsby clean** from the command line to delete the cache and start fresh on your next build.\nDon‚Äôt have the Gatsby CLI globally installed? Try running npx gatsby clean instead.\n\nFor organization, **it would be nice to keep all your blog-related pages together**. **Move the src/pages/blog.js file into your new src/pages/blog directory as well**.\n\n**Rename the file from blog.js to index.js**. (Otherwise your blog page will move to localhost:8000/blog/blog).\n\nYou‚Äôll also need to update the import for the Layout component to reflect the new folder structure:\n\n*src/pages/blog/index.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport Layout from '../../components/layout'\n// ...\n```\n\nYou may need to stop and **restart your local development server** for the changes to be picked up.\n\nIn a web browser, check that your Blog page still shows up at localhost:8000/blog.\n\nNice work! You‚Äôve now used Gatsby‚Äôs File System Route API to create pages from nodes in the data layer.\n\n### Render post contents in the blog post page template\n\nNow that you‚Äôve got all the pages for your posts set up, it‚Äôs time to pull in the actual post contents. You learned in Part 4 that you can pull data into your components using GraphQL queries. But **how can you tell Gatsby which MDX node from the data layer to pull into each page? **To do that, you‚Äôll need to learn about another key **GraphQL concept: query variables**.\n\n**-- Key GraphQL Concept: Query Variables --**\n**In GraphQL, query variables are a way to send extra data along with your request**. With query variables, **you can write dynamic queries that return different data based on the values you pass in**.\n\nLet‚Äôs take a look at an example in GraphiQL. In Part 5, you learned about passing arguments to fields to change the data you get back in the response. For example, you could use the query below to request data for the MDX node that has a slug field equal to \"another-post\":\n\n```\nquery MyQuery {\n  mdx(slug: {eq: \"another-post\"}) {\n    frontmatter {\n      title\n    }\n  }\n}\n```\n\n‚Ä¶which would return the following response:\n\n```\n{\n  \"data\": {\n    \"mdx\": {\n      \"frontmatter\": {\n        \"title\": \"Another Post\"\n      }\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nIn this case, y**our slug value is hard coded** into your GraphQL query. But what happens if you want to swap out a different value on a different page? That‚Äôs where **query variables come in**.\n\n**GraphiQL has a collapsible **\"Query Variables\"** section at the bottom of the *Query Editor pane***. If you click on it, a new text area appears, where **you can add key-value pairs for data that you want to pass into your query**. These key-value pairs should be written in **JSON**. For example, adding the object below to the Query Variables section passes your request **a query variable called slug with a value of another-post**:\n\n```\n{\n    \"slug\": \"another-post\"\n}\n```\n\nTo use the query variable inside your query, do the following:\n\n**Define your query variable: It should include the variable name (with a $ in front of it)** and **its GraphQL data type**.\nUse the query variable in your query. (You‚Äôll need to add a $ before the variable name.)\nFor example, here‚Äôs how you would update the previous query to use query variables instead of a field argument:\n\n```\nquery MyQuery($slug: String) {\n  mdx(slug: {eq: $slug}) {\n    frontmatter {\n      title\n    }\n  }\n}\n```\n\nRunning this new query should return the same response as the previous one without query variables. But now, you can swap out the value of your slug variable with a different value, like \"my-first-post\", and your response will send back the correct node.\n\nThe diagram below shows how the query, query variables, and response all fit together in the GraphiQL interface:\n\n![gatsbyjs-graphiql-with-query-variables](https://codersnack.com/assets/images/gatsbyjs-graphiql-with-query-variables.png)\n\nA screenshot of GraphiQL in a web browser. The Query Editor pane in the middle shows the request with query variables. The Query Variables pane below shows a JSON object with a single key-value pair for the `slug`. The Result Window shows the single MDX node returned in the response.\n\n> Note: I**n Gatsby, query variables can only be used inside of page queries. (You can‚Äôt use them with the useStaticQuery hook.)**\n\n**--.--**\n\nWhen you use **Gatsby‚Äôs File System Route API, it automatically adds some props into the page template component for each page**:\n\n- The **id** for the data layer node used to create the page.\n- The **field you used to create the dynamic part of the route**. (In this case, the slug field.)\n\nUnder the hood, Gatsby makes both of these values available to use as query variables in your page queries.\n\n**-- Want to take a closer look? --**\n\n**Add a console.log statement to print out the props for your BlogPost page component in src/pages/blog/{mdx.slug}.js.**\nIn a web browser, go to localhost:8000/blog/my-first-post and open the developer tools. In the console tab, you should see an object similar to the one below:\n```\nObject {\n  // ...\n  pageContext: Object { \n    id: \"11b3a825-30c5-551d-a713-dd748e7d554a\"\n    slug: \"my-first-post\"\n  }\n  // ...\n}\n```\nThe keys in the pageContext object get added when you create a page using the File System Route API. These are also the keys that are available for you to use as query variables in your page query for the blog post page template.\n\n**--.--**\n\n**Start by using GraphiQL to create a page query for your blog post page template**.\n\nSince each page only needs data for a single MDX node, use the **mdx field**. The fastest way to look up nodes is using the id field, so use the id query variable instead of slug.\n\n```\nquery MyQuery($id: String) {\n  mdx(id: {eq: $id}) {\n    frontmatter {\n      title\n      date(formatString: \"MMMM D, YYYY\")\n    }\n    body\n  }\n}\n```\n\n> **Tip**: If you want to test out your query in GraphiQL, you‚Äôll need to add an id key to the Query Variables section. You can copy one of the id values from running an allMdx query in GraphiQL.The JSON object in the Query Variables section should look something like the one below. (You‚Äôll need to use your own id, as copying the one below won‚Äôt work.):\n```\n{\n    \"id\": \"11b3a825-30c5-551d-a713-dd748e7d554a\"\n}\n```\n\n**Add your page query to the blog post page template**.\n\nDon‚Äôt forget to import the graphql tag!\n**You should also delete the query name MyQuery or replace it with a unique name.**\n*src/pages/blog/{mdx.slug}.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../../components/layout'\nconst BlogPost = () => {\n  return (\n    <Layout pageTitle=\"Super Cool Blog Posts\">\n      <p>My blog post contents will go here (eventually).</p>\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query ($id: String) {\n    mdx(id: {eq: $id}) {\n      frontmatter {\n        title\n        date(formatString: \"MMMM D, YYYY\")\n      }\n      body\n    }\n  }\n`\nexport default BlogPost\n```\n\nIn Part 4, you learned that Gatsby passes in the results from your page query into your page component as a data prop. You can update your BlogPost component to use the data prop and render the contents of your blog post. (Remember to import MDXRenderer so that you can render the body of your post!)\n\n*src/pages/blog/{mdx.slug}.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport Layout from '../../components/layout'\nconst BlogPost = ({ data }) => {\n  return (\n    <Layout pageTitle={data.mdx.frontmatter.title}>\n      <p>{data.mdx.frontmatter.date}</p>\n      <MDXRenderer>\n        {data.mdx.body}\n      </MDXRenderer>\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query ($id: String) {\n    mdx(id: {eq: $id}) {\n      frontmatter {\n        title\n        date(formatString: \"MMMM D, YYYY\")\n      }\n      body\n    }\n  }\n`\nexport default BlogPost\n```\n\nIn your web browser, go to one of your blog post pages (like localhost:8000/blog/my-first-post). You should see the contents of your blog post rendered in their own page!\n\n### Update Blog page to link to each post\n\nSo far, you‚Äôve used the File System Route API and GraphQL query variables to create separate pages for each of your blog posts.\n\nThe last step of Part 6 is to **clean up your Blog page. Instead of rendering the full contents of your blog posts, the Blog page should link out to the new post pages you just created.**\n\nIn your **src/pages/blog/index.js** file, remove the body field from your JSX and your page query. You can also get rid of the MDXRenderer component.\n\n*src/pages/blog/index.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      {\n        data.allMdx.nodes.map(node => (\n          <article key={node.id}>\n            <h2>{node.frontmatter.title}</h2>\n            <p>Posted: {node.frontmatter.date}</p>\n          </article>\n        ))\n      }\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          date(formatString: \"MMMM D, YYYY\")\n          title\n        }\n        id\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\n**Add the slug field to your page query, and use it to turn the post title into a link to the post page**.\n\nSince these links are between pages on your own site, you can use Gatsby‚Äôs Link component to get some extra performance benefits. If you use absolute URLs, you‚Äôll need to add the extra /blog/ path parameter, since the slug field only contains the last part of the path (like my-first-post).\n\n*src/pages/blog/index.js*\n```\nimport * as React from 'react'\nimport { Link, graphql } from 'gatsby'\nimport Layout from '../../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      {\n        data.allMdx.nodes.map(node => (\n          <article key={node.id}>\n            <h2>\n              <Link to={`/blog/${node.slug}`}>\n                {node.frontmatter.title}\n              </Link>\n            </h2>\n            <p>Posted: {node.frontmatter.date}</p>\n          </article>\n        ))\n      }\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          date(formatString: \"MMMM D, YYYY\")\n          title\n        }\n        id\n        slug\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nIn a web browser, go to localhost:8000/blog.\n\nCongratulations, you now have a multi-page blog site! Try adding some new .mdx files to your top-level blog directory. They should get added to your Blog page automatically when your site rebuilds!\n\n\n### Summary\n\nTake a moment to think back on what you‚Äôve learned so far. Challenge yourself to answer the following questions from memory:\n\nWhat is the File System Route API used for?\nWhat is the syntax for creating a new collection route?\nWhat is a query variable?\nWhen can you use a query variable?\n\n\n### Key takeaways\n\n- **Gatsby‚Äôs File System Route API lets you dynamically create new pages from data layer nodes** by naming your files with a special syntax.\n- **File System Routes only work on files in the src/pages directory (or subdirectories)**.\n- **To create a new collection route, you name your file {nodeType.field}.js**, where nodeType is the type of node you want to create pages from, and field is the data field from that node type that you want to use in the URL for that page.\n- **Query variables let you pass in different data values to the same GraphQL query**. They can be combined with field arguments to get back data only about a specific node.\n- Query variables **can only be used in page queries**.\n","references":"- [Create Pages Programmatically](https://www.gatsbyjs.com/docs/tutorial/part-6/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-create-pages-programmatically","weblink":"https://codersnack.com/gatsbyjs-create-pages-programmatically","featured_image_preview":{"id":140,"name":"gatsbyjs-logo.png","hash":"de4ec45acfc941e699e70c433359ee89","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/de4ec45acfc941e699e70c433359ee89.png","provider":"local","provider_metadata":null,"created_at":"2021-11-04T17:12:40.511Z","updated_at":"2021-11-04T17:12:40.511Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - create pages programmatically","created_at":"2021-11-04T17:13:07.057Z","updated_at":"2021-11-04T17:13:07.060Z"},{"id":103,"codersnack":{"id":105,"header":"GatsbyJS - Add Dynamic Images from Data","created_at":"2021-11-04T18:20:15.173Z","updated_at":"2021-11-04T18:20:15.173Z","explanation":"In Part 3, you used gatsby-plugin-image to add static images to your home page. Now that you‚Äôve worked a bit more with Gatsby‚Äôs data layer, **it‚Äôs time to revisit gatsby-plugin-image**. This time, you‚Äôll learn how to add dynamic images to your site.\n\nIn this part of the Tutorial, you‚Äôll use the dynamic GatsbyImage component to add hero images to each of your blog posts.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- **Use the GatsbyImage component to create images dynamically from data**.\n\n## What‚Äôs the difference between GatsbyImage and StaticImage?\n\nBack in Part 3 of the Tutorial, you learned about how to use the StaticImage component from gatsby-plugin-image.\n\nHow do you know whether to use the StaticImage component or the GatsbyImage component? The decision ultimately comes down to whether or not your image source is going to be the same every time the component renders.\n\n**The StaticImage component is for static image sources, like a hard-coded file path or remote URL**. In other words, the source for your image is always going to be the same every time the component renders.\n\n**The GatsbyImage component is for dynamic image sources, like if the image source gets passed in as a prop**.\n\n\nIn this part of the Tutorial, **you‚Äôll add a hero image to your blog post page template**. You‚Äôll **also add some frontmatter data to your blog post .mdx files to specify which image to use for each post**. Since the image source you‚Äôll load in the page template will **change for each blog post, you‚Äôll use the GatsbyImage component**.\n\n\n##¬†Add hero images to blog post frontmatter\n\n**Many blog sites include a hero image at the top of each post. These images are usually large, high-quality photos that are meant to grab the reader‚Äôs attention and make them want to stay on the page longer.**\n\nThe steps below will help you find and download some photos for your hero images and add them to the frontmatter for each of your blog posts.\n\n**Start by organizing the blog directory with all your MDX posts.** \n**First, create a new subdirectory in your blog folder for each post**.\n**Then, rename each of your .mdx files to index.mdx** (to prevent the routes from ending up with a duplicated path parameter, like blog/my-post/my-post/).\nFor example, a post at blog/my-first-post.mdx would move to blog/my-first-post/index.mdx. Similarly, a post at blog/another-post.mdx would move to blog/another-post/index.mdx.\n> **Note**: After you move or rename your .mdx files, you‚Äôll need to stop and restart your local development server for your changes to be picked up.\n\n![gatsbyjs-reorganize-blog-directory](https://codersnack.com/assets/images/gatsbyjs-reorganize-blog-directory.png)\n\n\n**Use a website like [Unsplash](https://unsplash.com/) to find some pretty, freely usable images. For best results, choose photos with a *landscape* (horizontal) orientation, since those will fit on your screen more easily.**\n\n\n**When you‚Äôve found a photo that you like, download it and add it to subdirectory for one of your blog posts**. Continue downloading photos until you have a different hero image for each post.\n\n![gatsbyjs-folder-structure-with-images](https://codersnack.com/assets/images/gatsbyjs-folder-structure-with-images.png)\n\n> **Pro Tip**: Sometimes, the images you download from the internet can be a little **too high quality**. If you know your site will only ever render an image at 1000 pixels wide, there‚Äôs no point in having a source image that‚Äôs 5000 pixels wide. All those extra pixels mean extra work to process and optimize your images, which **can slow down build times**.\nAs a general guideline, **it‚Äôs a good idea to preoptimize your image files by resizing them to be no more than twice the maximum size they‚Äôll be rendered at.** For example, if your layout is 600 pixels wide, then the highest resolution image you will need is 1200 pixels (to account for 2x pixel density).\nFor more detailed information, refer to the doc on [Preoptimizing Your Images](https://www.gatsbyjs.com/docs/preoptimizing-images/).\n\n**Next, add some additional frontmatter fields to each of your blog posts**:\n- hero_image: the relative path to the hero image file for that post\n- hero_image_alt: a short description of the image, to be used as alternative text for screen readers or in case the image doesn‚Äôt load correctly\n- hero_image_credit_text: the text to display to give the photographer credit for the hero image\n- hero_image_credit_link: a link to the page where your hero image was downloaded from \n\n*blog/my-first-post/index.mdx*\n```\n---\ntitle: \"My First Post\"\ndate: \"2021-07-23\"\nhero_image: \"./christopher-ayme-ocZ-_Y7-Ptg-unsplash.jpg\"\nhero_image_alt: \"A gray pitbull relaxing on the sidewalk with its tongue hanging out\"\nhero_image_credit_text: \"Christopher Ayme\"\nhero_image_credit_link: \"https://unsplash.com/photos/ocZ-_Y7-Ptg\"\n---\n...\n```\n*blog/another-post/index.mdx*\nCopyblog/another-post/index.mdx: copy code to clipboard\n```\n---\ntitle: \"Another Post\"\ndate: \"2021-07-24\"\nhero_image: \"./anthony-duran-eLUBGqKGdE4-unsplash.jpg\"\nhero_image_alt: \"A grey and white pitbull wading happily in a pool\"\nhero_image_credit_text: \"Anthony Duran\"\nhero_image_credit_link: \"https://unsplash.com/photos/eLUBGqKGdE4\"\n---\n...\n```\n*blog/yet-another-post/index.mdx*\n```\n---\ntitle: \"Yet Another Post\"\ndate: \"2021-07-25\"\nhero_image: \"./jane-almon-7rriIaBH6JY-unsplash.jpg\"\nhero_image_credit_text: \"Jane Almon\"\nhero_image_credit_link: \"https://unsplash.com/photos/7rriIaBH6JY\"\n---\n...\n```\nNow that your hero images are set up, it‚Äôs time to connect them to the data layer so you can pull them into your blog post page template.\n\n\n## Install and configure gatsby-transformer-sharp\n\n**In order to use the GatsbyImage component, you‚Äôll need to add the *gatsby-transformer-sharp transformer plugin* to your site.**\n\nWhen Gatsby adds nodes to the data layer at build time, the **gatsby-transformer-sharp plugin looks for any File nodes that end with an image extension (like .png or .jpg) and creates an *ImageSharp* node for that file**.\n\n\n![gatsbyjs-data-layer-with-imagesharp-nodes](https://codersnack.com/assets/images/gatsbyjs-data-layer-with-imagesharp-nodes.png)\n\nIn the terminal, run the following command to install gatsby-transformer-sharp:\n\n```\nnpm install gatsby-transformer-sharp\n```\nAdd gatsby-transformer-sharp to the plugins array in your gatsby-config.js file.\n\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    // ...existing plugins\n    \"gatsby-transformer-sharp\",\n  ],\n}\n```\n\nSince you‚Äôve added gatsby-transformer-sharp to your site, you‚Äôll need to **restart your local development server** to see the changes in GraphiQL. You‚Äôll take a closer look at GraphiQL in the next step.\n\n\n### Render hero image in the blog post page template\n\nWith all the necessary tools in place, you‚Äôre ready to add your hero image to your blog post page template.\n\n### Task: Use GraphiQL to build the query\n\nFirst, you‚Äôll use GraphiQL to add the hero image frontmatter fields to the GraphQL query for your blog post page template.\n\nOpen GraphiQL by going to localhost:8000/___graphql in a web browser. Start by copying your existing blog post page query into the GraphiQL Query Editor pane. Run it once to make sure everything is working correctly.\n> Note: You‚Äôll need to set up an object in the Query Variables pane with an id that matches one of your posts. Refer to Part 6 section on query variables if you need a refresher on how to set that up.\n\n```\nquery ($id: String) {\n  mdx(id: {eq: $id}) {\n    frontmatter {\n      title\n      date(formatString: \"MMMM D, YYYY\")\n    }\n    body\n  }\n}\n```\n\n```\n{\n  \"data\": {\n    \"mdx\": {\n      \"frontmatter\": {\n        \"title\": \"My First Post\",\n        \"date\": \"July 23, 2021\",\n      },\n      \"body\": \"...\"\n    }\n  },\n  \"extensions\": {}\n}\n```\n\n**In the Explorer pane, check the boxes for the *hero_image_alt*, *hero_image_credit_link*, and *hero_image_credit_text* fields**. When you run your query, you should get back a response something like the JSON object below.\n> *Note*: Remember to scroll down to the blue frontmatter field, which is lower than the purple frontmatter: argument.\n\n```\nquery ($id: String) {\n  mdx(id: {eq: $id}) {\n    frontmatter {\n      title\n      date(formatString: \"MMMM D, YYYY\")\n      hero_image_alt\n      hero_image_credit_link\n      hero_image_credit_text\n    }\n    body\n  }\n}\n```\n```\n{\n  \"data\": {\n    \"mdx\": {\n      \"frontmatter\": {\n        \"title\": \"My First Post\",\n        \"date\": \"July 23, 2021\",\n        \"hero_image_alt\": \"A gray pitbull relaxing on the sidewalk with its tongue hanging out\",\n        \"hero_image_credit_link\": \"https://unsplash.com/photos/ocZ-_Y7-Ptg\",\n        \"hero_image_credit_text\": \"Christopher Ayme\"\n      },\n      \"body\": \"...\"\n    }\n  },\n  \"extensions\": {}\n}\n```\n**Adding the hero_image field itself is a bit more involved. Within the hero_image field, toggle the childImageSharp field, and then check the box for the *gatsbyImageData* field**. Now your query should look like this:\n\n```\nquery ($id: String) {\n  mdx(id: {eq: $id}) {\n    frontmatter {\n      title\n      date(formatString: \"MMMM D, YYYY\")\n      hero_image_alt\n      hero_image_credit_link\n      hero_image_credit_text\n      hero_image {\n        childImageSharp {\n          gatsbyImageData\n        }\n      }\n    }\n    body\n  }\n}\n```\n> **Pro Tip**: How does GraphiQL know to add extra fields to the hero_image frontmatter field?\n\nWhen Gatsby builds your site, it creates a GraphQL schema that describes the different types of data in the data layer. **As Gatsby builds that schema, it tries to guess the type of data for each field. This process is called *schema inference*.**\n\n**Gatsby can tell that the hero_image field from your MDX frontmatter matches a File node, so it lets you query the File fields for that node**. Similarly, ***gatsby-transformer-sharp* can tell that the file is an image, so it also lets you query the ImageSharp fields for that node.**\n\nRun your query to see what data you get back in the response. It should mostly look like the response you got back before, but this time with an extra hero_image object:\n```\n{\n  \"data\": {\n    \"mdx\": {\n      \"frontmatter\": {\n        // ...\n        \"hero_image\": {\n          \"childImageSharp\": [\n            {\n              \"gatsbyImageData\": {\n                \"layout\": \"constrained\",\n                \"backgroundColor\": \"#282828\",\n                \"images\": {\n                  \"fallback\": {\n                    \"src\": \"/static/402ec135e08c3b799c16c08a82ae2dd8/68193/christopher-ayme-ocZ-_Y7-Ptg-unsplash.jpg\",\n                    \"srcSet\": \"/static/402ec135e08c3b799c16c08a82ae2dd8/86d57/christopher-ayme-ocZ-_Y7-Ptg-unsplash.jpg 919w,\\n/static/402ec135e08c3b799c16c08a82ae2dd8/075d8/christopher-ayme-ocZ-_Y7-Ptg-unsplash.jpg 1839w,\\n/static/402ec135e08c3b799c16c08a82ae2dd8/68193/christopher-ayme-ocZ-_Y7-Ptg-unsplash.jpg 3677w\",\n                    \"sizes\": \"(min-width: 3677px) 3677px, 100vw\"\n                  },\n                  \"sources\": [\n                    {\n                      \"srcSet\": \"/static/402ec135e08c3b799c16c08a82ae2dd8/6b4aa/christopher-ayme-ocZ-_Y7-Ptg-unsplash.webp 919w,\\n/static/402ec135e08c3b799c16c08a82ae2dd8/0fe0b/christopher-ayme-ocZ-_Y7-Ptg-unsplash.webp 1839w,\\n/static/402ec135e08c3b799c16c08a82ae2dd8/5d6d7/christopher-ayme-ocZ-_Y7-Ptg-unsplash.webp 3677w\",\n                      \"type\": \"image/webp\",\n                      \"sizes\": \"(min-width: 3677px) 3677px, 100vw\"\n                    }\n                  ]\n                },\n                \"width\": 3677,\n                \"height\": 2456\n              }\n            }\n          ]\n        }\n      },\n      \"body\": \"...\"\n    }\n  },\n  \"extensions\": {}\n}\n```\nIf you take a closer look at the **gatsbyImageData object on the hero_image.childImageSharp field, you‚Äôll see that it contains a bunch of information about the hero image for that post: dimensions, file paths for the images at different sizes, fallback images to use as a placeholder while the image loads**. All this data gets **calculated by gatsby-plugin-sharp at build time**. The gatsbyImageData object in your response has the same structure that the GatsbyImage component needs to render an image.\n\n> **Note**: You might have noticed that the **gatsbyImageData field in GraphiQL accepts several arguments, like aspectRatio, formats, or width.** You can use these arguments to pass in extra data about how you want the Sharp image processing library to create your optimized images.\nThese options are equivalent to the ones you would pass into the StaticImage component as props.\nFor more information, see the \ngatsby-plugin-image\nReference Guide.\n\n\n### Task: Add hero image using GatsbyImage component\n\nOnce you have your GraphQL query set up, you can add it to your blog post page template.\n\nReplace your existing page query with the query you built in GraphiQL that includes the hero image frontmatter fields.\n\n*src/pages/blog/{mdx.slug}.js*\n```\n// imports\nconst BlogPost = ({ data }) => {\n  return (\n    // ...\n  )\n}\nexport const query = graphql`\n  query($id: String) {\n    mdx(id: {eq: $id}) {\n      body\n      frontmatter {\n        title\n        date(formatString: \"MMMM DD, YYYY\")\n        hero_image_alt\n        hero_image_credit_link\n        hero_image_credit_text\n        hero_image {\n          childImageSharp {\n            gatsbyImageData\n          }\n        }\n      }\n    }\n  }\n`\nexport default BlogPost\n```\nImport the GatsbyImage component and the getImage helper function from the gatsby-plugin-image package.\n\n*src/pages/blog/{mdx.slug}.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport { GatsbyImage, getImage } from 'gatsby-plugin-image'\nimport Layout from '../../components/layout'\n// ...\n```\nUse the getImage helper function to get back the gatsbyImageData object from the hero_image field.\n*src/pages/blog/{mdx.slug}.js*\n```\n// imports\nconst BlogPost = ({ data }) => {\n  const image = getImage(data.mdx.frontmatter.hero_image)\n  return (\n    // ...\n  )\n}\n// ...\n```\n> *Note*: **getImage** is a helper function that takes in a File node or an ImageSharp node and returns the gatsbyImageData object for that node. You can use it to keep your code a little cleaner and easier to read.\n**Without the getImage helper function, you‚Äôd have to type out data.mdx.frontmatter.hero_image.childImageSharp.gatsbyImageData** (which is longer, but gives you back the same data).\n\nUse the **GatsbyImage** component from gatsby-plugin-image to render the hero image data. You should pass GatsbyImage two **props**:\n\n- image: the gatsbyImageData object for your hero_image field\n- alt: the alternative text for your image, from the hero_image_alt field\n\n*src/pages/blog/{mdx.slug}.js*\n```\nreturn (\n  <Layout pageTitle={data.mdx.frontmatter.title}>\n    <p>Posted: {data.mdx.frontmatter.date}</p>\n    <GatsbyImage\n      image={image}\n      alt={data.mdx.frontmatter.hero_image_alt}\n    />\n    <MDXRenderer>\n      {data.mdx.body}\n    </MDXRenderer>\n  </Layout>\n)\n```\nNow, when you visit each of your blog post pages, you should see the corresponding hero image rendered before the body of your post!\n\n\n###  Task: Add image credit after hero image\n\nIt‚Äôs important to **give credit to people whose work you use in your own site.** The last piece of including hero images to your site is to add a paragraph to give credit to the photographer.\n\n> **Pro Tip**: Since the credit link goes to an external page (in other words, one that‚Äôs not part of your site), you can use the <a> HTML tag instead of the Gatsby Link component.\nRemember, Gatsby‚Äôs Link component only gives performance benefits for internal links to other pages within your site.\n\n*src/pages/blog/{mdx.slug}.js*\n```\n// imports\nconst BlogPost = ({ data }) => {\n  const image = getImage(data.mdx.frontmatter.hero_image)\n  return (\n    <Layout pageTitle={data.mdx.frontmatter.title}>\n      <p>{data.mdx.frontmatter.date}</p>\n      <GatsbyImage\n        image={image}\n        alt={data.mdx.frontmatter.hero_image_alt}\n      />\n      <p>\n        Photo Credit:{\" \"}\n        <a href={data.mdx.frontmatter.hero_image_credit_link}>\n          {data.mdx.frontmatter.hero_image_credit_text}\n        </a>\n      </p>\n      <MDXRenderer>\n        {data.mdx.body}\n      </MDXRenderer>\n    </Layout>\n  )\n  }\nexport const query = graphql`\n  ...\n`\nexport default BlogPost\n```\n> **Syntax Hint**: You might have noticed that there‚Äôs a {\" \"} after the ‚ÄúPhoto Credit:‚Äù text <p> tag. That‚Äôs to make sure that a space gets rendered between the colon (:) and the link text.\nTry removing the {\" \"} and see what happens. The paragraph text should end up being ‚ÄúPhoto Credit:Author‚Äù.\n\n\n###¬†Key takeaways\n\n- Use the **StaticImage** component if your component **always renders the same image** (from a relative path or a remote URL).\n- Use the **GatsbyImage** component if the **image source changes for different instances of your component** (like if it gets passed in as a prop).\n","references":"- [Add Dynamic Images from Data](https://www.gatsbyjs.com/docs/tutorial/part-7/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-add-dynamic-images","weblink":"https://codersnack.com/gatsbyjs-add-dynamic-images","featured_image_preview":{"id":141,"name":"gatsbyjs-logo.png","hash":"59dd53f74266498dac4363ae55c04522","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/59dd53f74266498dac4363ae55c04522.png","provider":"local","provider_metadata":null,"created_at":"2021-11-04T18:20:15.183Z","updated_at":"2021-11-04T18:20:15.183Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - add dynamic images","created_at":"2021-11-04T18:21:14.819Z","updated_at":"2021-11-04T18:21:14.821Z"},{"id":104,"codersnack":{"id":106,"header":"GatsbyJS - Sourcing Content from JSON or YAML","created_at":"2021-11-04T22:01:09.066Z","updated_at":"2021-11-04T22:01:09.066Z","explanation":"As you work with Gatsby, **you might want to source data from a JSON or YAML file directly into a page or component**. This guide will cover approaches for those techniques, as well as architecting a Gatsby site from a YAML file.\n\n## Directly import data with YAML\n\nThis section starts with YAML data sourcing. If you want to see how to do it using JSON instead, jump to the next section.\n\n**Add the YAML content**\nIn your Gatsby project folder, **create a directory called *content*** and inside, add a file called **My-YAML-Content.yaml** with the following content:\n\n*content/My-YAML-Content.yaml*\n```\ntitle: YAML content used at build time with Gatsby\ncontent:\n  - item:\n      Cupcake ipsum dolor. Sit amet marshmallow topping cheesecake muffin. Halvah\n      croissant candy canes bonbon candy. Apple pie jelly beans topping carrot cake\n      danish tart cake cheesecake. Muffin danish chocolate souffl√© pastry icing bonbon\n      oat cake. Powder cake jujubes oat cake. Lemon drops tootsie roll marshmallow halvah\n      carrot cake.\n  - item:\n      Doggo ipsum borkdrive much ruin diet you are doing me the shock the neighborhood pupper doggorino length boy many pats, boofers heckin shooberino wrinkler.\n      Very good spot very jealous pupper very hand that feed shibe smol, shoob.\n      Long bois pupper doggo you are doin me a concern big ol yapper, smol boof most angery pupper I have ever seen puggorino.\n      Mlem blep wow very biscit dat tungg tho wow very biscit, thicc ur givin me a spook.\n      Many pats heckin you are doing me the shock corgo ur givin me a spook very hand that feed shibe shooberino, big ol pupper doge pats borkdrive.\n      Such treat what a nice floof super chub such treat, smol thicc.\n      Puggorino very good spot most angery pupper I have ever seen you are doing me the shock big ol pupper porgo corgo shoober, heckin good boys lotsa pats noodle horse very taste wow thicc.\n      What a nice floof long doggo blep length boy borking doggo, much ruin diet floofs borkf.\n  - item: 192.33\n  - item: 111111\n```\n**Import YAML into the page component**\nNow that you have something you want to show, the only thing missing is to create a page that will consume the data.\n\n**Add a new file called *yml-at-buildtime.js*** inside the pages folder, with the following code:\n\n*src/pages/yml-at-buildtime.js*\n```\nimport React from \"react\"\nimport YAMLData from \"../../content/My-YAML-Content.yaml\"\nconst YAMLbuildtime = () => (\n  <div style={{ maxWidth: `960px`, margin: `1.45rem` }}>\n    <h1>{YAMLData.title}</h1>\n    <ul>\n      {YAMLData.content.map((data, index) => {\n        return <li key={`content_item_${index}`}>{data.item}</li>\n      })}\n    </ul>\n  </div>\n)\nexport default YAMLbuildtime\n```\n\n**The above code imports YAML source data as an array**, iterates over it with the Array.map method, and renders the data-filled markup through a functional React component.\n\n\n## Directly import data with JSON\n\nIn addition to (or instead of) sourcing from YAML, you can use JSON as a data source in a Gatsby site.\n\n**Add the JSON content**\nIn your Gatsby project folder, **create a directory named *content*** if it doesn‚Äôt exist, and then add a new file inside called My-JSON-Content.json with the following content:\n\n*content/My-JSON-Content.json*\n```\n{\n  \"title\": \"JSON content used at build time with Gatsby\",\n  \"content\": [\n    {\n      \"item\": \"Cupcake ipsum dolor. Sit amet marshmallow topping cheesecake muffin. Halvah croissant candy canes bonbon candy. Apple pie jelly beans topping carrot cake danish tart cake cheesecake. Muffin danish chocolate souffl√© pastry icing bonbon oat cake. Powder cake jujubes oat cake. Lemon drops tootsie roll marshmallow halvah carrot cake.\"\n    },\n    {\n      \"item\": \"Doggo ipsum borkdrive much ruin diet you are doing me the shock the neighborhood pupper doggorino length boy many pats, boofers heckin shooberino wrinkler. Very good spot very jealous pupper very hand that feed shibe smol, shoob. Long bois pupper doggo you are doin me a concern big ol yapper, smol boof most angery pupper I have ever seen puggorino. Mlem blep wow very biscit dat tungg tho wow very biscit, thicc ur givin me a spook. Many pats heckin you are doing me the shock corgo ur givin me a spook very hand that feed shibe shooberino, big ol pupper doge pats borkdrive. Such treat what a nice floof super chub such treat, smol thicc. Puggorino very good spot most angery pupper I have ever seen you are doing me the shock big ol pupper porgo corgo shoober, heckin good boys lotsa pats noodle horse very taste wow thicc. What a nice floof long doggo blep length boy borking doggo, much ruin diet floofs borkf.\"\n    },\n    {\n      \"item\": 192.33\n    },\n    {\n      \"item\": 111111\n    }\n  ]\n}\n```\n**Import JSON into the page component**\nNow that you have JSON data that needs to be shown, all that‚Äôs missing is a page to consume it.\n\nAdd **a new file called *json-at-buildtime.js*** inside the pages folder with the following code:\n\n*src/pages/json-at-buildtime.js*\n```\nimport React from \"react\"\nimport JSONData from \"../../content/My-JSON-Content.json\"\nconst JSONbuildtime = () => (\n  <div style={{ maxWidth: `960px`, margin: `1.45rem` }}>\n    <h1>{JSONData.title}</h1>\n    <ul>\n      {JSONData.content.map((data, index) => {\n        return <li key={`content_item_${index}`}>{data.item}</li>\n      })}\n    </ul>\n  </div>\n)\nexport default JSONbuildtime\n```\n\nSimilar to the YAML example above, this code snippet shows how to import a JSON file for sourcing data. When imported, the data can be iterated upon with the Array.map method and rendered in a React component.\n\nOut of the box and without any extra configuration, the page will show content sourced from a JSON file.\n\n","references":"- [Sourcing Content from JSON or YAML](https://www.gatsbyjs.com/docs/how-to/sourcing-data/sourcing-from-json-or-yaml/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-sourcing-content-yaml-json","weblink":"https://codersnack.com/gatsbyjs-sourcing-content-yaml-json","featured_image_preview":{"id":142,"name":"gatsbyjs-logo.png","hash":"157c577488ba447bb03ad0db12426913","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/157c577488ba447bb03ad0db12426913.png","provider":"local","provider_metadata":null,"created_at":"2021-11-04T22:01:09.088Z","updated_at":"2021-11-04T22:01:09.088Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - source content from json or yaml","created_at":"2021-11-04T22:01:42.375Z","updated_at":"2021-11-04T22:01:42.378Z"},{"id":105,"codersnack":{"id":107,"header":"GatsbyJS - Creating Tags Pages for Blog Posts","created_at":"2021-11-08T19:13:34.957Z","updated_at":"2021-11-08T19:13:34.957Z","explanation":"Creating tag pages for your blog post is a way to let visitors browse related content.\n\nTo add tags to your blog posts, you will first want to have your site set up to turn your markdown pages into blog posts. To get your blog pages set up, see the tutorial on Gatsby‚Äôs data layer and Adding Markdown Pages.\n\nThe process will essentially look like this:\n\n- Add **tags to your markdown** files\n- Write a **query to get all tags** for your posts\n- Make a **tags page template** (for /tags/{tag})\n- Modify *gatsby-node.js* to render pages using that template\n- Make a **tags index page (/tags) that renders a list of all tags**\n- (optional) Render **tags inline** with your blog posts\n\n## Add tags to your markdown files\n\nYou add tags by **defining them in the frontmatter** of your Markdown file. The frontmatter is the area at the top surrounded by dashes that includes post data like the title and date.\n\n```\n---\ntitle: \"A Trip To the Zoo\"\n---\nI went to the zoo today. It was terrible.\n```\n**Fields can be strings, numbers, or arrays**. Since a post can usually have many tags, it makes sense to define it as an array. Here you add your new tags field:\n\n```\n---\ntitle: \"A Trip To the Zoo\"\ntags: [\"animals\", \"Chicago\", \"zoos\"]\n---\nI went to the zoo today. It was terrible.\n```\n\nIf gatsby develop is running, restart it so Gatsby can pick up the new fields.\n\n## Write a query to get all tags for your posts\n\nNow, these fields are available in the data layer. To use field data, **query it using graphql**. All fields are available to query inside frontmatter\n\nTry running the following query in GraphiQL (http://localhost:8000/___graphql):\n\n```\n{\n  allMdx {\n    group(field: frontmatter___tags) {\n      tag: fieldValue\n      totalCount\n    }\n  }\n}\n```\n\n**The above query groups posts by tags, and returns each tag with the number of posts as totalCount**. As an addition, you could extract some post data in each group if you need to. To keep this tutorial small, you‚Äôre only using the tag name in your tag pages. Make the tag page template now:\n\n##¬†Make a tags page template (for /tags/{tag})\n\nIf you followed the How-To Guide for Adding Markdown Pages, then this process should sound familiar: Make a tag page template, then use it in **createPages** in *gatsby-node.js* to generate individual pages for the tags in your posts.\n\nFirst, you‚Äôll add a tags template at src/templates/tags.js:\n\n*src/templates/tags.js*\n```\nimport React from \"react\"\nimport PropTypes from \"prop-types\"\n// Components\nimport { Link, graphql } from \"gatsby\"\nconst Tags = ({ pageContext, data }) => {\n  const { tag } = pageContext\n  const { edges, totalCount } = data.allMarkdownRemark\n  const tagHeader = `${totalCount} post${\n    totalCount === 1 ? \"\" : \"s\"\n  } tagged with \"${tag}\"`\n  return (\n    <div>\n      <h1>{tagHeader}</h1>\n      <ul>\n        {edges.map(({ node }) => {\n          const { slug } = node.fields\n          const { title } = node.frontmatter\n          return (\n            <li key={slug}>\n              <Link to={slug}>{title}</Link>\n            </li>\n          )\n        })}\n      </ul>\n      {/*\n              This links to a page that does not yet exist.\n              You'll come back to it!\n            */}\n      <Link to=\"/tags\">All tags</Link>\n    </div>\n  )\n}\nTags.propTypes = {\n  pageContext: PropTypes.shape({\n    tag: PropTypes.string.isRequired,\n  }),\n  data: PropTypes.shape({\n    allMarkdownRemark: PropTypes.shape({\n      totalCount: PropTypes.number.isRequired,\n      edges: PropTypes.arrayOf(\n        PropTypes.shape({\n          node: PropTypes.shape({\n            frontmatter: PropTypes.shape({\n              title: PropTypes.string.isRequired,\n            }),\n            fields: PropTypes.shape({\n              slug: PropTypes.string.isRequired,\n            }),\n          }),\n        }).isRequired\n      ),\n    }),\n  }),\n}\nexport default Tags\nexport const pageQuery = graphql`\n  query($tag: String) {\n    allMarkdownRemark(\n      limit: 2000\n      sort: { fields: [frontmatter___date], order: DESC }\n      filter: { frontmatter: { tags: { in: [$tag] } } }\n    ) {\n      totalCount\n      edges {\n        node {\n          fields {\n            slug\n          }\n          frontmatter {\n            title\n          }\n        }\n      }\n    }\n  }\n`\n```\n\n> *Note*: propTypes are included in this example to help you ensure you‚Äôre getting all the data you need in the component, and to help serve as a guide while destructuring / using those props.\n\n##¬†Modify gatsby-node.js to render pages using that template\n\nNow you‚Äôve got a template. Great! Assuming you followed the How-To Guide for Adding Markdown Pages and provide a sample createPages that generates post pages as well as tag pages. In the site‚Äôs **gatsby-node.js file, include lodash** (const _ = require('lodash')) and then make sure your createPages looks something like this:\n\n*gatsby-node.js*\n```\nconst path = require(\"path\")\nconst _ = require(\"lodash\")\nexports.createPages = async ({ actions, graphql, reporter }) => {\n  const { createPage } = actions\n  const blogPostTemplate = path.resolve(\"src/templates/blog.js\")\n  const tagTemplate = path.resolve(\"src/templates/tags.js\")\n  const result = await graphql(`\n    {\n      postsRemark: allMarkdownRemark(\n        sort: { order: DESC, fields: [frontmatter___date] }\n        limit: 2000\n      ) {\n        edges {\n          node {\n            fields {\n              slug\n            }\n            frontmatter {\n              tags\n            }\n          }\n        }\n      }\n      tagsGroup: allMarkdownRemark(limit: 2000) {\n        group(field: frontmatter___tags) {\n          fieldValue\n        }\n      }\n    }\n  `)\n  // handle errors\n  if (result.errors) {\n    reporter.panicOnBuild(`Error while running GraphQL query.`)\n    return\n  }\n  const posts = result.data.postsRemark.edges\n  // Create post detail pages\n  posts.forEach(({ node }) => {\n    createPage({\n      path: node.fields.slug,\n      component: blogPostTemplate,\n    })\n  })\n  // Extract tag data from query\n  const tags = result.data.tagsGroup.group\n  // Make tag pages\n  tags.forEach(tag => {\n    createPage({\n      path: `/tags/${_.kebabCase(tag.fieldValue)}/`,\n      component: tagTemplate,\n      context: {\n        tag: tag.fieldValue,\n      },\n    })\n  })\n}\n```\n\n> **Some notes**:\n- Your GraphQL query only looks for data you need to generate these pages. Anything else can be queried again later (and, if you notice, you do this above in the tags template for the post title).\n- You have referenced two allMarkdownRemark fields in your query. **To avoid naming collisions you must alias one of them**. You alias both to make your code more human-readable.\n- While making the tag pages, note that you pass **tag.name** through in the context. This is the value that gets used in the TagPage query to limit your search to only posts tagged with the tag in the URL.\n\n##¬†Make a tags index page (/tags) that renders a list of all tags\n\nYour */tags* page will list out all tags, followed by the number of posts with that tag. You can get the data with the first query you wrote earlier, that groups posts by tags:\n\n*src/pages/tags.js*\n```\nimport React from \"react\"\nimport PropTypes from \"prop-types\"\n// Utilities\nimport kebabCase from \"lodash/kebabCase\"\n// Components\nimport { Helmet } from \"react-helmet\"\nimport { Link, graphql } from \"gatsby\"\nconst TagsPage = ({\n  data: {\n    allMarkdownRemark: { group },\n    site: {\n      siteMetadata: { title },\n    },\n  },\n}) => (\n  <div>\n    <Helmet title={title} />\n    <div>\n      <h1>Tags</h1>\n      <ul>\n        {group.map(tag => (\n          <li key={tag.fieldValue}>\n            <Link to={`/tags/${kebabCase(tag.fieldValue)}/`}>\n              {tag.fieldValue} ({tag.totalCount})\n            </Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  </div>\n)\nTagsPage.propTypes = {\n  data: PropTypes.shape({\n    allMarkdownRemark: PropTypes.shape({\n      group: PropTypes.arrayOf(\n        PropTypes.shape({\n          fieldValue: PropTypes.string.isRequired,\n          totalCount: PropTypes.number.isRequired,\n        }).isRequired\n      ),\n    }),\n    site: PropTypes.shape({\n      siteMetadata: PropTypes.shape({\n        title: PropTypes.string.isRequired,\n      }),\n    }),\n  }),\n}\nexport default TagsPage\nexport const pageQuery = graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    allMarkdownRemark(limit: 2000) {\n      group(field: frontmatter___tags) {\n        fieldValue\n        totalCount\n      }\n    }\n  }\n`\n```\n##¬†(optional) Render tags inline with your blog posts\n\nThe home stretch! Anywhere else you‚Äôd like to render your tags, add them to the frontmatter section of your graphql query and access them in your component like any other prop.","references":"- [Creating Tags Pages for Blog Posts](https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-creating-tags-pages","weblink":"https://codersnack.com/gatsbyjs-creating-tags-pages","featured_image_preview":{"id":143,"name":"gatsbyjs-logo.png","hash":"04b6076fccad4898999819e62cdc4780","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/04b6076fccad4898999819e62cdc4780.png","provider":"local","provider_metadata":null,"created_at":"2021-11-08T19:13:34.977Z","updated_at":"2021-11-08T19:13:34.977Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - creating tags pages","created_at":"2021-11-08T19:13:56.673Z","updated_at":"2021-11-08T19:13:56.676Z"}]