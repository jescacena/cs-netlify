[{"id":97,"codersnack":{"id":98,"header":"GatsbyJS - Introduction","created_at":"2021-11-03T17:19:05.447Z","updated_at":"2021-11-03T17:46:52.760Z","explanation":"\n## What is Gatsby?\n\nIt's **another static site generator** like Hugo, Jekyll and so on. So what makes it special? Why are we talking specifically about it?\n\nGatsby can be used to build static sites that are **Progressive Web Apps**, follow the latest web standards, and are **optimized to be highly performant.** It makes use of the latest and popular technologies including **ReactJS**, Webpack, **GraphQL**, modern ES6+ JavaScript and CSS.\n\n![ReactJS + GraphQL + Webpack = i'm loving it](https://codersnack.com/assets/images/gatsbyjs-reactjs-graphql-webpack.png)\n*ReactJS + GraphQL + Webpack = i'm loving it*\n\nThis means **a lot of developers can jump in without much of a learning curve** as they already know or have at least used one piece of this tech stack Gatsby is built on.\n\n## Approach to development\n\nOn one side, we have users expecting an app-like smooth experience on the web. The other side is **developers, used to sites having pages with each being HTML files** or maybe using some templating ‚Äî at the very base ‚Äî sites as pages with internal linking.\n\nIf you‚Äôre getting started with any of the latest frameworks, let‚Äôs take the case of React. You could have an app up and running with minimal configuration with *create-react-app*. But if you take a look at the project structure it may not make much sense to a newbie or even some developers coming in from other tech stacks. *The pattern is pretty different from what you‚Äôve ever seen before.* It‚Äôs because without additional setup they aim at building Single-Page Applications, SPAs. To add routing, pages or optimizing for SEO, it will require more tools and configuration.\n\nThat doesn‚Äôt seem very convenient when you want static sites, does it? So here we have **Gatsby, optimized for this specific use case**. This could be **more intuitive for developers**, as there are pages created from components that follow the root idea that sites are pages with internal linking.\n\n## Webpack bundling and latest tooling\n\nWebpack creates optimized, minified bundles of HTML, JavaScript, and CSS. When it‚Äôs pre-configured with Babel and more plugins, it allows you to use the latest ES6+ JavaScript and GraphQL.\n\n*Icing on the cake*: we‚Äôve got hot reloading and code splitting built-in, giving a better development experience and better site performance. This is aimed at making the developer write minimal tooling configuration and focus more on the actual site development.\n\n## Gatsby plugins, starters and React packages\n\nYou can use any of the packages you‚Äôve already been using with NPM, particularly the React ones as it‚Äôs built on the same thing. But that‚Äôs not all: there‚Äôs a **large number of ever-growing plugins, starters, and transformers by the Gatsby community**. You almost never come to the point where you actually have to build on your own tool or module, the community already offers a huge number to suit every need.\n\nUsing these, Gatsby **can be extended with additional functionality**. For instance, a couple of examples include *responsive images*, *offline functionality*, *source data from CMS* and *data markup formats*, adding third-party services (Google analytics etc), and so on.\n\n## Responsive Images\n\nResizing images for responsiveness on different devices, lazy-loading, using srcsets and picture‚Ä¶Already sounds tedious when it is to be done manually.\n\n![Different versions of the same image for responsiveness](https://codersnack.com/assets/images/gatsbyjs-responsive-images.png)\n*Different versions of the same image for responsiveness*\n\nAlthough it is a requirement for performance and app-like optimized interfaces these days, we don‚Äôt see many tools that we can directly jump into and use.\n\nMeanwhile, in Gatsby with just a plugin, particularly the **gatsby-plugin-sharp**, you can directly generate **fluid images, add filters, change formats**, blur up on load and a lot more. This saves a lot of work and time manually resizing images and writing explicit boilerplate code for responsive images. It also gives you way better performance along with a smoother user experience.\n\n## App-like experience\n\nWith the performance boost and features to add to the **smoothness of the user experience**, Gatsby aims at a full app-like experience borrowing from full PWAs. There are **no reloads between pages** when using **gatsby-link** instead of hyperlinks, and the app still appears smooth and performant thanks to **lazy-loading images and code-splitting**.\n\nFor sites following standards that you also want to be performant, we‚Äôve got tons of things to do and guides to follow: minification and bundling, browser caching and async loading scripts or files, and so on. When working with a framework like React, you have more things to worry about even though it solves a couple of problems: **code-splitting, SEO, routing if required, responsive images**, and the list goes on.\n\n**Gatsby aims to solve all these problems**, with less time spent on tooling, configuration, and the environment and more time to actually design and develop the site.\n\n## Plugins\n\nGatsby was **built to be extensible and flexible ‚Äî using plugins is one way to make it so**. They can be directly installed and be used for a variety of functionality including making the site offline, adding Google analytics, adding support for inline SVGs, you name it ‚Äî the list is almost endless.\n\nOf the different types of Gatsby plugins, the **gatsby-source plugins in particular fetch data from a local or remote source and allow it to be usable via GraphQL**. These sources could be CMSs such as *Wordpress*, Drupal, Plone, *local markdown*, XML or such files, databases, APIs and *data formats as JSON*, CSV.\n\nThis implies that almost anything at all can be used as a source to work with Gatsby and generate static sites.\n\n***Note***: GraphQL is a query language for APIs that works on the philosophy of just asking for exactly what you require. Unlike REST APIs, you don‚Äôt look for endpoints to provide your data and process them from the structure that‚Äôs given from it, but rather ask for what you want and directly use this data. Read more about how it works and how to use it in their docs.\nAfter installation, some plugins can be used straight away by just listing them in *gatsby-config.js* and the others configured with an options object.\n\nGo check out the Gatsby plugin library, it‚Äôs already got quite a large number of plugins and more are being added still by the active community.\n\n## Starters\n\nThese are basically boilerplate Gatsby sites which help you kick-start development quickly depending on what kind of site it is. They help you directly get onto working on the development of a site, configuration and basic features you need already taken care of. Which means, less time on the tooling, more time for development.\n\nGatsby plugins often have their corresponding starters which show or serve a quick way to get started with using it. They also act as a reference covering all the features and showcase configurations of the plugin in use.\n\n[https://www.gatsbyjs.com/starters/](https://www.gatsbyjs.com/starters/)\n\n## Static Sites\n\nFirstly, let‚Äôs take a look at **how Gatsby works internally**. Unlike the SPAs that make API requests as you run the app, **Gatsby does all the data fetching, including data sourcing from local files, during build time**. All this data is then used to generate static HTML, JavaScript, and CSS files. This static rendering is what makes things work faster.\n\n![How GastbyJS works](https://codersnack.com/assets/images/gatsbyjs-how-it-works.png)\n*How GastbyJS works*\n\nThat was a lot about Gatsby, its ecosystem and how it helps you create amazing static sites. **But why would we want static sites? Doesn‚Äôt it sound like a step back from dynamic ones?**\n\n- They **do not require complex server setup with databases, maintenance, and don‚Äôt have any scaling issues**.\n- Data is **fully secure**. CMSs and APIs have private features but the data is still present in the server which can be exploited. Gatsby only takes the required data to display from the source and the private or secured data is not even present in the final build. Which is the safest it can possibly get.\n- Rather than relying on servers to generate pages dynamically, **pre-render all of them on build and use CDNs for a blazing fast** and smooth experience for users all around the globe.\n- Gatsby does static rendering. Which makes content available as HTML, and **search engine optimized, no long initial load time**.\n","references":"- [Why you should use GatsbyJS to build static sites](https://www.freecodecamp.org/news/why-you-should-use-gatsbyjs-to-build-static-sites-4f90eb6d1a7b/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-introduction","weblink":"https://codersnack.com/gatsbyjs-introduction","featured_image_preview":{"id":134,"name":"gatsbyjs-logo.png","hash":"88d8647b64d746bfa0e26e30739956a5","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/88d8647b64d746bfa0e26e30739956a5.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T17:19:05.459Z","updated_at":"2021-11-03T17:19:05.459Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"Gatsbyjs - Introduction","created_at":"2021-11-03T17:19:52.479Z","updated_at":"2021-11-03T17:19:52.483Z"},{"id":98,"codersnack":{"id":99,"header":"GatsbyJS - Use and Style React Components","created_at":"2021-11-03T20:02:39.083Z","updated_at":"2021-11-03T20:02:39.083Z","explanation":"To build out the basic page structure for your blog site, you‚Äôll need to know about React components and how Gatsby uses them.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Create page components to add new pages to your site.\n- Import and use a pre-built component from another package.\n- Create your own reusable ‚Äúbuilding block‚Äù component.\n- Use component props to change the way a component renders.\n- Use the children prop to create a wrapper component.\n \n## What is React?\n\n**React is the JavaScript library that Gatsby uses under the hood to create user interfaces (UIs)**. With React, you can **break down your UI into smaller, reusable pieces called components**.\n\nFor example, imagine the UI for an online store‚Äôs Products page:\n\n![gatsbyjs-ui-built-from-componentst](https://codersnack.com/assets/images/gatsbyjs-ui-built-from-components.png)\n\nTo build this page in React, you might have a ```<Navbar>``` component for the navigation menu, a ```<Sidebar>``` component for extra information displayed to the side of the main content, and a ```<ProductGrid>``` component to display all of the products for sale.\n\nYou can also create components from other components. For example, you might decide to break down the ```<ProductGrid>``` component into a list of multiple ```<ProductCard>``` components, which each display the details about a single product. This pattern is called composition, since your larger ```<ProductGrid>``` component is composed of smaller ```<ProductCard>``` components.\n\n##¬†What is a React component?\n\nUnder the hood, **a React component is a function that returns a React element**. A **React element is an object that React uses to render DOM elements**.\n\n**A component is a function that outputs a React component, written in JSX**.\n\nThe simplest way to write React elements is with JSX. JSX is a JavaScript syntax extension that describes the DOM structure for your component. It looks a bit like having HTML in your JavaScript files:\n\n```\nconst hello = <h1>Hello world!</h1>\n```\n\nSo a simple React component might look something like this:\n\n```\nconst Greeting = () => {\n  return (\n    <h1>Hello world!</h1>\n  )\n}\n```\n\n\n### Create a page component\n\nThere are two main types of components in a Gatsby site. The first type you‚Äôll create are page components. **A page component contains all the UI elements for a specific page of your site.**\n\nIn this section, you‚Äôll create two new page components: one for the Home page and one for an About page.\n\nThe Home Page content is in ```src/index.js```.\n\n### Task: Create a new page component for an About page\n\nNow that you‚Äôve updated the existing Home page, try creating a new page from scratch. Make an About page, so that you can tell people a little about yourself.\n\nCreate a new file: src/pages/about.js. Use the code below as a starting point for your About page. \n\n*src/pages/about.js*\n```\n// Step 1: Import React\nimport * as React from 'react'\n// Step 2: Define your component\nconst AboutPage = () => {\n  return (\n    <main>\n      <title>About Me</title>\n      <h1>About Me</h1>\n      <p>Hi there! I'm the proud creator of this site, which I built with Gatsby.</p>\n    </main>\n  )\n}\n// Step 3: Export your component\nexport default AboutPage\n```\n\n## Use the ```<Link>``` component\n\nSo far, your blog site has two separate pages (Home and About), but the only way to get from one page to the other is to update the URL manually. It would be nice to add links to make it easier to switch between pages on your site.\n\nThe **Link** component is an example of a **pre-built component** that you can use in your site. In other words, the Link component is defined and maintained by another package (in this case, the Gatsby package). That means you can import it and use it in your own components without knowing too much about how it works under the hood.\n\n**The Link component lets you add a link to another page in your Gatsby site**. It‚Äôs similar to an HTML ```<a>``` tag, but with some extra **performance benefits**. The Link component takes a **prop called to**, which is similar to the ```<a>``` tag's href attribute. The value should be the URL path to the page on your site you want to link to.\n\n*-- Key Gatsby Concept --* üí°\n\nThe Gatsby Link component provides a **performance feature called preloading**. **This means that the resources for the linked page are requested when the link scrolls into view or when the mouse hovers on it. That way, when the user actually clicks on the link, the new page can load super quickly**.\n\nUse the Link component for linking between pages within your site. For external links to pages not created by your Gatsby site, use the regular HTML ```<a>``` tag.\n\n*--*\n\nFollow the steps below to add Link components to your Home and About pages.\n\nOn the Home page, import the Link component from the Gatsby package and add a link to your About page.\n\n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nconst IndexPage = () => {\n  return (\n    <main>\n      <title>Home Page</title>\n      <h1>Welcome to my Gatsby site!</h1>\n      <Link to=\"/about\">About</Link>\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n    </main>\n  )\n}\nexport default IndexPage\n```\n\nOn the About page, import the Link component from the Gatsby package and add a link to your Home page.\n\n*src/pages/about.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nconst AboutPage = () => {\n  return (\n    <main>\n      <title>About Me</title>\n      <h1>About Me</h1>\n      <Link to=\"/\">Back to Home</Link>\n      <p>Hi there! I'm the proud creator of this site, which I built with Gatsby.</p>\n    </main>\n  )\n}\nexport default AboutPage\n```\n\n## Create a reusable layout component\n\nIf you take another look at the finished example blog, you might notice that there are some repeated parts of the UI across each page, like the site title and the navigation menu.\n\nYou could copy those elements into each page of your site separately. But imagine your site had dozens (or even thousands) of pages. If you wanted to make a change to the structure of your navigation menu, you‚Äôd have to go and update every one of those files separately. Yuck.\n\nInstead, it would be better to create one common **Layout component** that groups all the shared elements to **reuse across multiple pages**. That way, when you need to make updates to the layout, you can make the change in one place and it will automatically be applied to all the pages using that component.\n\nIn this section, you‚Äôll create your first custom building-block component: Layout. To do that, you‚Äôll need to use a special React prop called children.\n\nFollow the steps below to create a Layout component and add it to your Home and About pages.\n\nCreate a new file called **src/components/layout.js**. Insert the following code to define your Layout component. This component will render a dynamic page title and heading (from the **pageTitle prop**), a list of navigation links, and the contents passed in with the children prop. To improve accessibility, there's also a ```<main>``` element wrapping the page-specific elements (the ```<h1>``` heading and the contents from children).\n\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    <div>\n      <title>{pageTitle}</title>\n      <nav>\n        <ul>\n          <li><Link to=\"/\">Home</Link></li>\n          <li><Link to=\"/about\">About</Link></li>\n        </ul>\n      </nav>\n      <main>\n        <h1>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\n*Syntax Hint*: You might have noticed that the Layout component uses a slightly different syntax for its props.\n\nNow instead of looking like this:\n\n```\nconst Layout = (props) => {\n  ...\n}\n```\n‚Ä¶it looks like this:\n\n```\nconst Layout = ({ pageTitle, children }) => {\n  ...\n}\n```\n\nThis is a JavaScript technique called **destructuring**.\n\n\nUpdate your Home page component to use the Layout component instead of the hard-coded Link component you added in the previous section.\n\n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst IndexPage = () => {\n  return (\n    <Layout pageTitle=\"Home Page\">\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n    </Layout>\n  )\n}\nexport default IndexPage\n```\nUpdate your About page component to use the Layout component as well.\n*src/pages/about.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst AboutPage = () => {\n  return (\n    <Layout pageTitle=\"About Me\">\n      <p>Hi there! I'm the proud creator of this site, which I built with Gatsby.</p>\n    </Layout>\n  )\n}\nexport default AboutPage\n```\n\n## Style components with CSS Modules\n\nNow that you‚Äôve got your page structure set up, it‚Äôs time to add some style and make it cute!\n\n**Gatsby isn‚Äôt strict about what styling approach you use.** You can pick whatever system you‚Äôre most comfortable with.\n\nIn this Tutorial, you‚Äôll use **CSS Modules to style your components**. This means that **styles will be scoped to components, which helps avoid class naming collisions between components**. **Gatsby is automatically configured to handle CSS Modules** - no extra setup necessary!\n\nFollow the steps below to style your Layout component using CSS Modules.\n\nCreate a new file: *src/components/layout.module.css*. (**The .module.css part at the end is important!** That‚Äôs what tells Gatsby that these styles are using CSS Modules.)\n\nStart by adding a single **.container class**:\n\n*src/components/layout.module.css*\n```\n.container {\n  margin: auto;\n  max-width: 500px;\n  font-family: sans-serif;\n}\n```\n\nThen **import that class into your Layout component .js file**, and use the **className prop** to assign it to the top-level ```<div>``` element:\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nimport { container } from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    <div className={container}>\n      <title>{pageTitle}</title>\n      <nav>\n        <ul>\n          <li><Link to=\"/\">Home</Link></li>\n          <li><Link to=\"/about\">About</Link></li>\n        </ul>\n      </nav>\n      <main>\n        <h1>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n\n```\nSyntax Hint: To apply classes to React components, use the className prop. (This is another example of a built-in prop that React automatically knows how to handle.)\n\nThis might be confusing if you‚Äôre used to using the class attribute on HTML elements. Do your best to not mix them up!\n\nNow that you‚Äôve seen how to style a single element for your component, add some more styles to apply to the other elements in your Layout component.\n*src/components/layout.module.css*\n```\n.container {\n  margin: auto;\n  max-width: 500px;\n  font-family: sans-serif;\n}\n.heading {\n  color: rebeccapurple;\n}\n.nav-links {\n  display: flex;\n  list-style: none;\n  padding-left: 0;\n}\n.nav-link-item {\n  padding-right: 2rem;\n}\n.nav-link-text {\n  color: black;\n}\n```\n\nImport the new classes into your Layout component, and apply each class to the corresponding element.\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    <div className={container}>\n      <title>{pageTitle}</title>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\n*Syntax Hint*: In CSS, the convention is to name classes using kebab case (like .nav-links). But in JavaScript, the convention is to name variables using camel case (like navLinks).\n\nLuckily, when you use CSS Modules with Gatsby, you can have both! **Your kebab-case class names in your .module.css files will automatically be converted to camel-case variables that you can import in your .js files.**\n\n## Key takeaways\n\n- React is a library that helps you break down your UI into smaller pieces called components. A component is a function that returns a React element. React elements can be written in JSX.\n- **Page components** contain all the UI elements for a specific page of your site. Gatsby automatically creates pages for components that are the default exports of files in the src/pages directory. The name of the file will be used as the route for the page.\n- **Building-block components** are smaller reusable parts of your UI. They can be imported into page components or other building block components.\n- You **can import pre-built components (like Link) **from other packages, or you can write your own custom components from scratch (like Layout).\n- You can use **props to change how a component renders**. You can define your own props when you build a component. **React also has some built-in props, like *children* and *className***.\n- Gatsby isn‚Äôt opinionated about what styling approach you want to use, but it works with CSS Modules by default.\n\n","references":"- [Use and Style React Components](https://www.gatsbyjs.com/docs/tutorial/part-2/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-use-react-components","weblink":"https://codersnack.com/gatsbyjs-use-react-components","featured_image_preview":{"id":135,"name":"gatsbyjs-logo.png","hash":"ea8f1f34862a4e29a0e2a777accbaa3e","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/ea8f1f34862a4e29a0e2a777accbaa3e.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T20:02:39.096Z","updated_at":"2021-11-03T20:02:39.096Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - use react components","created_at":"2021-11-03T20:03:14.305Z","updated_at":"2021-11-03T20:03:14.310Z"},{"id":99,"codersnack":{"id":100,"header":"GatsbyJS - Add Features with Plugins","created_at":"2021-11-03T20:33:43.718Z","updated_at":"2021-11-03T20:40:12.105Z","explanation":"It can be a lot of work to build new features for a website. Luckily, **by using Gatsby plugins, you can quickly add new functionality to your site without needing to build it from scratch yourself**. Gatsby‚Äôs plugin ecosystem has thousands of prebuilt packages for you to choose from.\n\nIn this part of the Tutorial, you‚Äôll learn what Gatsby plugins are and how to use them in your site.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Use the Gatsby Plugin Library to browse all the available plugins.\n- Add a plugin to your Gatsby site.\n- Configure your plugins in your gatsby-config.js file.\n\n \n## What is a plugin?\n\nIn Gatsby terms, **a plugin is a separate npm package that you install to add extra features to your site.**\n\nThere are a variety of plugins that each have different use cases. Some plugins provide pre-built components, others add analytics, others let you pull data into your site. **Some plugins are built by Gatsby employees, while other plugins are built and maintained by community members**. So far, there are more than 2,600 plugins to choose from. You can look through all the available plugins using the [Gatsby Plugin Library](https://www.gatsbyjs.com/plugins).\n\nYou can think of a plugin as an accessory for your site. **You don‚Äôt need to use plugins - you could build out the same functionality from scratch yourself - but they save you time**. They‚Äôre like those fancy single-purpose cooking gadgets that peel apples or crush garlic. You could accomplish the same task using a regular knife, but it‚Äôs often faster to use a tool that‚Äôs built to do that one specific job really well.\n\n**You will likely use plugins in almost every Gatsby site you build**. While working through the rest of the Tutorial, you‚Äôll have many opportunities to practice installing and using plugins.\n\n## Add a plugin to your site\n\nTo add a plugin to your site, you‚Äôll use the following process:\n\n- Install the plugin using npm.\n- Configure the plugin in your site‚Äôs **gatsby-config.js** file.\n- Use the plugin features in your site, as needed.\n\n![gatsbyj-plugin-process](https://codersnack.com/assets/images/gatsbyj-plugin-process.png)\n\nThe next few sections will walk you through the process of adding a plugin to your site. You‚Äôll use the **gatsby-plugin-image** plugin to **add performant images to your site**.\n\n### Task: Use gatsby-plugin-image to add a static image to your home page\n\nYou can use the gatsby-plugin-image plugin to **add responsive images to your site** while maintaining high performance scores. **gatsby-plugin-image exports a component called *StaticImage***, which you can **use to load images from a remote URL or your local filesystem**.\n\nFollow the steps below to use the *StaticImage* component to add an image from a URL to your home page.\n\nIn the terminal, run the following command to install gatsby-plugin-image and its dependencies.\n```\nnpm install gatsby-plugin-image gatsby-plugin-sharp gatsby-source-filesystem\n```\n\nThe *StaticImage* component requires a few additional plugins to work. These extra plugins are called peer dependencies, and you‚Äôll need to install them along with the gatsby-plugin-image package:\n\n- **gatsby-plugin-sharp**: **Handles the actual image processing** that is used by gatsby-plugin-image.\n- **gatsby-source-filesystem**: Lets you **pull in data from your computer‚Äôs filesystem**. (You‚Äôll learn more about this plugin later. Just install it for now.)\n*Tip*: When adding a new plugin to your site, check the plugin README in the Gatsby Plugin Library to see if there are any special setup instructions.\n\nNext, add the gatsby-plugin-image and gatsby-plugin-sharp plugins to your gatsby-config.js file. (Don‚Äôt worry about gatsby-source-filesystem just yet. You‚Äôll come back to it later.)\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    \"gatsby-plugin-image\",\n    \"gatsby-plugin-sharp\",\n  ],\n};\n```\n\n*-- Key Gatsby Concept üí° --*\n\nThe **gatsby-config.js** file is a special file that **Gatsby recognizes automatically**. It‚Äôs **where you add plugins and other site configuration**.\n\n**After you update your gatsby-config.js file, your local development server has to restart in order to pick up the new changes**. Sometimes it will restart itself automatically, but if you‚Äôre seeing unexpected behavior, try stopping and restarting it yourself.\n*--.--*\n\nNow that your plugins have been installed and configured, you can use the *StaticImage* component in your Gatsby site! You can use the StaticImage component similarly to the way you‚Äôd use an HTML ```<img>`` tag.\n\nThe StaticImage component expects the following props:\n\n- **src** (string): The URL to the image you want to load. (This is the same as what you put in the src attribute of an <img> HTML element.)\n- **alt** (string): The alt text to describe the image. This gets used by screen readers or if there‚Äôs a problem loading the image.\n\nFind an image URL online, and then use the StaticImage component to add that image to your home page:\n\n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nimport { StaticImage } from 'gatsby-plugin-image'\nconst IndexPage = () => {\n  return (\n    <Layout pageTitle=\"Home Page\">\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n      <StaticImage\n        alt=\"Clifford, a reddish-brown pitbull, posing on a couch and looking stoically at the camera\"\n        src=\"https://pbs.twimg.com/media/E1oMV3QVgAIr1NT?format=jpg&name=large\"\n      />\n    </Layout>\n  )\n}\nexport default IndexPage\n```\n\n\n### Task: Update the static image to use a photo from your local filesystem\n\nSo far, you‚Äôve used the StaticImage component to add an image from an external URL. But what happens if you want to use a photo that isn‚Äôt on the internet yet?\n\nYou can also use the **StaticImage component to render images from your local filesystem**.\n\nDownload a photo to your computer, and move it into your project folder. To keep things organized, put it in the **src/images directory**.\nUpdate the src prop in your home page to be a relative path to your file instead of a URL. \n*src/pages/index.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nimport { StaticImage } from 'gatsby-plugin-image'\nconst IndexPage = () => {\n  return (\n    <Layout pageTitle=\"Home Page\">\n      <p>I'm making this by following the Gatsby Tutorial.</p>\n      <StaticImage\n        alt=\"Clifford, a reddish-brown pitbull, dozing in a bean bag chair\"\n        src=\"../images/clifford.jpg\"\n      />\n    </Layout>\n  )\n}\nexport default IndexPage\n```\n\n## Key takeaways\n\n- A plugin is a package that lets you add new features to your site.\n- Using plugins saves you development time, since it‚Äôs faster to install and configure a plugin than it is to recreate the same functionality from scratch.\n- The general process for using a plugin is to install it, configure it in your gatsby-config.js file, and then use it in your site as needed.\n- You can use the Gatsby Plugin Library to browse all the available plugins and learn more about how each one works.\n","references":"- [Add Features with Plugins](https://www.gatsbyjs.com/docs/tutorial/part-3/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-add-features-plugin","weblink":"https://codersnack.com/gatsbyjs-add-features-plugin","featured_image_preview":{"id":136,"name":"gatsbyjs-logo.png","hash":"d5c7695a7e414e2092c1fa04adade080","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/d5c7695a7e414e2092c1fa04adade080.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T20:33:43.733Z","updated_at":"2021-11-03T20:33:43.733Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - add new features with plugins","created_at":"2021-11-03T20:34:14.631Z","updated_at":"2021-11-03T20:34:14.639Z"},{"id":100,"codersnack":{"id":101,"header":"GatsbyJS - Query for Data with GraphQL","created_at":"2021-11-03T22:21:47.461Z","updated_at":"2021-11-03T22:29:18.918Z","explanation":"So far, you‚Äôve been writing text and adding images directly in your React components. That‚Äôs an excellent way to build many websites! **But often it‚Äôs easier to create and maintain data somewhere else - like a folder of Markdown files or a content management system (CMS) - and then pull it into your components as needed**. That way, you can make updates to your content without affecting the code for your site.\n\nConveniently, **Gatsby has a powerful feature called the data layer** that you can use to pull data into your site from anywhere. Want to keep your blog posts in WordPress, your store products in Shopify, and your user data in Airtable? No problem! With **Gatsby‚Äôs data layer, you can combine data from multiple sources**, which lets you choose the best platform for each type of data.\n\n**Gatsby‚Äôs data layer is powered by a technology called *GraphQL***. **GraphQL is a query language with a special syntax that lets you ask for the data you need inside a component**.\n\nIn this Tutorial, we‚Äôll teach you all the GraphQL you‚Äôll need to know to build your first Gatsby site. Interested in learning more? How To GraphQL is a free tutorial that teaches you the fundamentals.\n\nIn this part of the Tutorial, you‚Äôll learn about how to add data to Gatsby‚Äôs data layer and how to pull that data into your React components.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Use GraphiQL to explore the data in the data layer and build your own **GraphQL queries**.\n- Use the **useStaticQuery** hook to pull data into a ‚Äúbuilding-block‚Äù component.\n- Use the gatsby-source-filesystem plugin to pull data into your site from your computer‚Äôs filesystem.\n- Create a **page query** to pull data into a page component.\n\n## Meet Gatsby‚Äôs GraphQL data layer\n\n**Gatsby has its own GraphQL data layer where it keeps all the data for your site**. But how does it work under the hood?\n\nFirst, **your data is stored in one or more source**s. That source might be a folder on your computer‚Äôs filesystem, a content management system (CMS) like WordPress, or a database. You might even have multiple data sources!\n\nHow do you get data from its source into the data layer? By adding a type of plugin to your site called a source plugin. **Each source plugin is designed to communicate with a specific source**. **When you build your site, each source plugin pulls data from its particular source and adds it to your site‚Äôs GraphQL data layer**.\n\n*Tip*: Curious what source plugins are in the Plugin Library? You can identify source plugins by their name: they typically start with gatsby-source-.For example, a few popular source plugins are gatsby-source-filesystem and gatsby-source-contentful.\n\nHow do you get data back out of the data layer? **You can write GraphQL queries inside of your components to pull out the data you want to use in your site**. When you build your site, Gatsby will find all the GraphQL queries in your components, run them, and put the resulting data in your component.\n\n![gatsbyjs-data-layert](https://codersnack.com/assets/images/gatsbyjs-data-layer.png)\n\n## Use GraphiQL to explore the data layer and write GraphQL queries\n\nHow do you know what data is in your site‚Äôs GraphQL data layer? **When you start the local development server for your site, Gatsby automatically creates a special endpoint that lets you use an in-browser tool called GraphiQL**. With GraphiQL, you can explore your site‚Äôs data and build GraphQL queries.\n\nFollow the steps below to open the GraphiQL interface:\n\nStart up your local development server by running gatsby develop.\nIn a web browser, go to *http://localhost:8000/___graphql*. (That‚Äôs three underscores in the URL.)\n\n![gatsbyjs-graphiql](https://codersnack.com/assets/images/gatsbyjs-graphiql.png)\n\n###¬†A closer look at the GraphiQL interface\n\nThere are three main sections of the GraphiQL interface:\n\n- **Explorer**: This is the section on the left, which shows you **all the different kinds of data you can request in a GraphQL query**.You can toggle the dropdowns to expand the different fields and see what kinds of data are available in the data layer. The blue items correspond to the different data fields you can query for. The purple items accept additional arguments that you can use to filter down the data returned in the response.\n- **Query Editor**: This is the middle section, which you can use to **write out a query to test**. You can add fields to your query by checking the boxes for different fields in the Explorer pane. Or, if you‚Äôd prefer, you can type the fields directly into the Query Editor. (Pro Tip: You can press **Ctrl + Space on your keyboard to bring up an autocompletion** box that shows what fields are available to you.). To execute the query in the Query Editor, click the ‚ÄúExecute Query‚Äù button (it looks like a ‚Äúplay‚Äù triangle button) at the top of the page.\n- **Result Window**: This is the section on the right, which shows you **the result of running the query in the Query Editor**.\n\n**GraphiQL** is a **helpful tool for testing out your GraphQL queries** before you add them to your code. That way, you can make sure your queries always respond with the data you expect.\n\nTry creating and running a few queries by doing the following:\n\n- Check a few of the blue fields in the Explorer pane. Note how checking the box for a field adds it to the query in the Query Editor.\n\n- Click the button at the top of the page (that looks like a ‚Äúplay‚Äù button) to execute the query. Look at the data returned in the Result window.\n\nIn the next section, you‚Äôll learn more about how to use specific fields. For now, take a minute or two to explore the different fields. What kinds of data are already available to you in the data layer?\n\n### Queries in building-block components: Pull the site title into the Layout component\n\nNow that you‚Äôve seen the general process for how data works in your Gatsby site, it‚Äôs time to try it out yourself.\n\n**The process for using GraphQL queries in your components looks slightly different depending on whether it‚Äôs a page component or a building-block component**.\n\nIn this first section, **you‚Äôll start by pulling data into a building-block component**. To do that, you‚Äôll **update your Layout component to pull in the title of your site**.\n\n#### Task: Use GraphiQL to build the query\n\nLook in your **gatsby-config.js** file. There‚Äôs already some information there about your site, in the **siteMetadata** object.\n\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    // ...\n  ],\n};\n```\n\n**This data was added to your gatsby-config.js file automatically when you used the gatsby** new command in Part 1. It also gets pulled into the GraphQL data layer automatically, so **you don‚Äôt need a source plugin for this first section**.\n\nSince you don‚Äôt need to set up a source plugin, you can jump straight into GraphiQL to build your GraphQL query:\n\nIn your web browser, go to localhost:8000/___graphiql to see the GraphiQL interface.\nIn the Explorer pane, open the dropdown for the site field.\nWithin the site field, open the second dropdown for the siteMetadata field (the blue one). This corresponds to the siteMetadata object in your gatsby-config.js file.\n\n*-- Seeing Double? --*\n\nYou might have noticed that there are two different dropdowns for siteMetadata (and for every field under the site dropdown).\n\nThe first one (the purple one with a colon, siteMetadata:) is actually an argument attached to the site field. **You can use the purple dropdowns to filter which pieces of data from the data layer get returned in the response**. (You‚Äôll see an example of this later on.)\n\nThe second one (**the blue one** without a colon, siteMetadata) is what you‚Äôll use more frequently. **This one adds the actual siteMetadata field to your query**, which tells GraphQL to include that field in your response data.\n\nTry toggling each of the dropdowns in the Explorer and see how the query in the Query Editor pane changes. What differences do you notice?\n*--.--*\n\nWithin **siteMetadata**, check the box next to the title field. The query in your query editor should look like this:\n```\nquery MyQuery {\n  site {\n    siteMetadata {\n      title\n    }\n  }\n}\n```\n\nClick the Execute Query button (the ‚Äúplay‚Äù triangle at the top of the page) to run the query. The response in the Result Window should look something like the object below. Notice **how the structure of the data object in the response matches the structure of the fields in the query.**\n```\n{\n  \"data\": {\n    \"site\": {\n      \"siteMetadata\": {\n        \"title\": \"My First Gatsby Site\"\n      }\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nTry changing the value of the title property in your **gatsby-config.js file**. When you save the file, your site should rebuild, and when it‚Äôs finished you can re-run the query in GraphiQL and see your updated data.\n\n### Task: Use useStaticQuery to pull the site title into the Layout component\n\nNow that you have a GraphQL query that returns the data you‚Äôre looking for, how do you use that query in your React components?\n\n**To pull data into a building-block component, you‚Äôll use a pre-defined function from Gatsby called *useStaticQuery*.**\n\n**-- Key Gatsby Concept --**  :  **Pulling data into building-block components with *useStaticQuery***\nThe Gatsby package has a special pre-defined hook that lets you add GraphQL queries to your building-block components: **useStaticQuery**.\n\n**useStaticQuery takes one parameter: a templated string of the GraphQL query you want to run**. It returns the requested data, which you can store in a variable and then use throughout your component.\n\nHere‚Äôs a brief outline of the process for adding useStaticQuery to pull data into your building-block components:\n\n - **Import the useStaticQuery hook and the *graphql* tag from the gatsby package**. The **graphql tag is something called a tagged template literal**. Basically, the graphql tag tells Gatsby that the string following it is a GraphQL query, so then Gatsby can parse and run it.\n```\nimport { useStaticQuery, graphql } from 'gatsby'\n```\n\nInside your component, call useStaticQuery using the graphql template tag and your query from GraphiQL. Store the results in a new variable so that you can use it later in your component.\n```\nconst data = useStaticQuery(graphql`\n  // Copy-paste your query from GraphiQL here, and delete the query name \"MyQuery\"\n`)\n```\n\n**Use the data in your component** by using the dot operator (.) to access the appropriate field off the response.\nHere‚Äôs a small example to show what this process looks like in practice:\n\n*src/components/header.js*\n```\nimport * as React from 'react'\n// Step 1: Import the useStaticQuery hook and graphql tag\nimport { useStaticQuery, graphql } from 'gatsby'\nconst Header = () => {\n  /* Step 2: Use the useStaticQuery hook and\n    graphql tag to query for data\n    (The query gets run at build time) */\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <header>\n      {/* Step 3: Use the data in your component */}\n      <h1>{ data.site.siteMetadata.title }</h1>\n    </header>\n  )\n}\nexport default Header\n```\n\n*Note*: **You can only call useStaticQuery once per file**. If you need multiple fields, you can add them all into a single query.For example, if you need data from both the site field and the siteBuildMetadata field, you could make the following call to useStaticQuery:\n\n```\nconst data = useStaticQuery(graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    siteBuildMetadata {\n      buildTime\n    }\n  }\n`)\n```\n\n* --.-- *\n\nFollow the steps below to use useStaticQuery to pull in the site title from your site metadata into your Layout component.\n\nImport the useStaticQuery function and the graphql tag from the Gatsby package.\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  return (\n    // ...\n  )\n}\nexport default Layout\n```\nCall useStaticQuery and pass it the query you created in GraphiQL. Be sure to use the graphql tag so Gatsby knows that the string you‚Äôre passing in is a GraphQL query. Store the return value from useStaticQuery in a variable.\n\n*Note*: By default, the query you build in GraphiQL will have a query name, like MyQuery. You may see an error if you have more than one query with the same name, so after you copy your query over from GraphiQL to your component, delete the name (as in the code example below).\n\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    // ...\n  )\n}\nexport default Layout\n```\n\n*Note*: If you add a line to print out the value of your data variable to the console, you‚Äôll see that the response has a slightly different structure from what it looked like in GraphiQL‚Äôs Result Window. Specifically, your data variable will only contain the object that matches the data field in the Result Window.\n\nSo if your GraphiQL Result Window showed this:\n\n```\n{\n  \"data\": {\n    \"site\": {\n      \"siteMetadata\": {\n        \"title\": \"My First Gatsby Site\"\n      }\n    }\n  },\n  \"extensions\": {}\n}\n``` \n\nthen your data variable will have the following structure:\n\n```\n{\n  \"site\": {\n    \"siteMetadata\": {\n      \"title\": \"My First Gatsby Site\"\n    }\n  }\n}\n```\n\nNow that you have a variable with the results of your query, you can render the title of your site in the JSX for your Layout component. To access the site title, use the JavaScript dot operator (.) to get the value of data.site.siteMetadata.title. Add it so it appears in both the browser tab and at the top of your page content.\n\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <div className={container}>\n      <title>{pageTitle} | {data.site.siteMetadata.title}</title>\n      <header>{data.site.siteMetadata.title}</header>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\nNow that the site title is showing up on the page, it‚Äôs time to add some style! Define some styles for the site title below the existing styles in your layout.module.css file.\n*src/components/layout.module.css*\n```\n/* ... your existing styles */\n.site-title {\n  font-size: 3rem;\n  color: gray;\n  font-weight: 700;\n  margin: 3rem 0;\n}\n```\n\nImport your new styles into your Layout component and apply them to the site title paragraph you added.\n*src/components/layout.js*\n```\nimport * as React from 'react'\nimport { Link, useStaticQuery, graphql } from 'gatsby'\nimport {\n  container,\n  heading,\n  navLinks,\n  navLinkItem,\n  navLinkText,\n  siteTitle,\n} from './layout.module.css'\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <div className={container}>\n      <title>{pageTitle} | {data.site.siteMetadata.title}</title>\n      <header className={siteTitle}>{data.site.siteMetadata.title}</header>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\nCongratulations, you‚Äôve just used **GraphQL** to pull data into your site! Try changing the site title in your gatsby-config.js file and see your site update in the browser.\n\n### Queries in page components: Create a blog page with a list of post filenames\n\nSo far, your site has a few static landing pages: the Home page and the About page. The next step is to build out the actual blog page!\n\nEventually, **your blog page will link to separate pages for each of your posts**. But there‚Äôs a lot to learn to achieve that, so you‚Äôll be working up to that goal over the next few parts of the Tutorial (Parts 4, 5, and 6).\n\nIn this part, **you‚Äôll create a blog page that lists the filenames for your posts.**\n\n### Task: Create a new blog page\n\nStart by setting up the skeleton for your new blog page component.\n\nCreate a **new file: src/pages/blog.js**. Define and export a new page component for your blog page. Use your existing Layout component to add some basic structure.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport Layout from '../components/layout'\nconst BlogPage = () => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <p>My cool posts will go in here</p>\n    </Layout>\n  )\n}\nexport default BlogPage\n```\n\nAdd a link to your new blog page to the navigation bar in your Layout component:\n*src/components/layout.js*\n```\n// ... import statements\nconst Layout = ({ pageTitle, children }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <div className={container}>\n      <title>{pageTitle} | {data.site.siteMetadata.title}</title>\n      <header className={siteTitle}>{data.site.siteMetadata.title}</header>\n      <nav>\n        <ul className={navLinks}>\n          <li className={navLinkItem}>\n            <Link to=\"/\" className={navLinkText}>\n              Home\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/about\" className={navLinkText}>\n              About\n            </Link>\n          </li>\n          <li className={navLinkItem}>\n            <Link to=\"/blog\" className={navLinkText}>\n              Blog\n            </Link>\n          </li>\n        </ul>\n      </nav>\n      <main>\n        <h1 className={heading}>{pageTitle}</h1>\n        {children}\n      </main>\n    </div>\n  )\n}\nexport default Layout\n```\n\nNow, if you go to *localhost:8000/blog* in your web browser, you should see your new blog page skeleton, and there should be a link to the blog page in your navigation bar.\n\n### Task: Create some MDX blog posts\nNow that you have a blog page, it‚Äôs time to create some blog posts! For your site, you‚Äôll store each blog post as a separate file inside of a folder in your project.\n\nCreate a **new directory called blog at the top level of your project folder.**\n\n**Create three new files in the blog directory: one for each post**. It doesn‚Äôt matter what you name them, as long as **they end with the .mdx extension**. (You‚Äôll learn more about the powers of MDX in Part 5.) You can leave the files empty for now.\n\n### Task: Use GraphiQL to build the query\nNow that **you have some posts saved to your local filesystem**, it‚Äôs time to **pull those files into the Gatsby data layer**. To do that, you‚Äôll use a **plugin called *gatsby-source-filesystem***.\n\n*Note*: Remember the process for adding a plugin to your site from Part 3? The first step was to install the plugin.\n\nIf you‚Äôve been following along from the beginning, you should already have installed gatsby-source-filesystem in Part 3 (because you needed it for adding static images with gatsby-plugin-image).\n\nOtherwise, you can install the plugin by running the following command from the command line:\n\n```\nnpm install gatsby-source-filesystem\n```\n\nConfigure gatsby-source-filesystem in your gatsby-config.js file. Since gatsby-source-filesystem requires some additional configuration options, you‚Äôll use a configuration object instead of a string. The code example below shows **how to ‚Äúsource‚Äù files from your blog directory** (in other words, how to add them to the data layer).\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My First Gatsby Site\",\n  },\n  plugins: [\n    \"gatsby-plugin-image\",\n    \"gatsby-plugin-sharp\",\n    {\n      resolve: \"gatsby-source-filesystem\",\n      options: {\n        name: `blog`,\n        path: `${__dirname}/blog`,\n      }\n    },\n  ],\n};\n```\n\nA closer look at the configuration options:\n\n**When your site builds, gatsby-source-filesystem adds all the files in the folder specified by the path option to the data layer**.\n- **__dirname**: is a variable from Node.js that stores the absolute path for the directory that contains the file currently being run.)\n\n- The **name** option in the configuration object gets set to the **sourceInstanceName** field for each file. This comes in handy when you want to source files from multiple folders. **By giving each folder a different name option, you can build GraphQL queries that filter down to only a particular folder**.\n\nRestart your local development server to make sure it picks up the configuration changes and adds your files to the data layer.\n\nYou can use the **allFile** field to **request data about multiple files at once**. In GraphiQL, try exploring the different fields within allFile to see what sorts of data you get back. Then build a query using the allFile field to get the name of all the files in your blog folder:\n\n```\nquery MyQuery {\n  allFile {\n    nodes {\n      name\n    }\n  }\n}\n```\n\nRun the query in GraphiQL. Your response in the Result Window should look something like the object below:\n```\n{\n  \"data\": {\n    \"allFile\": {\n      \"nodes\": [\n        {\n          \"name\": \"my-first-post\"\n        },\n        {\n          \"name\": \"another-post\"\n        },\n        {\n          \"name\": \"yet-another-post\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\n**-- Seeing more nodes than expected? --**\nIf you‚Äôre still using a StaticImage from an external URL (like https://some-site/image.jpg) on your home page, you‚Äôll see an extra node for that image show up in your GraphQL response. That‚Äôs because StaticImage uses \n**createRemoteFileNode**\n under the hood which **creates a File node for each image it downloads**. **If you‚Äôre only using images from your filesystem, you won‚Äôt see the extra node**.\n\nTo get rid of it, **you can update your GraphQL query to filter the File nodes using the sourceInstanceName field** (which corresponds to the value of the name option you set for gatsby-source-filesystem in your gatsby-config.js file).\n\n*src/pages/blog.js*\n```\nquery {\n  allFile(filter: {sourceInstanceName: {eq: \"blog\"}}) {\n    nodes {\n      name\n    }\n  }\n}\n```\n\n***filter* is an argument that gets passed into the allFile field**. Some fields take arguments, which you can use to change the way that nodes get returned in your final GraphQL response.\n\n### Task: Use a page query to pull the list of post filenames into your blog page\n\nNow that you‚Äôve built a GraphQL query that returns a list of your post filenames, it‚Äôs time to render that data in your blog page!\n\n**Using GraphQL queries in page components uses a slightly different syntax from queries in building-block components**. In page components, you use page queries.\n\n**-- Key Gatsby Concept --** :  Pulling data into page components with page queries\nThe process for making a query in a page component looks slightly different from useStaticQuery:\n\n- **Import the graphql tag** from the Gatsby package.\n- **Export a variable that stores a templated string with the GraphQL query you want to run**. When your site gets built, **Gatsby will run your page query and pass the resulting data into your page component as a prop called *data***. **Your page query needs to be defined outside of your page component**. (With useStaticQuery, your query was defined inside your component.)\n- Use the data prop in your page component, as needed. You can use the JavaScript dot operator (.) to choose fields off of the data prop.\n\nHere‚Äôs a small example to show what this process looks like in practice:\n\n```\nimport * as React from 'react'\n// Step 1: Import the graphql tag\nimport { graphql } from 'gatsby'\nconst HomePage = ({ data }) => {\n  return (\n    <p>\n      { /* Step 3: Use the data in your component*/ }\n      { data.site.siteMetadata.description }\n    </p>\n  )\n}\n// Step 2: Export a page query\nexport const query = graphql`\n  query {\n    site {\n      siteMetadata {\n        description\n      }\n    }\n  }\n`\nexport default HomePage\n```\n\n\n**--.--**\n\nFollow the steps below to add a list of post filenames to your blog page.\n\nImport the graphql tag from the Gatsby package.\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = () => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <p>My cool posts will go in here</p>\n    </Layout>\n  )\n}\nexport default BlogPage\n```\nDefine and export your page query. Copy over the query you built in GraphiQL.\nNote: By default, the query you build in GraphiQL will have a query name, like MyQuery. You may see an error if you have more than one query with the same name, so after you copy your query over from GraphiQL to your component, delete the name (as in the code example below).\n\nAlternatively, you can give each of your queries a unique name. Query names can be useful for debugging errors that show up in your console when Gatsby executes your queries at build time.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = () => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <p>My cool posts will go in here</p>\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allFile {\n      nodes {\n        name\n      }\n    }\n  }\n`\nexport default BlogPage\n``` \n\nAdd in the data prop to the function definition. Then replace the placeholder ```<p>``` element with a list of the filenames for your posts. Use the ```JavaScript array .map()``` method to iterate over the nodes array and render the filename for each post.\n\n.map() takes in a function, which it runs on each element in the array. In the code block below, you‚Äôre using .map() to loop over each of the nodes in data.allFile.nodes and return a React element that wraps the node‚Äôs name in an ```<li>``` element.\n\nIn React, when you use the .map() method to render a list of elements, you should give **each element in the list a unique key prop**. This helps React keep track of what values have changed and need to be rerendered. For more on rendering lists in React, check out the React Docs: Lists and Keys.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      <ul>\n      {\n        data.allFile.nodes.map(node => (\n          <li key={node.name}>\n            {node.name}\n          </li>\n        ))\n      }\n      </ul>\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allFile(filter: {sourceInstanceName: {eq: \"blog\"}}) {\n      nodes {\n        name\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nGood job! You‚Äôve finished the first step of your new blog page.\n\nYou won‚Äôt be able to render the contents of your posts just yet, since your site doesn‚Äôt know how to process MDX. You‚Äôll fix that in the next part of the Tutorial!\n\n## Summary\n\nTake a moment to think back on what you‚Äôve learned so far. Challenge yourself to answer the following questions from memory:\n\n- How do you get data into the data layer?\n- How can you see what data is in the data layer?\n- How do you get data out of the data layer?\n- What are the differences between a page query and useStaticQuery? How would you decide which one to use?\n\n## Key takeaways\n\n- Source plugins pull data from their original location into the Gatsby GraphQL data layer.\n- You can use the GraphiQL endpoint (localhost:8000/___graphql) to explore the data in the data layer and design GraphQL queries.\n- You can write GraphQL queries to pull data out of the data layer and into your React components.\n- To pull data into a ‚Äúbuilding block‚Äù component, use the useStaticQuery hook.\n- To pull data into a page component, use a page query.\n\n**-- Key Gatsby Concept --** : General process for using data in your site\n- Add a source plugin to add data into the GraphQL data layer.\n- Use GraphiQL to design a query that responds with the data you want from the data layer.\n- Add the query into your component.\n- Use page queries for page components.\n- Use useStaticQuery for ‚Äúbuilding block‚Äù components.\n- Use the data from the response in your component.\n**--.--**","references":"- [Query for Data with GraphQL](https://www.gatsbyjs.com/docs/tutorial/part-4/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-graphql","weblink":"https://codersnack.com/gatsbyjs-graphql","featured_image_preview":{"id":137,"name":"gatsbyjs-logo.png","hash":"c658d1c9999840f8ac797906ee5d5773","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/c658d1c9999840f8ac797906ee5d5773.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T22:21:47.480Z","updated_at":"2021-11-03T22:21:47.480Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - query for data with GraphQL","created_at":"2021-11-03T22:22:43.365Z","updated_at":"2021-11-03T22:22:43.374Z"},{"id":101,"codersnack":{"id":102,"header":"GatsbyJS - Transform Data to Use MDX","created_at":"2021-11-04T12:40:44.462Z","updated_at":"2021-11-04T12:40:44.462Z","explanation":"In Part 4, you used the gatsby-source-filesystem source plugin to build a Blog page that lists the names of your blog post files. But **you weren‚Äôt able to actually render the contents of your post files**, because gatsby-source-filesystem doesn‚Äôt provide a field for it. To do that,**you‚Äôll need another type of plugin called a *transformer* plugin**.\n\nSometimes, the format of the data you get from source plugins isn‚Äôt exactly what you want to use to build your website. For example, the filesystem source plugin lets you query data about files, but it doesn‚Äôt let you use the data inside the files themselves. To make this possible, **Gatsby supports transformer plugins, which take the raw content from source plugins and transform it into something more usable**.\n\nIn this part of the Tutorial, you‚Äôll learn about one particular transformer plugin, **gatsby-plugin-mdx**, which **lets you use MDX, a file format that allows Markdown and JSX alongside your text content**. (Fun fact: this Tutorial is actually written in MDX!) You‚Äôll use MDX to add some content to your blog post files, and then you‚Äôll use gatsby-plugin-mdx to render the contents of your posts on your Blog page.\n\n> ***Note***: Usually, transformer plugin names start with **gatsby-transformer-**. (*gatsby-plugin-mdx is one exception* to this convention.) To see a list of other transformer plugins, try searching for gatsby-transformer- in the Gatsby Plugin Library.\n\nBy the end of this part of the Tutorial, you will be able to:\n\n- Write an MDX file with Markdown formatting and frontmatter.\n- Use the gatsby-plugin-mdx plugin to render the contents of your MDX files on your Blog page.\n- Use the sort field to control the order of results in your GraphQL queries.\n\n##¬†A closer look at Gatsby‚Äôs GraphQL data layer\n\nTo understand how gatsby-plugin-mdx and other transformer plugins work, you need to know a bit more about how Gatsby‚Äôs GraphQL data layer works.\n\n**Inside the data layer, information is stored in objects called *nodes***. A **node is the smallest form unit of data in the data layer**. **Different source plugins create different types of nodes, each of which have their own properties**. For example, gatsby-source-filesystem creates File nodes.\n\n**A transformer plugin converts nodes from one type to another**. For example, **the gatsby-plugin-mdx plugin transforms File nodes that have the .mdx extension into MDX nodes**, which have a different set of fields that you can query using GraphQL. **Transformer plugins let you manipulate the raw data in the nodes created by source plugins, so that you can get it into the structure or format you need.**\n\n![Gatsby data layer](https://codersnack.com/assets/images/gatsbyjs-data-layer-with-nodes.png)\n\n> ***Note***: Even though it‚Äôs called a transformer plugin, it‚Äôs not actually changing the original nodes created by the source plugins. Each transformer plugin creates new nodes based on the data from the sourced nodes, but it doesn‚Äôt actually change the source nodes themselves. So even though gatsby-plugin-mdx creates new MDX nodes in the data layer, you can still access the original File nodes created by gatsby-source-filesystem.\n\n##¬†Add some MDX content to your blog posts\n\nIn Part 4, you created empty files for your blog posts. Now, it‚Äôs time to fill them in!\n\n> **-- Using Markdown formatting in MDX --**\nMDX files let you format text using Markdown, a markup language that uses a special syntax to add special formatting to your text elements. For example, you can make text appear strong by wrapping it in **double asterisks**, or you can create a link by using a syntax like [text to link](url).\nOnce you get used to what all the different symbols mean, **Markdown can be easier to read than HTML**, which makes it a popular format for written content like blog posts.\nNew to Markdown? The **MDX documentation includes a table of components** that shows the different formatting options available. It includes things like *headings*, *blockquotes*, *lists*, and *code blocks*.\n**Frontmatter**\n**With gatsby-plugin-mdx, you can also add frontmatter to your MDX files.** Frontmatter is **additional metadata about your file**. It won‚Äôt be rendered on your page, but **it‚Äôs a way for you to add some extra details about your content**. For example, you might store your post title or the date it was published.\nTo add frontmatter to your post, put it between an opening and closing set of **three hyphens (---) at the top of your MDX file**. Within the opening and closing hyphens, you can create **key-value pairs for any kind of data you want to store about your file**.\nHere‚Äôs an example: \n```\n---\nname: \"Fun Facts about Red Pandas\"\ndatePublished: \"2021-07-12\"\nauthor: \"#1 Red Panda Fan\"\n---\n```\n\nAdd some Markdown content to each of the .mdx files you created in your /blog directory in Part 4. Include frontmatter with fields for the title of each post and the date it was published. (Give each post a different date, to make it easier to add sorting later on.) After the frontmatter, write some post content using some Markdown syntax.\n\nHere are some example posts that you can use for inspiration:\n\n*blog/my-first-post.mdx*\n```\n---\ntitle: \"My First Post\"\ndate: \"2021-07-23\"\n---\nThis is my first blog post! Isn't it *great*?\nSome of my **favorite** things are:\n* Petting dogs\n* Singing\n* Eating potato-based foods\n```\n\n*blog/another-post.mdx*\n```\n---\ntitle: \"Another Post\"\ndate: \"2021-07-24\"\n---\nHere's another post! It's even better than the first one!\n```\n\n*blog/yet-another-post.mdx*\n```\n---\ntitle: \"Yet Another Post\"\ndate: \"2021-07-25\"\n---\n```\n\nWow look at all this content. How do they do it?\n\n###¬†Render each post‚Äôs contents on the Blog page\nNow that you have some MDX content inside your blog posts, it‚Äôs time set up the gatsby-plugin-mdx transformer plugin.\n\n> ***Quick Refresher***: Remember the process for adding a plugin to your site (from Part 3)? See if you can remember the three steps from memory before checking your answer. (Science has shown that the act of trying to actively recall information helps you retain it better!)\n\nThe **gatsby-plugin-mdx plugin provides some new tools for you to use** in your site:\n\n- The **allMdx** and **mdx** fields (for your GraphQL queries)\n- An **MDXRenderer component** (for processing and displaying MDX content)\n\nTo render your posts on the Blog page, you‚Äôll complete a few different steps:\n\n- Install and configure the gatsby-plugin-mdx transformer plugin and its dependencies.\n- **Update the Blog page query to use the allMdx field from gatsby-plugin-mdx instead of allFile**.\n- **Use the MDXRenderer component from gatsby-plugin-mdx to render your post‚Äôs MDX contents in the JSX for your Blog page.**\n\n#### Task: Install and configure the MDX transformer plugin (and dependencies)\nThe gatsby-plugin-mdx package requires a few **additional dependencies to run**: **@mdx-js/mdx** (which implements MDX) and **@mdx-js/react** (which maps the MDX implementation to React components).\n\nIn your terminal, run the command below to install gatsby-plugin-mdx and its dependencies. (This adds all three packages to the dependencies object in your package.json file and to your node_modules directory.)\n\n```\nnpm install gatsby-plugin-mdx @mdx-js/mdx @mdx-js/react\n```\n\nAdd gatsby-plugin-mdx to the plugins array in your gatsby-config.js file, so that Gatsby knows to use the plugin when building your site.\n\n*gatsby-config.js*\n```\nmodule.exports = {\n  siteMetadata: {\n    title: \"My Super Cool Blog\",\n  },\n  plugins: [\n    \"gatsby-plugin-image\",\n    \"gatsby-plugin-sharp\",\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `blog`,\n        path: `${__dirname}/blog/`,\n      },\n    },\n    \"gatsby-plugin-mdx\",\n  ],\n};\n```\n> *Tip*: There are a variety of remark plugins that you can use to add extra features to your Markdown. You can configure them using the **gatsbyRemarkPlugins** option when you configure gatsby-plugin-mdx in your gatsby-config.js file.\nHere are some popular remark plugins:\n1.- **gatsby-remark-images**: Use this if you want to **generate responsive images when using the Markdown image syntax** (which looks like this: ![alt](image url)). To use this plugin, you‚Äôll also **need gatsby-plugin-sharp**, which you installed already in Part 3.\n2.- **gatsby-remark-prismjs**: Add syntax highlighting to your code blocks.\n3.- **gatsby-remark-autolink-headers**: **Automatically create links for all the headers in your Markdown content.**\nTry searching for gatsby-remark- in the Gatsby Plugin Library for a full list.\n\n#### Task: Update the Blog page query to use the allMdx field instead of allFile\nThe gatsby-plugin-mdx plugin makes two new fields available for you to use in your GraphQL queries: **allMdx** and **mdx**. In this part of the Tutorial, you‚Äôll use allMdx to add the contents of each blog post to your Blog page. (You‚Äôll use the mdx field later on, in Part 6.)\n\n**You can use the allMdx field to request data for multiple MDX nodes at once** (similar to the way allFile worked with File nodes). Open GraphiQL and explore what fields are available on MDX nodes. Try running a few queries to see what kind of information you get back.\n\n> *Quick Refresher*: Remember how to access GraphiQL? See if you can remember the steps before checking for the answer in Part 4. (Check the section called ‚ÄúUse GraphiQL to explore the data layer and write GraphQL queries‚Äù).\n\n**Use GraphiQL to create a new query that gets data about your blog posts using the allMdx field instead of the allFile field**.\n\nUnder allMdx, open the nodes dropdown. Inside the frontmatter dropdown, you should see fields for all the keys you created in the frontmatter of your MDX files. Select the title and date fields. You can use the formatString argument on the date field to change the way your dates are displayed (see Syntax Hint below).\n```\nquery MyQuery {\n  allMdx {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n    }\n  }\n}\n```\n\n> Syntax Hint: When it comes to using dates in your frontmatter, the **formatString argument** is a helpful tool for changing the way the date is displayed.\nImagine you have a key in your frontmatter with a value that uses a date format like \"YYYY-MM-DD\". (It doesn‚Äôt matter what you name the key, as long as the value has the required format.) GraphiQL will automatically detect that your value is a date, and when you select the corresponding frontmatter field in the Explorer pane, GraphiQL will automatically show a few arguments that you can pass to that field. One of those arguments is called formatString, which you can pass a **Moment.js formatting token** to change the way the date displays.\nFor example, if your MDX frontmatter looks like this:\n```\n---\ndate: \"2021-07-23\"\n---\n```\n\n‚Ä¶and your GraphQL query looks like this:\n\n```\nquery MyQuery {\n  allMdx {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n      }\n    }\n  }\n}\n```\n‚Ä¶then the dates in your response will look like this: \"July 23, 2021\".\n\n------\n\nWhile you‚Äôre at it, **add the id field, which is a unique string that Gatsby automatically adds to every node in the data layer**. (You‚Äôll use this as a **React key** later on, when you iterate over your list of posts.)\n\n```\nquery MyQuery {\n  allMdx {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n      id\n    }\n  }\n}\n``` \n\nExecute your query by clicking the triangle button. Your response object should look something like this:\n\n```\n{\n  \"data\": {\n    \"allMdx\": {\n      \"nodes\": [\n        {\n          \"frontmatter\": {\n            \"date\": \"July 25, 2021\",\n            \"title\": \"Yet Another Post\"\n          },\n          \"id\": \"c4b5ae6d-f3ad-5ea4-ab54-b08a72badea1\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 23, 2021\",\n            \"title\": \"My First Post\"\n          },\n          \"id\": \"11b3a825-30c5-551d-a713-dd748e7d554a\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 24, 2021\",\n            \"title\": \"Another Post\"\n          },\n          \"id\": \"560896e4-0148-59b8-9a2b-bf79bee68fba\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nYou might notice that your posts aren‚Äôt listed in order. Most blog sites **list their posts in reverse-chronological order,** so that the newest posts are listed first. **You can sort the data nodes in your response by using the sort argument on the allMdx field**.\n\n- In the Explorer pane, toggle the **sort dropdown underneath the allMdx **field.\n- Under sort, check the fields argument, and use the dropdown to select which field you want to sort your data nodes by. In this case, that would be **frontmatter___date** (with three underscores).\n- Check the order argument, and use the dropdown to select DESC. This will sort the nodes in descending order, so that the newest posts come first.\n```\nquery MyQuery {\n  allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n      id\n    }\n  }\n}\n```\n\nRun your query again to verify that the posts come back in the correct order. Your response should look something like this:\n\n```\n{\n  \"data\": {\n    \"allMdx\": {\n      \"nodes\": [\n        {\n          \"frontmatter\": {\n            \"date\": \"July 25, 2021\",\n            \"title\": \"Yet Another Post\"\n          },\n          \"id\": \"c4b5ae6d-f3ad-5ea4-ab54-b08a72badea1\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 24, 2021\",\n            \"title\": \"Another Post\"\n          },\n          \"id\": \"560896e4-0148-59b8-9a2b-bf79bee68fba\"\n        },\n        {\n          \"frontmatter\": {\n            \"date\": \"July 23, 2021\",\n            \"title\": \"My First Post\"\n          },\n          \"id\": \"11b3a825-30c5-551d-a713-dd748e7d554a\"\n        }\n      ]\n    }\n  },\n  \"extensions\": {}\n}\n```\n\nThe last thing you need to add to your query is the contents of each post! To do that, add the body field to your query.\n\n```\nquery MyQuery {\n  allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n    nodes {\n      frontmatter {\n        date(formatString: \"MMMM D, YYYY\")\n        title\n      }\n      id\n      body\n    }\n  }\n}\n```\n\nWhen you run your query, the body field for each node should look something like the data shown below. That‚Äôs a lot of information! The body field actually contains the compiled MDX content for your file. It might not be readable for humans, but it‚Äôs the format that the MDXRenderer component understands. (You‚Äôll get to MDXRenderer in a moment.)\n\n```\n\"body\": \"var _excluded = [\\\"components\\\"];\\n\\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\\n\\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\\n\\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\\n\\n/* @jsxRuntime classic */\\n\\n/* @jsx mdx */\\nvar _frontmatter = {\\n  \\\"title\\\": \\\"Yet Another Post\\\",\\n  \\\"date\\\": \\\"2021-07-25\\\"\\n};\\nvar layoutProps = {\\n  _frontmatter: _frontmatter\\n};\\nvar MDXLayout = \\\"wrapper\\\";\\nreturn function MDXContent(_ref) {\\n  var components = _ref.components,\\n      props = _objectWithoutProperties(_ref, _excluded);\\n\\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\\n    components: components,\\n    mdxType: \\\"MDXLayout\\\"\\n  }), mdx(\\\"p\\\", null, \\\"Wow look at all this content. How do they do it?\\\"));\\n}\\n;\\nMDXContent.isMDXComponent = true;\"\n```\n\nNow that you have your GraphQL query all set up, it‚Äôs time to tackle the last piece of the puzzle: rendering your posts in the Blog page.\n\n> *Pro Tip*: When transformer plugins create a new node, they add a parent field that references back to the original source node it was created from. For example, when gatsby-plugin-mdx creates new MDX nodes, **it adds a parent field which you can use to access data from the original File node**.\nUsing the parent node can come in handy if you want to use data from the transformed nodes along with data from the original source nodes. For example, the query below gives you back the time a file was changed, which you could use to display when a post was last updated.\nquery MyQuery {\n  allMdx {\n    nodes {\n      parent {\n        ... on File {\n          modifiedTime(formatString: \"MMMM D, YYYY\")\n        }\n      }\n    }\n  }\n}\n\n####¬†Task: Use the MDXRenderer component to render your post‚Äôs contents in your Blog page\nNow that your GraphQL query is all set up, it‚Äôs time to replace the page query in your Blog page component.\n\n**Start by swapping out the allFile page query in your Blog page for the one you just created using allMdx**. (Don‚Äôt forget to delete the query name!) And if you haven‚Äôt already from completing the task in Part 4, you‚Äôll need to import the graphql tag from the gatsby package.\n\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport Layout from '../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    // ...\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          date(formatString: \"MMMM D, YYYY\")\n          title\n        }\n        id\n        body\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nNext, **update the JSX for your Blog page to use the data fields of your response**. Start by rendering just the title and date for each post.\n\nNow that you‚Äôre rendering more than just a filename, it makes more sense to use the ```<article>```  semantic HTML element instead of a ```<ul>``` and nested ```<li>``` elements.\nYou can also use the **id field as your unique key prop for each post**. (React uses the key prop to keep track of what elements need to be re-rendered. If you don‚Äôt include it, you‚Äôll get a warning in your browser console. For more on the key prop, check out the React Docs: List and Keys.)\n\n*src/pages/blog.js*\n```\n// imports\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      {\n        data.allMdx.nodes.map((node) => (\n          <article key={node.id}>\n            <h2>{node.frontmatter.title}</h2>\n            <p>Posted: {node.frontmatter.date}</p>\n          </article>\n        ))\n      }\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          title\n          date(formatString: \"MMMM DD, YYYY\")\n        }\n        id\n        body\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n\nThe final step in this part of the Tutorial is to **render the actual contents of your MDX blog posts**. To do that, you‚Äôll need to use a component from gatsby-plugin-mdx called **MDXRenderer**. Start by importing the component into your Blog page:\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport Layout from '../components/layout'\n// ...\n```\n\n**-- The MDXRenderer component --**\nMDXRenderer is a component included in the gatsby-plugin-mdx plugin that you can use to render the contents of a .mdx file.\n\nThe MDXRenderer uses the children prop, similar to the Layout component you created in Part 2. It expects to receive compiled MDX between its opening and closing tags. You can pass in the body field from an MDX node.\n\n> Quick Refresher: Need a reminder of how the children prop works? Refer back to the ‚ÄúCreate a reusable layout component‚Äù section in Part 2.\n\nHere‚Äôs a quick example of how to import and use the MDXRenderer component:\n\n```\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\n// Use this in the JSX for your component\n<MDXRenderer>\n  { node.body }\n</MDXRenderer>\n```\n**--.--**\n\nIn the JSX for your Blog page, use the MDXRenderer component to wrap the contents of the body field for each node:\n*src/pages/blog.js*\n```\nimport * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { MDXRenderer } from 'gatsby-plugin-mdx'\nimport Layout from '../components/layout'\nconst BlogPage = ({ data }) => {\n  return (\n    <Layout pageTitle=\"My Blog Posts\">\n      {\n        data.allMdx.nodes.map((node) => (\n          <article key={node.id}>\n            <h2>{node.frontmatter.title}</h2>\n            <p>Posted: {node.frontmatter.date}</p>\n            <MDXRenderer>\n              {node.body}\n            </MDXRenderer>\n          </article>\n        ))\n      }\n    </Layout>\n  )\n}\nexport const query = graphql`\n  query {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        frontmatter {\n          title\n          date(formatString: \"MMMM DD, YYYY\")\n        }\n        id\n        body\n      }\n    }\n  }\n`\nexport default BlogPage\n```\n![gatsbyjs-blog-page-with-full-posts](https://codersnack.com/assets/images/gatsbyjs-blog-page-with-full-posts.png)\n\n\n","references":"- [Transform Data to Use MDX](https://www.gatsbyjs.com/docs/tutorial/part-5/)","featured_image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","slug":"gatsbyjs-transform-data-mdx","weblink":"https://codersnack.com/gatsbyjs-transform-data-mdx","featured_image_preview":{"id":138,"name":"gatsbyjs-logo.png","hash":"de131704198e492784094b1c5404791f","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/de131704198e492784094b1c5404791f.png","provider":"local","provider_metadata":null,"created_at":"2021-11-04T12:40:44.488Z","updated_at":"2021-11-04T12:40:44.488Z"}},"codersnacks_category":{"id":19,"header":"GatsbyJS","description":"Gatsby enables developers to build **fast**, **secure**, and powerful websites using a **React-based framework** and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple.","snacks_by_cat_json_filename":"gatsbyjs.snacks.json","key":"gatsbyjs","image_url":"https://codersnack.com/assets/images/gatsbyjs-logo.png","created_at":"2021-11-03T16:40:35.871Z","updated_at":"2021-11-03T16:40:35.871Z","image_preview":{"id":133,"name":"gatsbyjs-logo.png","hash":"43be89681abd44d1b57a0727c51f44b4","sha256":"JwaZ8RhB9I9yyZjBISjAU_qdgFuutP8x7hrsrDZYAx0","ext":".png","mime":"image/png","size":15.48,"url":"/uploads/43be89681abd44d1b57a0727c51f44b4.png","provider":"local","provider_metadata":null,"created_at":"2021-11-03T16:40:35.913Z","updated_at":"2021-11-03T16:40:35.913Z"}},"title":"gatsbyjs - transform data to use MDX","created_at":"2021-11-04T12:41:22.709Z","updated_at":"2021-11-04T12:41:22.719Z"}]