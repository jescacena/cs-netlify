[{"id":166,"codersnack":{"id":162,"header":"RxJS - Introduction","created_at":"2022-03-23T11:08:22.443Z","updated_at":"2022-03-23T15:50:28.587Z","explanation":"Brand new to RxJS? In this article we will take a crash course through all the major concepts you will need to begin getting a grasp on, and start being productive with RxJS. Hold on tight and let's get started!\n\n## What is an Observable?\n\n**An observable represents a stream, or source of data that can arrive over time**. You can create an observable from nearly anything, but the most common use case in RxJS is from events. This can be anything from mouse moves, button clicks, input into a text field, or even route changes. The easiest way to create an observable is through the built in creation functions. For example, we can use the fromEvent helper function to create an observable of mouse click events:\n```\n// import the fromEvent operator\nimport { fromEvent } from 'rxjs';\n\n// grab button reference\nconst button = document.getElementById('myButton');\n\n// create an observable of button clicks\nconst myObservable = fromEvent(button, 'click');\n```\n\nAt this point we have an observable but it's not doing anything. This is because observables are cold, or do not activate a producer (like wiring up an event listener), until there is a...\n\n\n##  Subscription\n\n**Subscriptions are what set everything in motion**. You can think of this like a faucet, you have a stream of water ready to be tapped (observable), someone just needs to turn the handle. In the case of observables, that role belongs to the subscriber.\n\n**To create a *subscription*, you call the subscribe method, supplying a function (or object) - also known as an *observer***. This is where you can decide how to react(-ive programming) to each event. Let's walk through what happens in the previous scenario when a subscription is created:\n\n```\n// import the fromEvent operator\nimport { fromEvent } from 'rxjs';\n\n// grab button reference\nconst button = document.getElementById('myButton');\n\n// create an observable of button clicks\nconst myObservable = fromEvent(button, 'click');\n\n// for now, let's just log the event on each click\nconst subscription = myObservable.subscribe(event => console.log(event));\n```\n\nIn the example above, calling **myObservable.subscribe() **will:\n- Set up an event listener on our button for click events.\n- Call the function we passed to the subscribe method (observer) on each click\nevent.\n- Return a subscription object with an unsubscribe which contains clean up\nlogic, like removing appropriate event listeners.\n\n**The subscribe method also accepts an object map to handle the case of error or completion**. You probably won't use this as much as simply supplying a function, but it's good to be aware of should the need arise:\n\n```\n// instead of a function, we will pass an object with next, error, and complete methods\nconst subscription = myObservable.subscribe({\n  // on successful emissions\n  next: event => console.log(event),\n  // on errors\n  error: error => console.log(error),\n  // called once on completion\n  complete: () => console.log('complete!')\n});\n```\n\n**It's important to note that each subscription will create a new execution context.** This means calling subscribe a second time will create a new event listener:\n\n```\n// addEventListener called\nconst subscription = myObservable.subscribe(event => console.log(event));\n\n// addEventListener called again!\nconst secondSubscription = myObservable.subscribe(event => console.log(event));\n\n// clean up with unsubscribe\nsubscription.unsubscribe();\nsecondSubscription.unsubscribe();\n```\n\n**By default, a subscription creates a one on one, one-sided conversation between the observable and observer**. This is like your boss (the observable) yelling (emitting) at you (the observer) for merging a bad PR. This is also known as **unicasting**. If you prefer a conference talk scenario - one observable, many observers - you will take a different approach which includes **multicasting** with **Subjects** (either explicitly or behind the scenes). More on that in a future article!\n\nIt's worth noting that when we discuss an Observable source emitting data to observers, this is a **push based model**. The source doesn't know or care what subscribers do with the data, it simply pushes it down the line.\n\nWhile working on a stream of events is nice, it's only so useful on its own. What makes RxJS the \"lodash for events\" are its...\n\n\n##  Operators\n\n**Operators offer a way to manipulate values from a source, returning an observable of the transformed values**. Many of the RxJS operators will look familiar if you are used to JavaScripts Array methods. For instance, if you want to **transform emitted values from an observable source, you can use *map***:\n\n```\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n/*\n *  'of' allows you to deliver values in a sequence\n *  In this case, it will emit 1,2,3,4,5 in order.\n */\nconst dataSource = of(1, 2, 3, 4, 5);\n\n// subscribe to our source observable\nconst subscription = dataSource\n  .pipe(\n    // add 1 to each emitted value\n    map(value => value + 1)\n  )\n  // log: 2, 3, 4, 5, 6\n  .subscribe(value => console.log(value));\n```\n\nOr if you want to **filter for specific values, you can use *filter***:\n\n```\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst dataSource = of(1, 2, 3, 4, 5);\n\n// subscribe to our source observable\nconst subscription = dataSource\n  .pipe(\n    // only accept values 2 or greater\n    filter(value => value >= 2)\n  )\n  // log: 2, 3, 4, 5\n  .subscribe(value => console.log(value));\n```\n\nIn practice, **if there is a problem you need to solve, it's more than likely there is an operator for that**. And while the sheer number of operators can be overwhelming as you begin your RxJS journey, **you can narrow it down to a small handful (and we will) to start being effective**. Over time, you will come to appreciate the flexibility of the operator library when obscure scenarios inevitably arrive.\n\nOne thing you may have noticed in the example above, is operators exist within a...\n\n\n### Pipe\n\n**The pipe function is the assembly line from your observable data source through your operators**. Just like raw material in a factory goes through a series of stops before it becomes a finished product, **source data can pass through a pipe-line of operators where you can manipulate, filter, and transform the data to fit your use case**. It's not uncommon to use 5 (or more) operators within an observable chain, contained within the pipe function.\n\nFor instance, a typeahead solution built with observables may use a group of operators to optimize both the request and display process:\n\n```\n// observable of values from a text box, pipe chains operators together\ninputValue\n  .pipe(\n    // wait for a 200ms pause\n    debounceTime(200),\n    // if the value is the same, ignore\n    distinctUntilChanged(),\n    // if an updated value comes through while request is still active cancel previous request and 'switch' to new observable\n    switchMap(searchTerm => typeaheadApi.search(searchTerm))\n  )\n  // create a subscription\n  .subscribe(results => {\n    // update the dom\n  });\n```\n\nBut how do you know which operator fits your use-case? The good news is...\n**Operators can be grouped into common categories**\n\n> **The first stop when looking for the correct operator is finding a related category**. Need to filter data from a source? Check out the filtering operators. Trying to track down a bug, or debug the flow of data through your observable stream? There are utility operators that will do the trick. The operator categories include...\n\n\n### Creation operators\n\nThese operators allow the **creation of an observable from nearly anything**. From generic to specific use-cases you are free to turn everything into a stream.\n\nFor example, suppose we are creating a progress bar as a user scrolls through an article. We could turn the scroll event into a stream by utilizing the fromEvent operator:\n\n```\nfromEvent(scrollContainerElement, 'scroll')\n  .pipe(\n    // we will discuss cleanup strategies like this in future article\n    takeUntil(userLeavesArticle)\n  )\n  .subscribe(event => {\n    // calculate and update DOM\n  });\n```\n\n> The most commonly used creation operators are **of, from, and fromEvent**.\n\n\n###  Combination operators\n\nThe combination operators allow the **joining of information from multiple observables**. Order, time, and structure of emitted values is the primary variation among these operators.\n\nFor example, we can combine updates from multiple data sources to perform a calculation:\n\n```\n// give me the last emitted value from each source, whenever either source emits\ncombineLatest(sourceOne, sourceTwo).subscribe(\n  ([latestValueFromSourceOne, latestValueFromSourceTwo]) => {\n    // perform calculation\n  }\n);\n```\n\n> The most commonly used combination operators are **combineLatest, concat, merge, startWith, and withLatestFrom**.\n\n\n###  Error handling operators\n\nThe error handling operators **provide effective ways to gracefully handle errors and perform retries, should they occur**.\n\nFor example, we can use catchError to safeguard against failed network requests:\n\n```\nsource\n  .pipe(\n    mergeMap(value => {\n      return makeRequest(value).pipe(\n        catchError(handleErrorByReturningObservable)\n      );\n    })\n  )\n  .subscribe(value => {\n    // take action\n  });\n```\n\n> The most commonly used error handling operators is **catchError**.\n\n###   Filtering operators\n\nThe filtering operators **provide techniques for accepting - or declining - values from an observable source and dealing with backpressure, or the build up of values within a stream**.\n\nFor example, we can use the take operator to capture only the first 5 emitted values from a source:\n\n```\nsource.pipe(take(5)).subscribe(value => {\n  // take action\n});\n```\n\n> The most commonly used filtering operators are **debounceTime, distinctUntilChanged, filter, take, and takeUntil**.\n\n\n###   Multicasting operators\n\nIn RxJS observables are cold, or unicast (one source per subscriber) by default. These operators **can make an observable hot, or multicast, allowing side-effects to be shared among multiple subscribers**.\n\nFor example, we may want late subscribers to share, and receive the last emitted value from an active source:\n\n```\nconst source = data.pipe(shareReplay());\n\nconst firstSubscriber = source.subscribe(value => {\n  // perform some action\n});\n\n// sometime later...\n\n// second subscriber gets last emitted value on subscription, shares execution context with 'firstSubscriber'\nconst secondSubscriber = source.subscribe(value => {\n  // perform some action\n});\n```\n\nThe most commonly used multicasting operator is **shareReplay**.\n\n\n###  Transformation operators\n\nTransforming values as they pass through an operator chain is a common task. These operators **provide transformation techniques for nearly any use-case you will encounter**.\n\nFor example, we may want to accumulate a state object from a source over time, similar to Redux:\n\n```\nsource\n  .pipe(\n    scan((accumulatedState, currentState) => {\n      return { ...accumulatedState, ...currentState };\n    })\n  )\n  .subscribe();\n```\n\n> The most commonly used transformation operators are **concatMap, map, mergeMap, scan, and switchMap**.\n\n\n###  Operators have common behaviors\n\n**While operators can be grouped into common categories, operators within a category often share common behavior**. By recognizing this common behavior you can start creating a 'choose your own operator' tree in your mind.\n\nFor instance, a large amount of operators can be grouped into...\n\n\n####  Operators that flatten\n\nOr, in other words, operators that **manage the subscription of an inner observable, emitting those values into a single observable source**. One common use case for flattening operators is handling HTTP requests in a observable or promise based API, but that is really just scratching the surface:\n\n```\nfromEvent(button, 'click')\n  .pipe(\n    mergeMap(value => {\n      // this 'inner' subscription is managed by mergeMap, with response value emitted to observer\n      return makeHttpRequest(value);\n    })\n  )\n  .subscribe(response => {\n    // do something\n  });\n```\nWe can then divide the flattening operators into common behaviors like...\n\n####  Operators that switch\n\nLike a light switch, **switch based operators will turn off (unsubscribe) the current observable and turn on a new observable on emissions from the source**. Switch operators are useful in situations **you don't want (or need) more than one active observable at a time**:\n```\ninputValueChanges\n  // only the last value is important, if new value comes through cancel previous request / observable\n  .pipe(\n    // make GET request for data\n    switchMap(requestObservable)\n  )\n  .subscribe();\n```\n> Switch based operators include **switchAll, switchMap, and switchMapTo**.\n\n\n####  Operators that concat\n\nComparable to a line at the ATM machine, **the next transaction can't begin until the previous completes**. In observable terms, only one subscription will occur at a time, in order, triggered by the completion of the previous. These are **useful in situations where order of execution is important**:\n\n```\nconcat(\n  firstObservable,\n  // will begin when 'firstObservable` completes\n  secondObservable,\n  // will begin when 'secondObservable` completes\n  thirdObservable\n).subscribe(values => {\n  // take action\n});\n```\n> Concat based operators include **concat, concatAll, concatMap, and concatMapTo**.\n\n\n####  Operators that merge\n\nLike your merging lane on the interstate, **merge based operators support multiple active observables flowing into one lane in a *first come first serve basis*.** Merge operators are useful in situations where **you want to trigger an action when an event from one of many sources occurs**:\n\n```\nmerge(firstObservable, secondObservable)\n  // any emissions from first or second observable as they occur\n  .pipe(mergeMap(saveActivity))\n  .subscribe();\n```\n\n> Merge based operators include **merge, mergeMap, mergeMapTo and mergeAll**.\n\n\n####   Other similarities between operators\n\nThere are also operators that share a similar goal but offer flexibility in their triggers. For instance, for unsubscribing from an observable after a specific condition is met, we could use:\n\n- **take** when we know we only ever want n\nvalues.\n- **takeLast** when you just want the last\nn values.\n- **takeWhile** when we have a predicate\nexpression to supply.\n- **takeUntil** when we only want the\nsource to remain active until another source emits.\n\nWhile the number of RxJS operators can seem overhelming at first, these common behaviors and patterns can bridge the gap rather quickly while learning RxJS.\n\n\n##  What does this get me?\n\nAs you become more familiar with push based programming through Observables, **you can begin to model all async behavior in your applications through observable streams**. This opens up simple solutions and flexibility for notably complex behavior.\n\nFor instance, suppose we wanted to make a request which saved user activity when they answered a quiz question. Our initial implementation may use the mergeMap operator, which fires off a save request on each event:\n\n```\nconst formEvents = fromEvent(formField, 'click');\nconst subscription = formEvents\n  .pipe(\n    map(convertToAppropriateValue),\n    mergeMap(saveRequest)\n  )\n  .subscribe();\n```\n\n**Later, it's determined that we need to ensure order of these saves**. Armed with the knowledge of operator behavior from above, instead of implementing a complex queueing system **we can instead replace the *mergeMap* operator with *concatMap* and push up our changes**:\n\n```\nconst formEvents = fromEvent(formField, 'click');\nconst subscription = formEvents\n  .pipe(\n    map(convertToAppropriateValue),\n    // now the next request won't begin until the previous completes\n    concatMap(saveRequest)\n  )\n  .subscribe();\n```\n\nWith the change of one word we are now queueing our event requests, and this is just scratching the surface of what is possible!\n\n\n##  Keep Going!\n\nLearning RxJS can be intimidating, but it's a path I promise is worth the investment. If some of these concepts are still fuzzy (or make no sense at all!), don't worry! It will all click soon.\n","references":"- [LearnRXJS - RxJS Primer](https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer)","featured_image_url":"https://codersnack.com/assets/images/rxjs-logo.png","slug":"rxjs-introduction","weblink":"https://codersnack.com/rxjs-introduction","featured_image_preview":{"id":202,"name":"rxjs-logo.png","hash":"b9d5c2d784bc4ab3984a7178333c9c94","sha256":"vTH-nccZ57pOSOOF1V2YrY3Wx7C1Wh38ynkbtVxgSMA","ext":".png","mime":"image/png","size":2.41,"url":"/uploads/b9d5c2d784bc4ab3984a7178333c9c94.png","provider":"local","provider_metadata":null,"created_at":"2022-03-23T11:08:22.467Z","updated_at":"2022-03-23T11:08:22.467Z"}},"codersnacks_category":{"id":24,"header":"RxJS","description":"RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code","snacks_by_cat_json_filename":"rxjs.snacks.json","key":"rxjs","image_url":"https://codersnack.com/assets/images/rxjs-logo.png","created_at":"2022-03-23T10:46:50.067Z","updated_at":"2022-03-23T10:46:50.067Z","image_preview":{"id":201,"name":"rxjs-logo.png","hash":"d214d6eb28404b0b8bd1765d4c0eb3cc","sha256":"vTH-nccZ57pOSOOF1V2YrY3Wx7C1Wh38ynkbtVxgSMA","ext":".png","mime":"image/png","size":2.41,"url":"/uploads/d214d6eb28404b0b8bd1765d4c0eb3cc.png","provider":"local","provider_metadata":null,"created_at":"2022-03-23T10:46:50.111Z","updated_at":"2022-03-23T10:46:50.111Z"}},"title":"RxJS - Introduction","created_at":"2022-03-23T15:51:10.387Z","updated_at":"2022-03-23T15:51:10.392Z"}]